00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/16/2021 8:05:55 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler V1.8
00000000                             3  * Written by : Brent and Parker
00000000                             4  * Date       : 3/16/21
00000000                             5  * Description: Final Project for CSS 422
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  ;************************ Define Constants ********************************* 
00000000  =0000000D                  9  CR                  EQU     $0D     ;carriage return
00000000  =0000000A                 10  LF                  EQU     $0a     ;line feed
00000000  =000A0000                 11  stack               EQU     $000A0000
00000000  =0000000F                 12  lines_per_screen    EQU     15
00000000  =00000040                 13  buffer_size         EQU     64      ;size of buffer
00000000  =0000F000                 14  nibble1             EQU     $F000   ;1st nibble in code (bits 15-12)
00000000  =00000F00                 15  nibble2             EQU     $0F00   ;2nd nibble in code (bits 11-8)
00000000  =000000F0                 16  nibble3             EQU     $00F0   ;3rd nibble in code (bits 7-4)
00000000  =0000000F                 17  nibble4             EQU     $000F   ;4th nibble in code (bits 3-0)
00000000  =00000001                 18  right1              EQU     1       ;shift 1 time
00000000  =00000002                 19  right2              EQU     2       ;shift 2 times
00000000  =00000003                 20  right3              EQU     3       ;shift 3 times to extract src mode
00000000  =00000004                 21  right4              EQU     4       ;shift 4 times to extract 3rd nibble
00000000  =00000005                 22  right5              EQU     5       ;shift 5 times (unused)
00000000  =00000006                 23  right6              EQU     6       ;shift 6 times to extract dst mode
00000000  =00000007                 24  right7              EQU     7       ;shift 7 times
00000000  =00000008                 25  right8              EQU     8       ;shift 8 to extract 2nd nibble
00000000  =00000009                 26  right9              EQU     9       ;shift 9 times to check 2nd nibble?
00000000  =0000000A                 27  right10             EQU     10      ;shift 10
00000000  =0000000C                 28  right12             EQU     12      ;shift 12 to extract 3rd byte
00000000  =00000010                 29  right16             EQU     16      ;shift 16 to extract 2nd byte
00000000  =00000018                 30  right24             EQU     24      ;shift 24 to extract 1st byte
00000000  =000001C0                 31  dest_mode           EQU     $01C0   ; --> 0000 0001 1100 0000 (used for destination in MOVE/MOVEA
00000000  =00000E00                 32  dest_reg            EQU     $0E00   ;destination register (0000 0111 0000 0000)
00000000                            33  
00000000  =00000000                 34  ea_type_immediate   EQU     0
00000000  =00000001                 35  ea_type_move        EQU     1
00000000  =00000002                 36  ea_type_movea       EQU     2
00000000  =0000000C                 37  ea_type_movea6      EQU     12
00000000  =00000003                 38  ea_type_lea         EQU     3
00000000  =00000004                 39  ea_type_destonly    EQU     4
00000000  =00000005                 40  ea_type_ext         EQU     5
00000000  =00000006                 41  ea_type_movem       EQU     6
00000000  =00000007                 42  ea_type_trap        EQU     7
00000000  =00000008                 43  ea_type_quick       EQU     8
00000000  =00000009                 44  ea_type_branch      EQU     9
00000000  =0000000A                 45  ea_type_math        EQU     10
00000000  =0000000B                 46  ea_type_rotation    EQU     11
00000000                            47  
00001000                            48      ORG    $1000
00001000                            49  START:                              ;first instruction of program
00001000  4FF9 000A0000             50      LEA     stack, SP               ;SP @ $A0000
00001006                            51  
00001006                            52  
00001006                            53  
00001006                            54  ;********************************** Welcome Message ******************************************** 
00001006                            55  WELCOME:
00001006  43F9 000021D8             56      LEA     welcome_message,A1      ;load the welcome message into A1
0000100C  103C 000E                 57      MOVE.B  #14,D0
00001010  4E4F                      58      TRAP    #15                     ;print contents of welcome_message
00001012                            59  
00001012                            60  
00001012                            61  ;*********************************** Get Starting Address *************************************** 
00001012                            62  GET_STARTING_ADDRESS:
00001012                            63      ;prompt for address
00001012  103C 000E                 64      MOVE.B  #14,D0    
00001016  43F9 000021F6             65      LEA     get_start_address,A1    ;load the get_start_address message into A1
0000101C  4E4F                      66      TRAP    #15                     ;print get_start_address
0000101E                            67      
0000101E                            68      ;get user input address, store, and convert
0000101E  43F9 000023B8             69      LEA     ascii_start,A1          ;store
00001024  103C 0002                 70      MOVE.B  #2,D0                   ;get user input    
00001028  4E4F                      71      TRAP    #15                     ;another trap to get input
0000102A  4EB9 0000182A             72      JSR     ATOI                    ;address is now in hex format in memory location
00001030                            73      
00001030                            74      
00001030                            75      ;at this point our address is in D4 in hex
00001030                            76      ;check if > 0
00001030  B8BC 00000000             77      CMP.L   #0,D4                       ;compare to D4
00001036  6F00 08BE                 78      BLE     STARTA_ERROR_LESS_THAN_ZERO ;branch to ERROR_LESS_THAN_ZERO if less than 0
0000103A                            79      
0000103A                            80      ;?? MOVE.L  (A1),D3
0000103A                            81      
0000103A                            82      ;address is > 0 so check if even / odd
0000103A  E29C                      83      ROR.L   #1,D4
0000103C  6500 08C8                 84      BCS     STARTA_ERROR_NOT_EVEN
00001040  E39C                      85      ROL.L   #1,D4    
00001042                            86      
00001042                            87      ;address is > 0 and verified even
00001042  2A39 000023B8             88      MOVE.l    (ascii_start),D5      ;load into A5
00001048  2A45                      89      MOVE.l    D5,A5                ;load into A5
0000104A                            90  
0000104A                            91  
0000104A                            92  ;******************************** Get Ending Address ******************************************** 
0000104A                            93  GET_ENDING_ADDRESS:
0000104A                            94      ;prompt for address 
0000104A  103C 000E                 95      MOVE.B  #14,D0
0000104E  43F9 00002227             96      LEA     get_end_address,A1      ;load the get_end_address message into A1  
00001054  4E4F                      97      TRAP    #15                     ;print get_end_address
00001056                            98      
00001056                            99      ;get user input address, store, and convert
00001056  43F9 000023CC            100      LEA     ascii_end,A1            ;store 
0000105C  103C 0002                101      MOVE.B  #2,D0                   ;get user input
00001060  4E4F                     102      TRAP    #15                     ;another trap to get intput
00001062  4EB9 0000182A            103      JSR ATOI
00001068                           104  
00001068                           105      ;perform checks:
00001068                           106      ;1.) even
00001068  E29C                     107      ROR.L   #1,D4
0000106A  6500 08AA                108      BCS     ENDA_ERROR_NOT_EVEN
0000106E  E39C                     109      ROL.L   #1,D4    
00001070                           110      
00001070                           111      ;2.) less than 00FFFFFF
00001070  B8BC 00FFFFFF            112      CMP.L   #$00FFFFFF,D4
00001076  6C00 08AE                113      BGE     ENDA_ERROR_LARGE    
0000107A                           114      
0000107A                           115      ;3.) greater than starting address
0000107A  BBC4                     116      CMP.L   D4,A5
0000107C  6C00 08B8                117      BGE     ENDA_ERROR_LESS_THAN_STARTA
00001080                           118      
00001080                           119      ;good --> store in A6
00001080  2C39 000023CC            120      MOVE.l    (ascii_end),D6      ;load into D6
00001086  2C46                     121      MOVE.l    D6,A6               ;load into A6
00001088                           122  
00001088                           123  
00001088                           124  ;************************************ Main Loop???? ***********************************************
00001088                           125  ;get pointer to first given address
00001088                           126  ;pull hex code from that address and store in A1?
00001088                           127  ;take hex code and go to OP_TABLE
00001088                           128  
00001088                           129  
00001088                           130  ;A5 = starting address
00001088                           131  ;A6 = ending address
00001088                           132  START_DECODING:
00001088  4282                     133      CLR.L   D2                             ;clear screen line counter
0000108A                           134  
0000108A                           135  DECODING_LOOP:
0000108A  4EB9 00001112            136      JSR     OP_START                       ;get complete line of instruction to decode   
00001090                           137  
00001090                           138      ;RETURN FROM OP FINISH HERE
00001090                           139      
00001090                           140      ;print buffer to screen
00001090  103C 000D                141      MOVE.B  #$0D, D0
00001094  43F9 000023E0            142      LEA     buffer,A1
0000109A  4E4F                     143      TRAP    #15
0000109C                           144      
0000109C                           145      ;check if we have hit ending address (current memory past ending address)
0000109C  BDCD                     146      CMP.L   A5,A6       ;THE SOURCE OPERAND IS SUBTRACTED FROM THE DESTINATION OPERAND (A6-A5)--> (600 - 400)
0000109E  6F00 0016                147      BLE     REPEAT_OR_FINISH
000010A2                           148      
000010A2                           149      ;CHECK FOR FFFF
000010A2  0C55 FFFF                150      CMP.W   #$FFFF,(A5)
000010A6  6700 000E                151      BEQ     REPEAT_OR_FINISH
000010AA                           152      
000010AA  5202                     153      ADDI.B  #1,D2
000010AC  B43C 000F                154      CMP.B   #lines_per_screen,D2
000010B0  6C00 0046                155      BGE     FILLED_SCREEN
000010B4  60D4                     156      BRA     DECODING_LOOP
000010B6                           157      
000010B6                           158  REPEAT_OR_FINISH:    
000010B6  103C 000E                159      MOVE.B  #14,D0
000010BA  43F9 0000236C            160      LEA     prompt_again,A1
000010C0  4E4F                     161      TRAP    #15
000010C2                           162      
000010C2                           163      ;get user input
000010C2  103C 0002                164      MOVE.B  #2,D0
000010C6  43F9 00002460            165      LEA     ascii_y_or_n,A1
000010CC  4E4F                     166      TRAP    #15
000010CE                           167      
000010CE                           168      ;check user input and handle accordingly
000010CE  4243                     169      CLR     D3
000010D0  1639 00002460            170      MOVE.B  ascii_y_or_n,D3
000010D6  0C03 0079                171      CMPI.B  #'y',D3
000010DA  6700 FF36                172      BEQ     GET_STARTING_ADDRESS
000010DE  0C03 0059                173      CMPI.B  #'Y',D3
000010E2  6700 FF2E                174      BEQ     GET_STARTING_ADDRESS
000010E6  0C03 006E                175      CMPI.B  #'n',D3
000010EA  6700 0022                176      BEQ     DONE
000010EE  0C03 004E                177      CMPI.B  #'N',D3
000010F2  6700 001A                178      BEQ     DONE
000010F6                           179      
000010F6                           180      ;nothing was entered, try again
000010F6  60BE                     181      BRA     REPEAT_OR_FINISH    
000010F8                           182  
000010F8                           183  FILLED_SCREEN:
000010F8  103C 000E                184      MOVE.B  #14,D0
000010FC  43F9 00002354            185      LEA     prompt_enter,A1
00001102  4E4F                     186      TRAP    #15
00001104  103C 0005                187      MOVE.B  #$05,D0
00001108  4E4F                     188      TRAP    #15
0000110A  6000 FF7C                189      BRA     START_DECODING  
0000110E                           190         
0000110E                           191  DONE:
0000110E  FFFF FFFF                192      SIMHALT                                 ; halt simulator
00001112                           193  
00001112                           194  
00001112                           195  
00001112                           196  ;************************************ OP Stuff *************************************************************************************************************************** 
00001112                           197  
00001112                           198  ;A0 = POINTER TO OP_TABLE???
00001112                           199  ;A1 = 
00001112                           200  ;A2 = buffer (this is our decoded string that will print to screen)
00001112                           201  ;A3 = 
00001112                           202  ;A4 = current memory address for buffer (used for clearing????)
00001112                           203  ;A5 = starting address / current address in memory
00001112                           204  ;A6 = ending address
00001112                           205  ;A7 = SP
00001112                           206  
00001112                           207  ;D0
00001112                           208  ;D1
00001112                           209  ;D2 = ?
00001112                           210  ;D3 = buffer size (used for loop = 64)
00001112                           211  ;D4 = 
00001112                           212  ;D5
00001112                           213  ;D6
00001112                           214  ;D7
00001112                           215  
00001112                           216  OP_START
00001112                           217      ;get complete line? 
00001112                           218      ;everything happens in here
00001112                           219      
00001112  48E7 2000                220      MOVEM.L         D2, -(SP)
00001116                           221  
00001116  4EB9 0000114E            222      JSR         OP_DATA_CLR         ;clear buffer
0000111C  45F9 000023E0            223      LEA         buffer, A2          ;A2 now points to buffer, which is cleared
00001122                           224      
00001122                           225  
00001122                           226      ;print out current mem address by putting into buffer and then adding a ' ' (tab)
00001122  7403                     227      MOVE.L      #$0003,D2           ;? BINARY --> 0011 ?
00001124  4EB9 000018AA            228      JSR         ITOA_ADDRESS        ;convert A5 (current address) to ASCII and put in buffer
0000112A  14FC 0009                229      MOVE.B      #$09, (A2)+         ;adds a ' ' to buffer
0000112E                           230      
0000112E                           231      ;at this point buffer has the memory address and a space, ready for op code                     !!TESTED UP UNTIL THIS POINT AND GOOD!!
0000112E                           232      
0000112E  41F9 00001164            233      LEA         OP_TABLE, A0
00001134  4280                     234      CLR.L       D0
00001136  301D                     235      MOVE.W      (A5)+,D0            ;moves opcode from current address into D0
00001138  2200                     236      MOVE.L      D0,D1               ;should move into D1
0000113A  143C 000C                237      MOVE.B      #right12,D2         ;move immediate value 12 into D2
0000113E  E469                     238      LSR.W       D2,D1               ;shift D1 by 12 bits, leaving just 4 bits (this is our opcode???)
00001140  C2FC 0006                239      MULU        #6,D1               ;computes opcode table jump displacement
00001144  4EF0 1000                240      JMP         0(A0,D1)            ;jumps to opcode table entry (A0 = OP_TABLE)
00001148                           241  
00001148                           242  OP_FINISH:
00001148  4CDF 0004                243      MOVEM.L     (SP)+,D2
0000114C  4E75                     244      RTS                             ;returns to DECODING_LOOP !?!?!?!?!?
0000114E                           245  
0000114E                           246  
0000114E                           247  OP_DATA_CLR:
0000114E  4283                     248      CLR.L       D3                  ; ? What is D3????
00001150                           249      ;MOVE.B      #buffer_size,D3     ; put 64 into D3
00001150  163C 0040                250      MOVE.B      #64,D3          ; put 10 into D3                                                                 ;delete after testing and use 64
00001154  49F9 000023E0            251      LEA         buffer, A4          ; what address register?
0000115A                           252  
0000115A                           253  OP_DATA_CLR_LOOP:
0000115A  18FC 0000                254      MOVE.B      #0, (A4)+
0000115E  5343                     255      SUBI        #1, D3
00001160  6EF8                     256      BGT         OP_DATA_CLR_LOOP
00001162  4E75                     257      RTS                                 ;need RTS to return
00001164                           258  
00001164                           259  
00001164                           260  ;********************************* jump table ****************************************
00001164                           261  OP_TABLE:
00001164  4EF9 000011C4            262      JMP         opcode0000              ;ORI (ANDI, SUBI, ADDI, EORI, CMPI)                                 $0
0000116A  4EF9 000011DE            263      JMP         opcode0001              ;MOVE.B                                                             $1    
00001170  4EF9 000011E4            264      JMP         opcode0010              ;MOVEA.L, MOVE.L                                                    $2
00001176  4EF9 000011FE            265      JMP         opcode0011              ;MOVEA.W MOVE.W                                                     $3
0000117C  4EF9 00001218            266      JMP         opcode0100              ;NOP, MOVEM, LEA (CLR, NOT, EXT, TRAP, STOP, RTE, RTS, JSR, JMP     $4
00001182  4EF9 00001232            267      JMP         opcode0101              ;ADDQ (SUBQ)                                                        $5
00001188  4EF9 0000124E            268      JMP         opcode0110              ;BRA.bw, BSR.bw (BEQ)                                               $6
0000118E  4EF9 00001268            269      JMP         opcode0111              ;MOVEQ.l                                                            $7
00001194  4EF9 0000126E            270      JMP         opcode1000              ;DIVU (DIVS, OR)                                                    $8
0000119A  4EF9 0000128A            271      JMP         opcode1001              ;SUB                                                                $9
000011A0  4EF9 00001290            272      JMP         opcode1010              ;not assigned                                                       $A
000011A6  4EF9 00001296            273      JMP         opcode1011              ;CMP (EOR)                                                          $B
000011AC  4EF9 0000129C            274      JMP         opcode1100              ;MULU (MULS, AND)                                                   $C
000011B2  4EF9 000012B8            275      JMP         opcode1101              ;ADD, ADDA                                                          $D
000011B8  4EF9 000012D4            276      JMP         opcode1110              ;ASL, ASR (LSL, LSR, ROL, ROR)                                      $E
000011BE  4EF9 000012F4            277      JMP         opcode1111              ;not assigned                                                       $F
000011C4                           278  
000011C4                           279  
000011C4                           280  
000011C4                           281  
000011C4                           282  ;A0 = POINTER TO OP_TABLE???
000011C4                           283  ;A1 = 
000011C4                           284  ;A2 = buffer (this is our decoded string that will print to screen)
000011C4                           285  ;A3 = pointer to op_xxx_table
000011C4                           286  ;A4 = current memory address for buffer (used for clearing????)
000011C4                           287  ;A5 = starting address / current address in memory
000011C4                           288  ;A6 = ending address
000011C4                           289  ;A7 = SP
000011C4                           290  
000011C4                           291  ;D0 = full instruction
000011C4                           292  ;D1 = full instruction for manipulating (temporary)
000011C4                           293  ;D2 = will store immediate value for comparing
000011C4                           294  ;D3 = buffer size (used for loop = 64)
000011C4                           295  ;D4 = 
000011C4                           296  ;D5 = 
000011C4                           297  ;D6 = 
000011C4                           298  ;D7 = 
000011C4                           299  
000011C4                           300  
000011C4                           301  
000011C4                           302  ;ORI (ANDI, SUBI, ADDI, EORI, CMPI)                                 $0
000011C4                           303  opcode0000:                                 
000011C4  2200                     304      MOVE.L      D0,D1                   ;D1 has full instruction
000011C6  0241 0F00                305      ANDI.W      #nibble2,D1             ;check bits 11,10,9,8
000011CA  143C 0008                306      MOVE.B      #right8, D2             ;store immediate value 8 in D2
000011CE  E469                     307      LSR.W       D2, D1                  ;shift to isolate next nibble (bits 11-8)
000011D0  C2FC 0006                308      MULU        #6, D1                  ;multiply by 6 to get displacement
000011D4  47F9 000012FA            309      LEA         OP_0000_TABLE, A3       ;load op_0000_table into address register
000011DA  4EF3 1000                310      JMP         0(A3,D1)                ;jumps to opcode table entry (A0 = OP_TABLE)
000011DE                           311  
000011DE                           312  ;MOVE.B                                                             $1
000011DE                           313  opcode0001:
000011DE  4EF9 000014E2            314      JMP         OP_MOVEB                ;no need to break down, only MOVE.B
000011E4                           315  
000011E4                           316  
000011E4                           317  ;MOVEA.L, MOVE.L                                                    $2
000011E4                           318  opcode0010:
000011E4  2200                     319      MOVE.L      D0,D1                   ;D1 has full instruction
000011E6  0241 01C0                320      ANDI        #dest_mode, D1          ;0000 0001 1100 0000
000011EA  143C 0006                321      MOVE.B      #right6, D2             ;D2 now 00000111
000011EE  E469                     322      LSR.W       D2, D1                  ;shifting destination mode in D1 to far right by 3
000011F0  B23C 0001                323      CMP.B       #1,D1                   ;does d1 = 001?
000011F4  6700 0310                324      BEQ         OP_MOVEAL               ;if d1 = 001, go to MOVEA
000011F8  4EF9 0000152E            325      JMP         OP_MOVEL                ;else jump to MOVEL
000011FE                           326      
000011FE                           327  
000011FE                           328  
000011FE                           329  
000011FE                           330  ;MOVEA.W MOVE.W                                                     $3
000011FE                           331  opcode0011:
000011FE  2200                     332      MOVE.L      D0,D1                   ;D1 has full instruction
00001200  0241 01C0                333      ANDI        #dest_mode, D1          ;0000 0001 1100 0000
00001204  143C 0006                334      MOVE.B      #right6, D2             ;D2 now 00000111
00001208  E469                     335      LSR.W       D2, D1                  ;shifting destination mode in D1 to far right by 3
0000120A  B23C 0001                336      CMP.B       #1,D1                   ;does d1 = 001?
0000120E  6700 0342                337      BEQ         OP_MOVEAW               ;if d1 = 001, go to MOVEAW
00001212  4EF9 0000157A            338      JMP         OP_MOVEW                ;else jump to MOVEW
00001218                           339  
00001218                           340  
00001218                           341  
00001218                           342  
00001218                           343  ;NOP, MOVEM, LEA (CLR, NOT, EXT, TRAP, STOP, RTE, RTS, JSR, JMP)     $4
00001218                           344  opcode0100:
00001218  2200                     345      MOVE.L      D0,D1                   ;D1 has full instruction
0000121A  0241 0F00                346      ANDI.W      #nibble2,D1             ;check bits 11,10,9,8
0000121E  143C 0008                347      MOVE.B      #right8, D2             ;store immediate value 8 in D2
00001222  E469                     348      LSR.W       D2, D1                  ;shift to isolate next nibble (bits 11-8)
00001224  C2FC 0006                349      MULU        #6, D1                  ;multiply by 6 to get displacement
00001228  47F9 0000135A            350      LEA         OP_0100_TABLE, A3       ;load op_0000_table into address register
0000122E  4EF3 1000                351      JMP         0(A3,D1)                ;jumps to opcode table entry (A0 = OP_TABLE)
00001232                           352  
00001232                           353  
00001232                           354  ;ADDQ (SUBQ)                                                        $5
00001232                           355  opcode0101:
00001232                           356      ;JMP         OP_ADDQ
00001232                           357      
00001232                           358      
00001232                           359      ;3/8/21
00001232  2200                     360      MOVE.L      D0,D1
00001234  0241 0F00                361      ANDI.W      #nibble2,D1
00001238  E049                     362      LSR.W       #right8,D1
0000123A  0241 0001                363      ANDI.W      #1,D1
0000123E  B23C 0000                364      CMP.B       #0,D1
00001242  6700 03A8                365      BEQ         OP_ADDQ
00001246  B23C 0001                366      CMP.B       #1,D1   
0000124A  6700 03C2                367      BEQ         OP_SUBQ
0000124E                           368      ;HANDLE ERROR
0000124E                           369  
0000124E                           370  
0000124E                           371  ;EA_ADDQ_SUBQ:
0000124E                           372  ;    ;CHECK BIT 8 FOR ADDQ OR SUBQ
0000124E                           373  ;    CMP.W       #nibble2,D1
0000124E                           374  ;    LSR.W       #right7,D1     
0000124E                           375  ;    ANDI.W      #1,D1
0000124E                           376  ;    CMP.B       #0,D1
0000124E                           377  ;    BEQ         EA_ADDQ
0000124E                           378  ;    CMP.B       #1,D1  
0000124E                           379  ;    BEQ         EA_SUBQ
0000124E                           380  ;    ;HANDLE ERROR      
0000124E                           381  
0000124E                           382  
0000124E                           383  ;BRA.bw, BSR.bw (BEQ)                                               $6
0000124E                           384  opcode0110:
0000124E  2200                     385      MOVE.L      D0,D1                   ;D1 has full instruction
00001250  0241 0F00                386      ANDI.W      #nibble2,D1             ;check bits 11,10,9,8
00001254  143C 0008                387      MOVE.B      #right8, D2             ;store immediate value 8 in D2
00001258  E469                     388      LSR.W       D2, D1                  ;shift to isolate next nibble (bits 11-8)
0000125A  C2FC 0006                389      MULU        #6, D1                  ;multiply by 6 to get displacement
0000125E  47F9 000013BA            390      LEA         OP_0110_TABLE, A3       ;load op_0110_table into address register
00001264  4EF3 1000                391      JMP         0(A3,D1)                ;jumps to opcode table entry (A0 = OP_TABLE)
00001268                           392      
00001268                           393      ;come back and check when debugging. if this does not work then skip jump table
00001268                           394  
00001268                           395  
00001268                           396  ;MOVEQ                                                            $7
00001268                           397  opcode0111:
00001268  4EF9 00001660            398      JMP         OP_MOVEQ
0000126E                           399  
0000126E                           400  
0000126E                           401  
0000126E                           402  ;DIVU (DIVS, OR)                                                    $8
0000126E                           403  opcode1000:
0000126E  2200                     404      MOVE.L      D0,D1
00001270  0241 0F00                405      ANDI.W      #nibble2,D1
00001274  E049                     406      LSR.W       #8,D1
00001276  0201 0001                407      ANDI.B      #1,D1
0000127A  B23C 0000                408      CMP.B       #0,D1
0000127E  6700 0400                409      BEQ         OP_DIVU
00001282  B23C 0001                410      CMP.B       #1,D1
00001286  6700 0414                411      BEQ         OP_DIVS
0000128A                           412      ;HANDLE ERROR
0000128A                           413  
0000128A                           414  ;SUB                                                                $9
0000128A                           415  opcode1001:
0000128A  4EF9 000016B8            416      JMP         OP_SUB
00001290                           417  
00001290                           418  
00001290                           419  ;not assigned                                                       $A
00001290                           420  opcode1010:
00001290  4EF9 000017A8            421      JMP         OP_UNSUPPORTED_OPCODE
00001296                           422  
00001296                           423  
00001296                           424  ;CMP (EOR)                                                          $B
00001296                           425  opcode1011:
00001296  4EF9 000016D6            426      JMP         OP_CMP
0000129C                           427  
0000129C                           428  
0000129C                           429  ;MULU (MULS, AND)                                                   $C
0000129C                           430  opcode1100:
0000129C  2200                     431      MOVE.L      D0,D1
0000129E  0241 0F00                432      ANDI.W      #nibble2,D1
000012A2  E049                     433      LSR.W       #8,D1
000012A4  0201 0001                434      ANDI.B      #1,D1
000012A8  B23C 0000                435      CMP.B       #0,D1
000012AC  6700 0446                436      BEQ         OP_MULU
000012B0  B23C 0001                437      CMP.B       #1,D1
000012B4  6700 045A                438      BEQ         OP_MULS
000012B8                           439      ;HANDLE ERROR
000012B8                           440  
000012B8                           441  ;ADD, ADDA                                                          $D
000012B8                           442  opcode1101:
000012B8                           443      ;ADD and ADDA differ on bits 6,7... ADD will never be 11 for bits 6,7... use as check
000012B8  4241                     444      CLR         D1
000012BA  4242                     445      CLR         D2
000012BC  2200                     446      MOVE.L      D0,D1
000012BE  0241 00F0                447      ANDI.W      #nibble3, D1
000012C2  143C 0006                448      MOVE.B      #right6, D2
000012C6  E469                     449      LSR.W       D2,D1
000012C8                           450      
000012C8                           451      ;at this point we have our bits of interest in bits 1,0
000012C8                           452      
000012C8  B27C 0003                453      CMP         #3,D1                              ;check if bits == 11
000012CC  6700 047C                454      BEQ         OP_ADDA                             ;if yes, branch ADDA
000012D0  6000 045A                455      BRA         OP_ADD                              ;else branch ADD
000012D4                           456  
000012D4                           457  
000012D4                           458  
000012D4                           459  ;ASL, ASR (LSL, LSR, ROL, ROR)                                      $E
000012D4                           460  opcode1110:
000012D4  4241                     461      CLR D1
000012D6  4242                     462      CLR D2
000012D8  2200                     463      MOVE.L      D0, D1
000012DA  0241 0F00                464      ANDI.W      #nibble2, D1
000012DE  143C 0008                465      MOVE.B      #right8, D2
000012E2  E469                     466      LSR.W       D2, D1                              ;D1 has 0003 or 0004
000012E4  0241 0001                467      ANDI.W      #0001,D1                           ;isolate single bit
000012E8                           468      
000012E8                           469      ;at this point we have our single bit of interest in bit 0
000012E8                           470      
000012E8  B27C 0000                471      CMP         #0,D1                           ;check if bit == 0
000012EC  6700 049C                472      BEQ         OP_ASR                          ;if yes, branch to ASR
000012F0  6000 047A                473      BRA         OP_ASL                          ;else, branch to ASL
000012F4                           474  
000012F4                           475  
000012F4                           476  ;not assigned                                                       $F
000012F4                           477  opcode1111:
000012F4  4EF9 000017A8            478      JMP         OP_UNSUPPORTED_OPCODE
000012FA                           479  
000012FA                           480  
000012FA                           481  ;******************************** OP_XXX_TABLES ************************************
000012FA                           482  ;once in OP_XXX_TABLE , we will use these entries to jump to specific op code to put into buffer
000012FA                           483  
000012FA                           484  OP_0000_TABLE:
000012FA  4EF9 0000141A            485      jmp OP_ORI                                      ;0  
00001300  4EF9 000017A8            486      jmp OP_UNSUPPORTED_OPCODE                       ;1
00001306  4EF9 00001438            487      jmp OP_ANDI                                     ;2
0000130C  4EF9 000017A8            488      jmp OP_UNSUPPORTED_OPCODE                       ;3
00001312  4EF9 0000145A            489      jmp OP_SUBI                                     ;4
00001318  4EF9 000017A8            490      jmp OP_UNSUPPORTED_OPCODE                       ;5
0000131E  4EF9 0000147C            491      jmp OP_ADDI                                     ;6
00001324  4EF9 000017A8            492      jmp OP_UNSUPPORTED_OPCODE                       ;7
0000132A  4EF9 000017A8            493      jmp OP_UNSUPPORTED_OPCODE                       ;8
00001330  4EF9 000017A8            494      jmp OP_UNSUPPORTED_OPCODE                       ;9
00001336  4EF9 0000149E            495      jmp OP_EORI                                     ;10
0000133C  4EF9 000017A8            496      jmp OP_UNSUPPORTED_OPCODE                       ;11
00001342  4EF9 000014C0            497      jmp OP_CMPI                                     ;12
00001348  4EF9 000017A8            498      jmp OP_UNSUPPORTED_OPCODE                       ;13
0000134E  4EF9 000017A8            499      jmp OP_UNSUPPORTED_OPCODE                       ;14
00001354  4EF9 000017A8            500      jmp OP_UNSUPPORTED_OPCODE                       ;15
0000135A                           501  
0000135A                           502  ;OP_0001_TABLE:
0000135A                           503  ;    jmp OP_MOVEB
0000135A                           504  
0000135A                           505  
0000135A                           506  ;OP_0010_TABLE:
0000135A                           507  ;   jmp OP_MOVEAL
0000135A                           508  ;   jmp OP_MOVEL
0000135A                           509  
0000135A                           510  
0000135A                           511  ;OP_0011_TABLE:
0000135A                           512  
0000135A                           513  
0000135A                           514  
0000135A                           515  ;NOP, MOVEM, LEA (CLR, NOT, EXT, TRAP, STOP, RTE, RTS, JSR, JMP     $4
0000135A                           516  ;NOP    1110
0000135A                           517  ;MOVEM  1D00
0000135A                           518  ;LEA    AN1
0000135A                           519  OP_0100_TABLE:
0000135A  4EF9 000017A8            520      jmp OP_UNSUPPORTED_OPCODE                           ;0  
00001360  4EF9 000015D4            521      jmp OP_LEA                                          ;1      (address 0001)
00001366  4EF9 000017A8            522      jmp OP_UNSUPPORTED_OPCODE                           ;2
0000136C  4EF9 000015D4            523      jmp OP_LEA                                          ;3      (address 0011)
00001372  4EF9 000017A8            524      jmp OP_UNSUPPORTED_OPCODE                           ;4 
00001378  4EF9 000015D4            525      jmp OP_LEA                                          ;5      (address 0101)
0000137E  4EF9 000017A8            526      jmp OP_UNSUPPORTED_OPCODE                           ;6 
00001384  4EF9 000015D4            527      jmp OP_LEA                                          ;7      (address 0111) 
0000138A  4EF9 000015AE            528      jmp OP_MOVEM                                        ;8                          ;jmp OP_MOVEM_R2M
00001390  4EF9 000015D4            529      jmp OP_LEA                                          ;9      (address 1001) 
00001396  4EF9 000017A8            530      jmp OP_UNSUPPORTED_OPCODE                           ;10 
0000139C  4EF9 000015D4            531      jmp OP_LEA                                          ;11     (address 1011) 
000013A2  4EF9 000015AE            532      jmp OP_MOVEM                                        ;12                         ;jmp OP_MOVEM_M2R    
000013A8  4EF9 000015D4            533      jmp OP_LEA                                          ;13     (address 1101)
000013AE  4EF9 0000159E            534      jmp OP_NOP                                          ;14
000013B4  4EF9 000015D4            535      jmp OP_LEA                                          ;15     (address 1111)
000013BA                           536  
000013BA                           537  
000013BA                           538  ;OP_0101_TABLE:
000013BA                           539  
000013BA                           540  
000013BA                           541  
000013BA                           542  ;BRA nibble 2 = 0000 (0) , BSR nibble 2 = 0001 (1)
000013BA                           543  OP_0110_TABLE:
000013BA  4EF9 00001630            544      jmp OP_BRA                                          ;0
000013C0  4EF9 00001648            545      jmp OP_BSR                                          ;1
000013C6  4EF9 000017A8            546      jmp OP_UNSUPPORTED_OPCODE                           ;2
000013CC  4EF9 000017A8            547      jmp OP_UNSUPPORTED_OPCODE                           ;3
000013D2  4EF9 000017A8            548      jmp OP_UNSUPPORTED_OPCODE                           ;4
000013D8  4EF9 000017A8            549      jmp OP_UNSUPPORTED_OPCODE                           ;5
000013DE  4EF9 000017A8            550      jmp OP_UNSUPPORTED_OPCODE                           ;6
000013E4  4EF9 000017A8            551      jmp OP_UNSUPPORTED_OPCODE                           ;7
000013EA  4EF9 000017A8            552      jmp OP_UNSUPPORTED_OPCODE                           ;8
000013F0  4EF9 000017A8            553      jmp OP_UNSUPPORTED_OPCODE                           ;9
000013F6  4EF9 000017A8            554      jmp OP_UNSUPPORTED_OPCODE                           ;10
000013FC  4EF9 000017A8            555      jmp OP_UNSUPPORTED_OPCODE                           ;11
00001402  4EF9 000017A8            556      jmp OP_UNSUPPORTED_OPCODE                           ;12
00001408  4EF9 000017A8            557      jmp OP_UNSUPPORTED_OPCODE                           ;13
0000140E  4EF9 000017A8            558      jmp OP_UNSUPPORTED_OPCODE                           ;14
00001414  4EF9 000017A8            559      jmp OP_UNSUPPORTED_OPCODE                           ;15
0000141A                           560  
0000141A                           561  
0000141A                           562  ;OP_0111_TABLE:
0000141A                           563  ;implement later if needed
0000141A                           564  
0000141A                           565  
0000141A                           566  ;OP_1000_TABLE:
0000141A                           567  ;implement later if needed
0000141A                           568  
0000141A                           569  
0000141A                           570  ;OP_1001_TABLE:
0000141A                           571  ;implement later if needed
0000141A                           572  
0000141A                           573  
0000141A                           574  ;OP_1010_TABLE:
0000141A                           575  ;implement later if needed
0000141A                           576  
0000141A                           577  
0000141A                           578  ;OP_1011_TABLE:
0000141A                           579  ;implement later if needed
0000141A                           580  
0000141A                           581  
0000141A                           582  ;OP_1100_TABLE:
0000141A                           583  ;implement later if needed
0000141A                           584  
0000141A                           585  
0000141A                           586  ;OP_1101_TABLE:
0000141A                           587  ;implement later if needed
0000141A                           588  
0000141A                           589  
0000141A                           590  ;OP_1110_TABLE:
0000141A                           591  ;implement later if needed
0000141A                           592  
0000141A                           593  
0000141A                           594  ;OP_1111_TABLE:
0000141A                           595  ;implement later if needed
0000141A                           596  
0000141A                           597  
0000141A                           598  
0000141A                           599  
0000141A                           600  ;******************************** OP_INSTRUCTION_XXXX******************************************
0000141A                           601  ;this is where we are putting ascii text into buffer
0000141A                           602  
0000141A                           603  
0000141A                           604  OP_ORI:
0000141A  14FC 004F                605      MOVE.B  #'O', (A2)+
0000141E  14FC 0052                606      MOVE.B  #'R', (A2)+
00001422  14FC 0049                607      MOVE.B  #'I', (A2)+
00001426                           608      
00001426                           609      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001426  4EB9 000017A8            610      JSR     OP_CHECK_SIZE
0000142C                           611      
0000142C  7200                     612      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
0000142E                           613  
0000142E  4EB9 00001946            614      JSR     EA_START
00001434  4EF8 1148                615      JMP     OP_FINISH
00001438                           616  
00001438                           617  OP_ANDI:  ;(optional)
00001438  14FC 0041                618      MOVE.B  #'A', (A2)+
0000143C  14FC 004E                619      MOVE.B  #'N', (A2)+
00001440  14FC 0044                620      MOVE.B  #'D', (A2)+
00001444  14FC 0049                621      MOVE.B  #'I', (A2)+
00001448                           622      
00001448                           623      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001448  4EB9 000017A8            624      JSR     OP_CHECK_SIZE
0000144E                           625      
0000144E  7200                     626      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
00001450                           627  
00001450  4EB9 00001946            628      JSR     EA_START
00001456  4EF8 1148                629      JMP     OP_FINISH
0000145A                           630  
0000145A                           631  
0000145A                           632  OP_SUBI:  ;(optional)
0000145A  14FC 0053                633      MOVE.B  #'S', (A2)+
0000145E  14FC 0055                634      MOVE.B  #'U', (A2)+
00001462  14FC 0042                635      MOVE.B  #'B', (A2)+
00001466  14FC 0049                636      MOVE.B  #'I', (A2)+
0000146A                           637      
0000146A                           638      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000146A  4EB9 000017A8            639      JSR     OP_CHECK_SIZE
00001470                           640      
00001470  7200                     641      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
00001472                           642  
00001472  4EB9 00001946            643      JSR     EA_START
00001478  4EF8 1148                644      JMP     OP_FINISH
0000147C                           645  
0000147C                           646  
0000147C                           647  OP_ADDI:  ;(optional)
0000147C  14FC 0041                648      MOVE.B  #'A', (A2)+
00001480  14FC 0044                649      MOVE.B  #'D', (A2)+
00001484  14FC 0044                650      MOVE.B  #'D', (A2)+
00001488  14FC 0049                651      MOVE.B  #'I', (A2)+
0000148C                           652      
0000148C                           653      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000148C  4EB9 000017A8            654      JSR     OP_CHECK_SIZE
00001492                           655     
00001492  7200                     656      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
00001494                           657  
00001494  4EB9 00001946            658      JSR     EA_START
0000149A  4EF8 1148                659      JMP     OP_FINISH
0000149E                           660  
0000149E                           661  
0000149E                           662  OP_EORI:  ;(optional)
0000149E  14FC 0045                663      MOVE.B  #'E', (A2)+
000014A2  14FC 004F                664      MOVE.B  #'O', (A2)+
000014A6  14FC 0052                665      MOVE.B  #'R', (A2)+
000014AA  14FC 0049                666      MOVE.B  #'I', (A2)+
000014AE                           667      
000014AE                           668      ;call OP_CHECK_SIZE to append a .b/.w/.l
000014AE  4EB9 000017A8            669      JSR     OP_CHECK_SIZE
000014B4                           670      
000014B4  7200                     671      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
000014B6                           672      
000014B6  4EB9 00001946            673      JSR     EA_START
000014BC  4EF8 1148                674      JMP     OP_FINISH
000014C0                           675  
000014C0                           676  
000014C0                           677  OP_CMPI:  ;(optional)
000014C0  14FC 0043                678      MOVE.B  #'C', (A2)+
000014C4  14FC 004D                679      MOVE.B  #'M', (A2)+
000014C8  14FC 0050                680      MOVE.B  #'P', (A2)+
000014CC  14FC 0049                681      MOVE.B  #'I', (A2)+
000014D0                           682      
000014D0                           683      
000014D0                           684      ;call OP_CHECK_SIZE to append a .b/.w/.l
000014D0  4EB9 000017A8            685      JSR     OP_CHECK_SIZE
000014D6                           686  
000014D6  7200                     687      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
000014D8                           688  
000014D8  4EB9 00001946            689      JSR     EA_START
000014DE  4EF8 1148                690      JMP     OP_FINISH
000014E2                           691  
000014E2                           692  
000014E2                           693  OP_MOVEB:
000014E2  14FC 004D                694      MOVE.B  #'M', (A2)+
000014E6  14FC 004F                695      MOVE.B  #'O', (A2)+
000014EA  14FC 0056                696      MOVE.B  #'V', (A2)+
000014EE  14FC 0045                697      MOVE.B  #'E', (A2)+
000014F2  14FC 002E                698      MOVE.B  #'.', (A2)+
000014F6  14FC 0042                699      MOVE.B  #'B', (A2)+
000014FA                           700      
000014FA  7201                     701      MOVE.L  #ea_type_move, D1                   ;preps for EA_START and puts 1 into D1
000014FC                           702      
000014FC  4EB9 00001946            703      JSR     EA_START
00001502  4EF8 1148                704      JMP     OP_FINISH
00001506                           705  
00001506                           706  OP_MOVEAL:
00001506  14FC 004D                707      MOVE.B  #'M', (A2)+
0000150A  14FC 004F                708      MOVE.B  #'O', (A2)+
0000150E  14FC 0056                709      MOVE.B  #'V', (A2)+
00001512  14FC 0045                710      MOVE.B  #'E', (A2)+
00001516  14FC 0041                711      MOVE.B  #'A', (A2)+
0000151A  14FC 002E                712      MOVE.B  #'.', (A2)+
0000151E  14FC 004C                713      MOVE.B  #'L', (A2)+
00001522                           714      
00001522  7202                     715      MOVE.L  #ea_type_movea, D1                   ;preps for EA_START and puts 2 into D1
00001524                           716      
00001524  4EB9 00001946            717      JSR     EA_START
0000152A  4EF8 1148                718      JMP     OP_FINISH
0000152E                           719  
0000152E                           720  OP_MOVEL:
0000152E  14FC 004D                721      MOVE.B  #'M', (A2)+
00001532  14FC 004F                722      MOVE.B  #'O', (A2)+
00001536  14FC 0056                723      MOVE.B  #'V', (A2)+
0000153A  14FC 0045                724      MOVE.B  #'E', (A2)+
0000153E  14FC 002E                725      MOVE.B  #'.', (A2)+
00001542  14FC 004C                726      MOVE.B  #'L', (A2)+
00001546                           727      
00001546  7201                     728      MOVE.L  #ea_type_move, D1                   ;preps for EA_START and puts 1 into D1
00001548                           729      
00001548  4EB9 00001946            730      JSR     EA_START
0000154E  4EF8 1148                731      JMP     OP_FINISH
00001552                           732  
00001552                           733  
00001552                           734  OP_MOVEAW:
00001552  14FC 004D                735      MOVE.B  #'M', (A2)+
00001556  14FC 004F                736      MOVE.B  #'O', (A2)+
0000155A  14FC 0056                737      MOVE.B  #'V', (A2)+
0000155E  14FC 0045                738      MOVE.B  #'E', (A2)+
00001562  14FC 0041                739      MOVE.B  #'A', (A2)+
00001566  14FC 002E                740      MOVE.B  #'.', (A2)+
0000156A  14FC 0057                741      MOVE.B  #'W', (A2)+
0000156E                           742      
0000156E  7202                     743      MOVE.L  #ea_type_movea, D1                   ;preps for EA_START and puts 2 into D1
00001570                           744      
00001570  4EB9 00001946            745      JSR     EA_START
00001576  4EF8 1148                746      JMP     OP_FINISH
0000157A                           747  
0000157A                           748  
0000157A                           749  OP_MOVEW:
0000157A  14FC 004D                750      MOVE.B  #'M', (A2)+
0000157E  14FC 004F                751      MOVE.B  #'O', (A2)+
00001582  14FC 0056                752      MOVE.B  #'V', (A2)+
00001586  14FC 0045                753      MOVE.B  #'E', (A2)+
0000158A  14FC 002E                754      MOVE.B  #'.', (A2)+
0000158E  14FC 0057                755      MOVE.B  #'W', (A2)+
00001592                           756      
00001592  7201                     757      MOVE.L  #ea_type_move, D1                   ;preps for EA_START and puts 1 into D1
00001594                           758      
00001594  4EB9 00001946            759      JSR     EA_START
0000159A  4EF8 1148                760      JMP     OP_FINISH
0000159E                           761  
0000159E                           762  
0000159E                           763  OP_NOP:
0000159E  14FC 004E                764      MOVE.B  #'N', (A2)+
000015A2  14FC 004F                765      MOVE.B  #'O', (A2)+
000015A6  14FC 0050                766      MOVE.B  #'P', (A2)+
000015AA                           767      
000015AA                           768      ;NO EA
000015AA  4EF8 1148                769      JMP     OP_FINISH
000015AE                           770  
000015AE                           771  
000015AE                           772  OP_MOVEM:
000015AE                           773      ;see movemd2r or movemr2d... see below at bottom ?????
000015AE                           774      
000015AE  14FC 004D                775      MOVE.B  #'M', (A2)+
000015B2  14FC 004F                776      MOVE.B  #'O', (A2)+
000015B6  14FC 0056                777      MOVE.B  #'V', (A2)+
000015BA  14FC 0045                778      MOVE.B  #'E', (A2)+
000015BE  14FC 004D                779      MOVE.B  #'M', (A2)+
000015C2                           780      
000015C2                           781      ;call OP_CHECK_SIZE to append a .b/.w/.l
000015C2  4EB9 000017CC            782      JSR     OP_CHECK_SIZE_MOVEM
000015C8                           783      
000015C8  7206                     784      MOVE.L  #ea_type_movem, D1                   ;preps for EA_START and puts 6 into D1
000015CA                           785      
000015CA  4EB9 00001946            786      JSR     EA_START
000015D0  4EF8 1148                787      JMP     OP_FINISH
000015D4                           788  
000015D4                           789  OP_LEA:
000015D4  14FC 004C                790      MOVE.B  #'L', (A2)+
000015D8  14FC 0045                791      MOVE.B  #'E', (A2)+
000015DC  14FC 0041                792      MOVE.B  #'A', (A2)+
000015E0                           793      
000015E0  7203                     794      MOVE.L  #ea_type_lea, D1                   ;preps for EA_START and puts 3 into D1
000015E2                           795      
000015E2  4EB9 00001946            796      JSR     EA_START
000015E8  4EF8 1148                797      JMP     OP_FINISH
000015EC                           798  
000015EC                           799  OP_CLR:  ;(optional)
000015EC                           800  ;implement later if needed
000015EC                           801  
000015EC                           802  
000015EC                           803  OP_NOT:  ;(optional)
000015EC                           804  ;implement later if needed
000015EC                           805  
000015EC                           806  
000015EC                           807  OP_EXT:  ;(optional)
000015EC                           808  ;implement later if needed
000015EC                           809  
000015EC                           810  
000015EC                           811  OP_TRAP:  ;(optional)
000015EC                           812  ;implement later if needed
000015EC                           813  
000015EC                           814   
000015EC                           815  OP_STOP:  ;(optional)
000015EC                           816  ;implement later if needed
000015EC                           817  
000015EC                           818  
000015EC                           819  OP_RTE:  ;(optional)
000015EC                           820  ;implement later if needed
000015EC                           821  
000015EC                           822  
000015EC                           823  OP_RTS:  ;(optional)
000015EC                           824  ;implement later if needed
000015EC                           825  
000015EC                           826  
000015EC                           827  OP_JSR:  ;(optional)
000015EC                           828  ;implement later if needed
000015EC                           829  
000015EC                           830  
000015EC                           831  OP_JMP:  ;(optional)
000015EC                           832  ;implement later if needed
000015EC                           833  
000015EC                           834  
000015EC                           835  OP_ADDQ:
000015EC  14FC 0041                836      MOVE.B  #'A', (A2)+
000015F0  14FC 0044                837      MOVE.B  #'D', (A2)+
000015F4  14FC 0044                838      MOVE.B  #'D', (A2)+
000015F8  14FC 0051                839      MOVE.B  #'Q', (A2)+
000015FC                           840      
000015FC                           841      ;call OP_CHECK_SIZE to append a .b/.w/.l
000015FC  4EB9 000017A8            842      JSR     OP_CHECK_SIZE
00001602                           843  
00001602  7208                     844      MOVE.L  #ea_type_quick, D1                   ;preps for EA_START and puts 8 into D1
00001604                           845  
00001604  4EB9 00001946            846      JSR     EA_START
0000160A  4EF8 1148                847      JMP     OP_FINISH
0000160E                           848  
0000160E                           849  OP_SUBQ:  ;(optional)
0000160E  14FC 0053                850      MOVE.B  #'S', (A2)+
00001612  14FC 0055                851      MOVE.B  #'U', (A2)+
00001616  14FC 0042                852      MOVE.B  #'B', (A2)+
0000161A  14FC 0051                853      MOVE.B  #'Q', (A2)+
0000161E                           854      
0000161E                           855      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000161E  4EB9 000017A8            856      JSR     OP_CHECK_SIZE
00001624                           857      
00001624  7208                     858      MOVE.L  #ea_type_quick, D1                   ;preps for EA_START and puts 8 into D1
00001626                           859  
00001626  4EB9 00001946            860      JSR     EA_START
0000162C  4EF8 1148                861      JMP     OP_FINISH
00001630                           862  
00001630                           863  OP_BRA:                                     ;???? DO WE DEFINE SIZE HERE OR AFTER????
00001630  14FC 0042                864      MOVE.B  #'B', (A2)+
00001634  14FC 0052                865      MOVE.B  #'R', (A2)+
00001638  14FC 0041                866      MOVE.B  #'A', (A2)+
0000163C                           867  
0000163C  7209                     868      MOVE.L  #ea_type_branch,D1
0000163E                           869      
0000163E  4EB9 00001946            870      JSR     EA_START
00001644  4EF8 1148                871      JMP     OP_FINISH
00001648                           872  
00001648                           873  
00001648                           874  OP_BSR:
00001648  14FC 0042                875      MOVE.B  #'B', (A2)+
0000164C  14FC 0053                876      MOVE.B  #'S', (A2)+
00001650  14FC 0052                877      MOVE.B  #'R', (A2)+
00001654                           878      
00001654  7209                     879      MOVE.L  #ea_type_branch,D1
00001656                           880      
00001656  4EB9 00001946            881      JSR     EA_START                        ;DO WE HAVE EA?
0000165C  4EF8 1148                882      JMP     OP_FINISH
00001660                           883  
00001660                           884  
00001660                           885  OP_BEQ:
00001660                           886  ;implement later if needed
00001660                           887  
00001660                           888  
00001660                           889  OP_MOVEQ:
00001660  14FC 004D                890      MOVE.B  #'M', (A2)+
00001664  14FC 004F                891      MOVE.B  #'O', (A2)+
00001668  14FC 0056                892      MOVE.B  #'V', (A2)+
0000166C  14FC 0045                893      MOVE.B  #'E', (A2)+
00001670  14FC 0051                894      MOVE.B  #'Q', (A2)+
00001674                           895      
00001674                           896      ;DO WE NEED A .L ?
00001674                           897      
00001674  7208                     898      MOVE.L  #ea_type_quick, D1                   ;preps for EA_START and puts 8 into D1
00001676                           899      
00001676  4EB9 00001946            900      JSR     EA_START
0000167C  4EF8 1148                901      JMP     OP_FINISH
00001680                           902  
00001680                           903  
00001680                           904  OP_DIVU:
00001680  14FC 0044                905      MOVE.B  #'D', (A2)+
00001684  14FC 0049                906      MOVE.B  #'I', (A2)+
00001688  14FC 0056                907      MOVE.B  #'V', (A2)+
0000168C  14FC 0055                908      MOVE.B  #'U', (A2)+
00001690                           909    
00001690  720A                     910      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
00001692                           911    
00001692  4EB9 00001946            912      JSR     EA_START
00001698  4EF8 1148                913      JMP     OP_FINISH    
0000169C                           914  
0000169C                           915  
0000169C                           916  OP_DIVS  ;(optional)
0000169C  14FC 0044                917      MOVE.B  #'D', (A2)+
000016A0  14FC 0049                918      MOVE.B  #'I', (A2)+
000016A4  14FC 0056                919      MOVE.B  #'V', (A2)+
000016A8  14FC 0053                920      MOVE.B  #'S', (A2)+
000016AC                           921    
000016AC  720A                     922      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
000016AE                           923    
000016AE  4EB9 00001946            924      JSR     EA_START
000016B4  4EF8 1148                925      JMP     OP_FINISH   
000016B8                           926  
000016B8                           927  
000016B8                           928  OP_OR  ;(optional)
000016B8                           929  ;implement later if needed
000016B8                           930  
000016B8                           931  
000016B8                           932  OP_SUB:
000016B8  14FC 0053                933      MOVE.B  #'S', (A2)+
000016BC  14FC 0055                934      MOVE.B  #'U', (A2)+
000016C0  14FC 0042                935      MOVE.B  #'B', (A2)+
000016C4                           936  
000016C4  4EB9 000017A8            937      JSR     OP_CHECK_SIZE                       ;call OP_CHECK_SIZE to append a .b/.w/.l
000016CA                           938      
000016CA  720A                     939      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
000016CC                           940      
000016CC                           941      ;at this point it will return with SUB.X and go to EA_START
000016CC  4EB9 00001946            942      JSR     EA_START
000016D2  4EF8 1148                943      JMP     OP_FINISH    
000016D6                           944  
000016D6                           945  
000016D6                           946  OP_CMP:
000016D6  14FC 0043                947      MOVE.B  #'C', (A2)+
000016DA  14FC 004D                948      MOVE.B  #'M', (A2)+
000016DE  14FC 0050                949      MOVE.B  #'P', (A2)+
000016E2                           950    
000016E2  4EB9 000017A8            951      JSR     OP_CHECK_SIZE                       ;call OP_CHECK_SIZE to append a .b/.w/.l  
000016E8                           952      
000016E8  720A                     953      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
000016EA                           954      
000016EA                           955      ;at this point it will return with SUB.X and go to EA_START
000016EA  4EB9 00001946            956      JSR     EA_START
000016F0  4EF8 1148                957      JMP     OP_FINISH    
000016F4                           958      
000016F4                           959  
000016F4                           960  
000016F4                           961  OP_EOR:  ;(optional)
000016F4                           962  ;implement later if needed
000016F4                           963  
000016F4                           964  
000016F4                           965  OP_MULU:
000016F4  14FC 004D                966      MOVE.B  #'M', (A2)+
000016F8  14FC 0055                967      MOVE.B  #'U', (A2)+
000016FC  14FC 004C                968      MOVE.B  #'L', (A2)+
00001700  14FC 0055                969      MOVE.B  #'U', (A2)+
00001704                           970  
00001704  720A                     971      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
00001706                           972      
00001706  4EB9 00001946            973      JSR     EA_START
0000170C  4EF8 1148                974      JMP     OP_FINISH    
00001710                           975  
00001710                           976  OP_MULS:  ;(optional)
00001710  14FC 004D                977      MOVE.B  #'M', (A2)+
00001714  14FC 0055                978      MOVE.B  #'U', (A2)+
00001718  14FC 004C                979      MOVE.B  #'L', (A2)+
0000171C  14FC 0053                980      MOVE.B  #'S', (A2)+
00001720                           981  
00001720  720A                     982      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
00001722                           983  
00001722  4EB9 00001946            984      JSR     EA_START
00001728  4EF8 1148                985      JMP     OP_FINISH
0000172C                           986  
0000172C                           987  
0000172C                           988  OP_AND:  ;(optional)
0000172C                           989  ;implement later if needed
0000172C                           990  
0000172C                           991  
0000172C                           992  OP_ADD:
0000172C  14FC 0041                993      MOVE.B  #'A', (A2)+
00001730  14FC 0044                994      MOVE.B  #'D', (A2)+
00001734  14FC 0044                995      MOVE.B  #'D', (A2)+
00001738                           996  
00001738                           997      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001738  4EB9 000017A8            998      JSR     OP_CHECK_SIZE
0000173E                           999      
0000173E  720A                    1000      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
00001740                          1001  
00001740  4EB9 00001946           1002      JSR     EA_START
00001746  4EF8 1148               1003      JMP     OP_FINISH
0000174A                          1004  
0000174A                          1005  OP_ADDA:
0000174A  14FC 0041               1006      MOVE.B  #'A', (A2)+
0000174E  14FC 0044               1007      MOVE.B  #'D', (A2)+
00001752  14FC 0044               1008      MOVE.B  #'D', (A2)+
00001756  14FC 0041               1009      MOVE.B  #'A', (A2)+
0000175A                          1010  
0000175A                          1011      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000175A  4EB9 0000180E           1012      JSR     OP_CHECK_SIZE_ADDA
00001760                          1013      
00001760  720A                    1014      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
00001762                          1015  
00001762  4EB9 00001946           1016      JSR     EA_START
00001768  4EF8 1148               1017      JMP     OP_FINISH
0000176C                          1018  
0000176C                          1019  
0000176C                          1020  OP_ASL:
0000176C  14FC 0041               1021      MOVE.B  #'A', (A2)+
00001770  14FC 0053               1022      MOVE.B  #'S', (A2)+
00001774  14FC 004C               1023      MOVE.B  #'L', (A2)+
00001778                          1024  
00001778                          1025      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001778  4EB9 000017A8           1026      JSR     OP_CHECK_SIZE
0000177E                          1027      
0000177E  720B                    1028      MOVE.L  #ea_type_rotation, D1                   ;preps for EA_START and puts 10 into D1
00001780                          1029      
00001780  4EB9 00001946           1030      JSR     EA_START
00001786  4EF8 1148               1031      JMP     OP_FINISH
0000178A                          1032  
0000178A                          1033  
0000178A                          1034  OP_ASR:
0000178A  14FC 0041               1035      MOVE.B  #'A', (A2)+
0000178E  14FC 0053               1036      MOVE.B  #'S', (A2)+
00001792  14FC 0052               1037      MOVE.B  #'R', (A2)+
00001796                          1038  
00001796                          1039      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001796  4EB9 000017A8           1040      JSR     OP_CHECK_SIZE
0000179C                          1041      
0000179C  720B                    1042      MOVE.L  #ea_type_rotation, D1                   ;preps for EA_START and puts 10 into D1
0000179E                          1043  
0000179E  4EB9 00001946           1044      JSR     EA_START
000017A4  4EF8 1148               1045      JMP     OP_FINISH
000017A8                          1046  
000017A8                          1047  OP_LSL:  ;(optional)
000017A8                          1048  ;implement later if needed
000017A8                          1049  
000017A8                          1050  
000017A8                          1051  
000017A8                          1052  OP_LSR:  ;(optional)
000017A8                          1053  ;implement later if needed
000017A8                          1054  
000017A8                          1055  
000017A8                          1056  
000017A8                          1057  OP_ROL:  ;(optional)
000017A8                          1058  ;implement later if needed
000017A8                          1059  
000017A8                          1060  
000017A8                          1061  
000017A8                          1062  OP_ROR:  ;(optional)
000017A8                          1063  ;implement later if needed
000017A8                          1064  
000017A8                          1065  
000017A8                          1066  
000017A8                          1067  ;OP_MOVEM_R2M:
000017A8                          1068  ;    MOVE.B  #'M', (A2)+
000017A8                          1069  ;    MOVE.B  #'O', (A2)+
000017A8                          1070  ;    MOVE.B  #'V', (A2)+
000017A8                          1071  ;    MOVE.B  #'E', (A2)+
000017A8                          1072  ;    MOVE.B  #'M', (A2)+
000017A8                          1073      
000017A8                          1074  ;    ;call OP_CHECK_SIZE to append a .b/.w/.l
000017A8                          1075  ;    JSR     OP_CHECK_SIZE
000017A8                          1076      
000017A8                          1077  ;    MOVE.L  #ea_type_movem, D1                   ;preps for EA_START and puts 6 into D1
000017A8                          1078      
000017A8                          1079  ;    JSR     EA_START
000017A8                          1080  ;    JMP     OP_FINISH
000017A8                          1081  
000017A8                          1082  
000017A8                          1083  ;OP_MOVEM_M2R:
000017A8                          1084  ;    MOVE.B  #'M', (A2)+
000017A8                          1085  ;    MOVE.B  #'O', (A2)+
000017A8                          1086  ;    MOVE.B  #'V', (A2)+
000017A8                          1087  ;    MOVE.B  #'E', (A2)+
000017A8                          1088  ;    MOVE.B  #'M', (A2)+
000017A8                          1089      
000017A8                          1090  ;    ;call OP_CHECK_SIZE to append a .b/.w/.l
000017A8                          1091  ;    JSR     OP_CHECK_SIZE
000017A8                          1092      
000017A8                          1093  ;    MOVE.L  #ea_type_movem, D1                   ;preps for EA_START and puts 6 into D1
000017A8                          1094      
000017A8                          1095  ;    JSR     EA_START
000017A8                          1096  ;    JMP     OP_FINISH
000017A8                          1097  
000017A8                          1098  
000017A8                          1099  OP_UNSUPPORTED_OPCODE:
000017A8                          1100  ;fill out
000017A8                          1101  
000017A8                          1102  ;D0 HAS COMPLETE INSTRUCTION
000017A8                          1103  OP_CHECK_SIZE:
000017A8  4241                    1104      CLR     D1                                  ;CLEAR D1
000017AA  4242                    1105      CLR     D2                                  ;clear D2
000017AC  2200                    1106      MOVE.L  D0,D1                               ;D0 and D1 both have complete opcode
000017AE  0241 00F0               1107      ANDI.W  #nibble3,D1                         ;isolate nibble 3
000017B2  143C 0006               1108      MOVE.B  #right6, D2                         ;putting immediate value 6 in D2
000017B6  E469                    1109      LSR.W   D2, D1                              ;bits 7,6 --> bits 1,0
000017B8                          1110      
000017B8                          1111       
000017B8  B27C 0000               1112      CMP     #00,D1                              ;compare bits 1,0 to 00
000017BC  6700 0032               1113      BEQ     OP_SIZE_BYTE                        ;if bits == 00, size byte
000017C0  B27C 0001               1114      CMP     #01,D1                              ;compare bits to 01
000017C4  6700 0034               1115      BEQ     OP_SIZE_WORD                        ;if bits == 01, size word
000017C8  6000 003A               1116      BRA     OP_SIZE_LONG                        ;else size long
000017CC                          1117  
000017CC                          1118  
000017CC                          1119  OP_CHECK_SIZE_MOVEM:
000017CC  4241                    1120      CLR     D1                                  ;CLEAR D1
000017CE  4242                    1121      CLR     D2                                  ;clear D2
000017D0  2200                    1122      MOVE.L  D0,D1                               ;D0 and D1 both have complete opcode
000017D2  0241 00F0               1123      ANDI.W  #nibble3,D1                         ;isolate nibble 3
000017D6  143C 0006               1124      MOVE.B  #right6, D2                         ;putting immediate value 6 in D2
000017DA  E469                    1125      LSR.W   D2, D1                              ;bits 7,6 --> bits 1,0
000017DC                          1126      
000017DC  0241 0001               1127      ANDI.W  #1,D1    
000017E0  B27C 0000               1128      CMP     #0,D1                              ;compare bits 1,0 to 00
000017E4  6700 0014               1129      BEQ     OP_SIZE_WORD                        ;if bits == 00, size WORD
000017E8  B27C 0001               1130      CMP     #1,D1                              ;compare bits to 01
000017EC  6700 0016               1131      BEQ     OP_SIZE_LONG                       ;if bits == 01, size LONG
000017F0                          1132  
000017F0                          1133  OP_SIZE_BYTE
000017F0  14FC 002E               1134      MOVE.B  #'.', (A2)+
000017F4  14FC 0042               1135      MOVE.B  #'B', (A2)+
000017F8  4E75                    1136      RTS
000017FA                          1137  
000017FA                          1138  OP_SIZE_WORD
000017FA  14FC 002E               1139      MOVE.B  #'.', (A2)+
000017FE  14FC 0057               1140      MOVE.B  #'W', (A2)+
00001802  4E75                    1141      RTS
00001804                          1142  
00001804                          1143  
00001804                          1144  OP_SIZE_LONG
00001804  14FC 002E               1145      MOVE.B  #'.', (A2)+
00001808  14FC 004C               1146      MOVE.B  #'L', (A2)+
0000180C  4E75                    1147      RTS
0000180E                          1148  
0000180E                          1149  
0000180E                          1150  OP_CHECK_SIZE_ADDA:
0000180E  4241                    1151      CLR     D1                                  ;CLEAR D1
00001810  4242                    1152      CLR     D2                                  ;clear D2
00001812  2200                    1153      MOVE.L  D0,D1                               ;D0 and D1 both have complete opcode
00001814  0241 0F00               1154      ANDI.W  #nibble2,D1                         ;isolate nibble 2
00001818  143C 0008               1155      MOVE.B  #right8, D2                         ;putting immediate value 8 in D2
0000181C  E469                    1156      LSR.W   D2, D1                              ;
0000181E                          1157      
0000181E                          1158      ;at this point we have our single bit in bit 0
0000181E                          1159      
0000181E  0241 0001               1160      ANDI.W  #0001,D1                            ;isolate bit 0
00001822  B27C 0000               1161      CMP     #0,D1                               ;check if bit == 0
00001826  67D2                    1162      BEQ     OP_SIZE_WORD                        ;if yes, size = word
00001828  60DA                    1163      BRA     OP_SIZE_LONG                        ;else, size = long
0000182A                          1164   
0000182A                          1165  
0000182A                          1166  ;******************************** ATOI ******************************************************************************************************************************
0000182A                          1167  ATOI:
0000182A  2401                    1168          MOVE.L      D1,D2                   ;loop variable (size) is in D2
0000182C  2449                    1169          MOVEA.L     A1,A2                   ;pointer to next char
0000182E  4284                    1170          CLR.L       D4
00001830                          1171  
00001830                          1172  ATOI_LOOP  
00001830  4243                    1173          CLR         D3                      ;clear d3
00001832                          1174          ;CMP.B       #0,D2
00001832                          1175          ;BEQ         ATOI_DONE               ;DONE
00001832  5382                    1176          SUBI.L      #1,D2                   ;subtract 1 from loop counter
00001834  161A                    1177          MOVE.B      (A2)+,D3                 ;move current byte to D3, then increment to next
00001836  B63C 002F               1178          CMP.B       #$2F,D3
0000183A  6F00 0060               1179          BLE         ATOI_ERROR              ;if less than 30, not a number, branch to error
0000183E  B63C 0039               1180          CMP.B       #$39,D3                 ;check byte to see if number or letter
00001842  6F00 002A               1181          BLE         ATOI_NUMBER             ;30<x<39 --> number
00001846  B63C 0040               1182          CMP.B       #$40,D3
0000184A  6F00 0050               1183          BLE         ATOI_ERROR
0000184E  B63C 0046               1184          CMP.B       #$46,D3
00001852  6F00 0024               1185          BLE         ATOI_UPPERCASE_LETTER   ;less than 47, it is uppercase letter
00001856  B63C 0060               1186          CMP.B       #$60,D3
0000185A  6F00 0040               1187          BLE         ATOI_ERROR
0000185E  B63C 0066               1188          CMP.B       #$66,D3
00001862  6F00 001E               1189          BLE         ATOI_LOWERCASE_LETTER
00001866  B63C 0067               1190          CMP.B       #$67,D3
0000186A  6C00 0030               1191          BGE         ATOI_ERROR
0000186E                          1192          
0000186E                          1193          ;BNE         ATOI_LOOP                    ;run loop
0000186E                          1194      
0000186E                          1195  
0000186E                          1196  ATOI_NUMBER
0000186E                          1197  ;number --> d1 = d1 - $30
0000186E  0403 0030               1198      SUBI.B          #$30, D3                    ;subtract 30 if number
00001872                          1199      ;MOVE.B          D3,(A2)+                    ;move into A2 and post increment pointer
00001872  4EF9 0000188C           1200      JMP             ATOI_FORMAT                 ;testing
00001878                          1201      ;JMP            ATOI_LOOP                   ;loop
00001878                          1202  
00001878                          1203  ATOI_UPPERCASE_LETTER
00001878                          1204  ;letter --> d1 = d1 - $37
00001878  0403 0037               1205      SUBI.B          #$37,D3                     ;subtract 37 if UPPER case letter
0000187C                          1206      ;MOVE.B          D3,(A2)+                    ;move into A2 and post increment pointer
0000187C  4EF9 0000188C           1207      JMP             ATOI_FORMAT                 ;testing
00001882                          1208      ;JMP            ATOI_LOOP                   ;loop
00001882                          1209  
00001882                          1210  ATOI_LOWERCASE_LETTER
00001882  0403 0057               1211      SUBI.B          #$57,D3                     ;subtract 57(20 + 37)
00001886                          1212      ;MOVE.B          D3,(A2)+                    ;move into A2 and post increment pointer
00001886  4EF9 0000188C           1213      JMP             ATOI_FORMAT                 ;testing
0000188C                          1214      ;JMP            ATOI_LOOP                  ;loop
0000188C                          1215  
0000188C                          1216  
0000188C                          1217  ATOI_FORMAT
0000188C  D803                    1218      ADD.B           D3,D4                       ;add the byte to D4 so can add later   
0000188E  B43C 0000               1219      CMP.B           #0,D2                       
00001892  6700 0008               1220      BEQ             ATOI_DONE                   ;check if done (loop counter D2 is at 0)
00001896  E984                    1221      ASL.L           #4,D4                       ;logical shift left to make room
00001898  4EF8 1830               1222      JMP             ATOI_LOOP                   ;go back to loop
0000189C                          1223  
0000189C                          1224  ATOI_ERROR
0000189C                          1225      ;come back to handle error when out of range
0000189C                          1226      
0000189C                          1227  
0000189C                          1228  ATOI_DONE 
0000189C  2284                    1229      MOVE.L         D4,(A1)                      ;at this point, move the new address in D4 to mem location                                
0000189E  4E75                    1230      RTS                                         ;used to RTS after a branch statement
000018A0                          1231  
000018A0                          1232  ;************************************* ITOA *******************************************************************************************************************
000018A0                          1233  ;A0
000018A0                          1234  ;A1
000018A0                          1235  ;A2 = buffer (this is our decoded string that will print to screen)
000018A0                          1236  ;A3
000018A0                          1237  ;A4 = current memory address for buffer
000018A0                          1238  ;A5 = starting address / current address in memory
000018A0                          1239  ;A6 = ending address
000018A0                          1240  ;A7 = SP
000018A0                          1241  
000018A0                          1242  ;D0 = counter
000018A0                          1243  ;D1 = 
000018A0                          1244  ;D2 = ?
000018A0                          1245  ;D3 = buffer size (used for loop = 64)
000018A0                          1246  ;D4 = value being converted
000018A0                          1247  ;D5 =
000018A0                          1248  ;D6 = 
000018A0                          1249  ;D7 = 
000018A0                          1250  ITOA:
000018A0  280D                    1251      MOVE.L         A5,D4                    ;D4 has data to convert to ascii
000018A2                          1252  
000018A2                          1253  ITOA_LOOP:
000018A2  BA3C 0000               1254      CMP.B           #0,D5
000018A6  6700 004C               1255      BEQ             ITOA_FINISH             ;when 0, branch to finish to complete
000018AA                          1256  
000018AA                          1257  
000018AA                          1258  
000018AA                          1259  
000018AA                          1260  ITOA_BYTE:
000018AA                          1261  
000018AA                          1262  
000018AA                          1263  
000018AA                          1264  ITOA_WORD:
000018AA                          1265  
000018AA                          1266  
000018AA                          1267  
000018AA                          1268  ITOA_LONG:
000018AA                          1269  
000018AA                          1270  
000018AA                          1271  
000018AA                          1272  ITOA_ADDRESS:
000018AA  4284                    1273      CLR.L       D4                          ;D4 = 0000 0000
000018AC  280D                    1274      MOVE.L      A5,D4                       ;our address is now in D4 and ready to deconstruct
000018AE  103C 0008               1275      MOVE.B      #8,D0                       ;counter
000018B2  4EF9 000018B8           1276      JMP         ITOA_ADDRESS_LOOP
000018B8                          1277  ITOA_ADDRESS_LOOP:
000018B8  B03C 0000               1278      CMP.B       #0,D0                       ;check if done
000018BC  6700 0036               1279      BEQ         ITOA_FINISH                 ;if at 0, branch to ITOA_FINISH
000018C0  E99C                    1280      ROL.L       #4,D4                       ;rotate left 4 bits, to get MSB to beginning 
000018C2  1204                    1281      MOVE.B      D4,D1                       ;store in D1 (this will be whole byte, we want half)
000018C4  0241 000F               1282      ANDI.W      #$000F,D1                   ;character is now isolated
000018C8                          1283      
000018C8  4EB9 000018D4           1284      JSR         ITOA_HEX2ASCII              ;JSR to convert
000018CE  5340                    1285      SUBI        #1,D0                       ;subtract 1 from counter
000018D0  4EF8 18B8               1286      JMP         ITOA_ADDRESS_LOOP           ;loop again!
000018D4                          1287  
000018D4                          1288  ITOA_HEX2ASCII:
000018D4  B23C 000A               1289      CMP.B       #$A,D1                      ;compare byte in D1 to hex value A
000018D8  6C00 0012               1290      BGE         ITOA_LETTER                 ;if greater than/equal A, it is letter
000018DC  B23C 000A               1291      CMP.B       #$A,D1                      ;compare byte in D1 to hex value A
000018E0  6D00 0002               1292      BLT         ITOA_NUMBER                 ;if less than, it is number
000018E4                          1293  
000018E4                          1294  ITOA_NUMBER:
000018E4  0601 0030               1295      ADDI.B      #$30,D1                     ;add $30 to D1 to convert
000018E8  14C1                    1296      MOVE.B      D1,(A2)+                    ;add to buffer and increment to next position
000018EA  4E75                    1297      RTS
000018EC                          1298  
000018EC                          1299  ITOA_LETTER:
000018EC  0601 0037               1300      ADDI.B      #$37,D1                     ;add 37 to D1 to convert
000018F0  14C1                    1301      MOVE.B      D1,(A2)+                    ;add to buffer and increment to next position
000018F2  4E75                    1302      RTS
000018F4                          1303  
000018F4                          1304  ITOA_FINISH:
000018F4  4E75                    1305      RTS
000018F6                          1306  
000018F6                          1307  
000018F6                          1308  ;************************************ Validate Addresses ******************************************
000018F6                          1309  
000018F6                          1310  VALIDATE_BEGINNING:
000018F6                          1311      
000018F6                          1312  
000018F6                          1313  
000018F6                          1314  
000018F6                          1315  ;******************************** Message Error Handling ***************************************************************************************************************** 
000018F6                          1316  STARTA_ERROR_LESS_THAN_ZERO:
000018F6  103C 000E               1317      MOVE.B  #14,D0
000018FA  43F9 00002282           1318      LEA     error_message_1,A1      ;load the get_end_address message into A1
00001900  4E4F                    1319      TRAP    #15    
00001902  4EF8 1012               1320      JMP     GET_STARTING_ADDRESS
00001906                          1321  
00001906                          1322  STARTA_ERROR_NOT_EVEN:
00001906  103C 000E               1323      MOVE.B  #14,D0
0000190A  43F9 000022AC           1324      LEA     error_message_2,A1      ;load error_message_2
00001910  4E4F                    1325      TRAP    #15    
00001912  4EF8 1012               1326      JMP     GET_STARTING_ADDRESS
00001916                          1327  
00001916                          1328  ENDA_ERROR_NOT_EVEN:
00001916  103C 000E               1329      MOVE.B  #14,D0
0000191A  43F9 000022CC           1330      LEA     error_message_3,A1      ;load error_message_3
00001920  4E4F                    1331      TRAP    #15
00001922  4EF8 104A               1332      JMP     GET_ENDING_ADDRESS
00001926                          1333  
00001926                          1334  ENDA_ERROR_LARGE:
00001926  103C 000E               1335      MOVE.B  #14,D0
0000192A  43F9 000022EC           1336      LEA     error_message_4,A1      ;load error_message_4
00001930  4E4F                    1337      TRAP    #15
00001932  4EF8 104A               1338      JMP     GET_ENDING_ADDRESS
00001936                          1339      
00001936                          1340  ENDA_ERROR_LESS_THAN_STARTA:
00001936  103C 000E               1341      MOVE.B  #14,D0
0000193A  43F9 0000231B           1342      LEA     error_message_5,A1      ;load error_message_5
00001940  4E4F                    1343      TRAP    #15
00001942  4EF8 104A               1344      JMP     GET_ENDING_ADDRESS
00001946                          1345  
00001946                          1346  ;****************************************** EA Stuff ********************************************************************************************************************* 
00001946                          1347  
00001946                          1348  EA_START:
00001946  41F9 00001954           1349      LEA         EA_TYPE_TABLE, A0
0000194C                          1350      
0000194C  C2FC 0006               1351      MULU        #6,D1               ;computes opcode table jump displacement
00001950  4EF0 1000               1352      JMP         0(A0,D1)            ;jump to correct table input
00001954                          1353  
00001954                          1354  
00001954                          1355  EA_TYPE_TABLE:
00001954  4EF9 000019A4           1356      JMP         EA_IMMEDIATE        ;0  DONE
0000195A  4EF9 000019E6           1357      JMP         EA_MOVE             ;1  DONE
00001960  4EF9 00001A2C           1358      JMP         EA_MOVEA            ;2  DONE
00001966  4EF9 00001A72           1359      JMP         EA_LEA              ;3  DONE
0000196C  4EF9 00001AB2           1360      JMP         EA_DESTONLY         ;4  JMP, CLR
00001972  4EF9 00001AB2           1361      JMP         EA_EXT              ;5
00001978  4EF9 00001AB2           1362      JMP         EA_MOVEM            ;6
0000197E  4EF9 00001DD6           1363      JMP         EA_TRAP             ;7
00001984  4EF9 00001DD6           1364      JMP         EA_QUICK            ;8  DONE
0000198A  4EF9 00001E52           1365      JMP         EA_BRANCH           ;9  DONE
00001990  4EF9 00001F1A           1366      JMP         EA_MATH             ;10 DONE    DIVU, DIVS, SUB, CMP, MULU, ADD, ADDA
00001996  4EF9 00001F92           1367      JMP         EA_ROTATION         ;11         ASL, ASR, ???  
0000199C  4EF9 000019A2           1368      JMP         EA_FINISH           ;
000019A2                          1369  
000019A2                          1370  EA_FINISH:
000019A2  4E75                    1371      RTS ; TAKE OUT LATER
000019A4                          1372      
000019A4                          1373  
000019A4                          1374  
000019A4                          1375  ;********************************************  EA_TYPE  ****************************************************   
000019A4                          1376  
000019A4                          1377  EA_IMMEDIATE:                               ;value 0
000019A4  14FC 0009               1378      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
000019A8  14FC 0023               1379      MOVE.B  #'#',(A2)+                      ;add a # to buffer
000019AC  14FC 0024               1380      MOVE.B  #'$',(A2)+                      ;add a $ to buffer
000019B0                          1381      
000019B0                          1382      ;check size which is bits 6,7 and store in D6
000019B0                          1383      ;get immediate value from memory based off size and store in D7
000019B0  4EB9 00002112           1384      JSR     EA_CHECK_SIZE
000019B6                          1385      
000019B6                          1386      ;at this point our size is in D6 and data is in D7 and memory has been advanced
000019B6                          1387      ;convert immediate data to ascii and put on buffer
000019B6  4EB9 0000213C           1388      JSR     EA_ITOA_IMMEDIATE
000019BC                          1389      
000019BC  41F9 00002014           1390      LEA     EA_MODE_TABLE,A0                ;load table
000019C2  14FC 002C               1391      MOVE.B  #',',(A2)+                      ;add a # to buffer
000019C6  14FC 0009               1392      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
000019CA                          1393      
000019CA                          1394      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
000019CA                          1395      
000019CA                          1396      ;isolate source mode - bits 3,4,5 and store in D4
000019CA  2800                    1397      MOVE.L  D0,D4
000019CC  E64C                    1398      LSR.W   #3,D4
000019CE  0244 0007               1399      ANDI.W  #$7,D4
000019D2  C8FC 0006               1400      MULU    #6,D4
000019D6                          1401      
000019D6                          1402      ;isolate source register - bits 0,1,2 and store in D5
000019D6  2A00                    1403      MOVE.L  D0,D5
000019D8  0245 0007               1404      ANDI.W  #$7,D5
000019DC                          1405  
000019DC  4EB9 00002010           1406      JSR     EA_JMP_HELPER
000019E2  4EF8 19A2               1407      JMP     EA_FINISH
000019E6                          1408  
000019E6                          1409  ;D4 = mode      --> source / destination
000019E6                          1410  ;D5 = register  --> source / destination   
000019E6                          1411  EA_MOVE:
000019E6  14FC 0009               1412      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
000019EA  41F9 00002014           1413      LEA     EA_MODE_TABLE,A0                ;load table
000019F0                          1414      
000019F0                          1415      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
000019F0                          1416      
000019F0                          1417      ;isolate source mode
000019F0  2800                    1418      MOVE.L  D0,D4
000019F2  E64C                    1419      LSR.W   #3,D4
000019F4  0244 0007               1420      ANDI.W  #$7,D4
000019F8  C8FC 0006               1421      MULU    #6,D4
000019FC                          1422          
000019FC                          1423      ;isolate source register
000019FC  2A00                    1424      MOVE.L  D0,D5
000019FE  0245 0007               1425      ANDI.W  #$7,D5
00001A02                          1426      
00001A02  4EB9 00002010           1427      JSR    EA_JMP_HELPER
00001A08  14FC 002C               1428      MOVE.B  #',',(A2)+                  ;add ',' to buffer  
00001A0C                          1429      
00001A0C                          1430      ;isolate destination mode
00001A0C  2800                    1431      MOVE.L  D0,D4
00001A0E  EC4C                    1432      LSR.W   #6,D4
00001A10  0244 0007               1433      ANDI.W  #$7,D4
00001A14  C8FC 0006               1434      MULU    #6,D4
00001A18                          1435      
00001A18                          1436      ;isolate destination register 
00001A18  2A00                    1437      MOVE.L  D0,D5
00001A1A  E84D                    1438      LSR.W   #4,D5
00001A1C  EA4D                    1439      LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
00001A1E  0245 0007               1440      ANDI.W  #$7,D5   
00001A22  4EB9 00002010           1441      JSR     EA_JMP_HELPER
00001A28                          1442  
00001A28  4EF8 19A2               1443      JMP     EA_FINISH
00001A2C                          1444      
00001A2C                          1445  
00001A2C                          1446  EA_MOVEA:
00001A2C  14FC 0009               1447      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001A30  41F9 00002014           1448      LEA     EA_MODE_TABLE,A0                ;load table
00001A36                          1449  
00001A36                          1450      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
00001A36                          1451      
00001A36                          1452      ;isolate source mode
00001A36  2800                    1453      MOVE.L  D0,D4
00001A38  E64C                    1454      LSR.W   #3,D4
00001A3A  0244 0007               1455      ANDI.W  #$7,D4
00001A3E  C8FC 0006               1456      MULU    #6,D4
00001A42                          1457          
00001A42                          1458      ;isolate source register
00001A42  2A00                    1459      MOVE.L  D0,D5
00001A44  0245 0007               1460      ANDI.W  #$7,D5
00001A48                          1461      
00001A48  4EB9 00002010           1462      JSR    EA_JMP_HELPER
00001A4E  14FC 002C               1463      MOVE.B  #',',(A2)+                  ;add ',' to buffer
00001A52                          1464      
00001A52                          1465      ;isolate destination mode --> SHOULD ALWAYS BE 001 AND GO TO ADDRESS REGISTER
00001A52  2800                    1466      MOVE.L  D0,D4
00001A54  EC4C                    1467      LSR.W   #6,D4
00001A56  0244 0007               1468      ANDI.W  #$7,D4
00001A5A  C8FC 0006               1469      MULU    #6,D4
00001A5E                          1470      
00001A5E                          1471      ;isolate destination register 
00001A5E  2A00                    1472      MOVE.L  D0,D5
00001A60  E84D                    1473      LSR.W   #4,D5
00001A62  EA4D                    1474      LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
00001A64  0245 0007               1475      ANDI.W  #$7,D5   
00001A68  4EB9 00002010           1476      JSR     EA_JMP_HELPER
00001A6E                          1477  
00001A6E  4EF8 19A2               1478      JMP     EA_FINISH
00001A72                          1479  
00001A72                          1480  EA_LEA:
00001A72  14FC 0009               1481      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001A76  41F9 00002014           1482      LEA     EA_MODE_TABLE,A0                ;load table
00001A7C                          1483      
00001A7C                          1484      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
00001A7C                          1485      
00001A7C                          1486      ;isolate source mode
00001A7C  2800                    1487      MOVE.L  D0,D4
00001A7E  E64C                    1488      LSR.W   #3,D4
00001A80  0244 0007               1489      ANDI.W  #$7,D4
00001A84  C8FC 0006               1490      MULU    #6,D4
00001A88                          1491          
00001A88                          1492      ;isolate source register
00001A88  2A00                    1493      MOVE.L  D0,D5
00001A8A  0245 0007               1494      ANDI.W  #$7,D5
00001A8E                          1495      
00001A8E  4EB9 00002010           1496      JSR    EA_JMP_HELPER
00001A94  14FC 002C               1497      MOVE.B  #',',(A2)+                  ;add ',' to buffer
00001A98                          1498      
00001A98                          1499      ;destination always An
00001A98                          1500      ;MOVE.B  #'A',(A2)+                  ;add 'A' to buffer
00001A98                          1501      
00001A98                          1502      ;isolate destination register 
00001A98                          1503      ;MOVE.L  D0,D5
00001A98                          1504      ;LSR.W   #4,D5
00001A98                          1505      ;LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
00001A98                          1506      ;ANDI.W  #$7,D5
00001A98                          1507  
00001A98                          1508      ;isolate destination mode --> SHOULD ALWAYS BE 001 AND GO TO ADDRESS REGISTER
00001A98  7801                    1509      MOVE.L  #1,D4
00001A9A  C8FC 0006               1510      MULU    #6,D4
00001A9E                          1511      
00001A9E                          1512      ;isolate destination register 
00001A9E  2A00                    1513      MOVE.L  D0,D5
00001AA0  E84D                    1514      LSR.W   #4,D5
00001AA2  EA4D                    1515      LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
00001AA4  0245 0007               1516      ANDI.W  #$7,D5   
00001AA8  4EB9 00002010           1517      JSR     EA_JMP_HELPER
00001AAE                          1518  
00001AAE  4EF8 19A2               1519      JMP     EA_FINISH
00001AB2                          1520  
00001AB2                          1521  EA_DESTONLY:        ;JMP, CLR
00001AB2                          1522  
00001AB2                          1523  
00001AB2                          1524  
00001AB2                          1525  
00001AB2                          1526  
00001AB2                          1527  EA_EXT:
00001AB2                          1528  
00001AB2                          1529  
00001AB2                          1530  
00001AB2                          1531  
00001AB2                          1532  
00001AB2                          1533  EA_MOVEM:
00001AB2  14FC 0009               1534      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001AB6  41F9 00002014           1535      LEA     EA_MODE_TABLE,A0                ;load table
00001ABC                          1536      
00001ABC  2200                    1537      MOVE.L  D0,D1                           ;
00001ABE  341D                    1538      MOVE.W  (A5)+,D2                        ;come back and verify D2 is free!!!!!
00001AC0                          1539      
00001AC0                          1540      ;D1 = 4890 | D2 = 0080 (source)
00001AC0                          1541      
00001AC0                          1542      ;if direction (bit 10) == 0, destination is in opcode, source is in the second operand
00001AC0                          1543      ;if direction (bit 10) == 1, the source is in the opcode, destination is in the operand
00001AC0                          1544      
00001AC0                          1545      ;check direction (bit 10)
00001AC0  0241 0F00               1546      ANDI.W  #nibble2,D1
00001AC4  EA49                    1547      LSR.W   #5,D1
00001AC6  EA49                    1548      LSR.W   #5,D1                           ;total of 10 shifts
00001AC8  0241 0001               1549      ANDI.W  #1,D1
00001ACC  B23C 0000               1550      CMP.B   #0,D1
00001AD0  6700 000A               1551      BEQ     EA_MOVEM_REG_TO_MEM
00001AD4  B23C 0001               1552      CMP.B   #1,D1
00001AD8  6700 018E               1553      BEQ     EA_MOVEM_MEM_TO_REG
00001ADC                          1554      
00001ADC                          1555      
00001ADC                          1556  ;MOVEM.W    D/A2,(A7)    
00001ADC                          1557  EA_MOVEM_REG_TO_MEM:                        ;bit 10 == 0
00001ADC                          1558      ;check if data register or address register
00001ADC  4246                    1559      CLR     D6
00001ADE  3C02                    1560      MOVE.W  D2,D6
00001AE0  0246 FF00               1561      ANDI.W  #$FF00,D6                       ;isolate nibble 1 and 2
00001AE4  BC7C 0000               1562      CMP.W   #0,D6                           ;check if 0
00001AE8  6700 00A4               1563      BEQ     EA_MOVEM_DATAREG_TO_MEM        ;if 0, source is data register
00001AEC                          1564      
00001AEC  3C02                    1565      MOVE.W  D2,D6
00001AEE  0246 00FF               1566      ANDI.W  #$00FF,D6
00001AF2  BC7C 0000               1567      CMP.W   #0,D6
00001AF6  6700 011E               1568      BEQ     EA_MOVEM_ADDRREG_TO_MEM        ;else it is address register
00001AFA                          1569      
00001AFA                          1570      
00001AFA                          1571      ;else, both are populated and we need to handle mixture
00001AFA                          1572      
00001AFA  2C02                    1573      MOVE.L  D2,D6
00001AFC  4247                    1574      CLR     D7
00001AFE                          1575      
00001AFE  0246 00FF               1576      ANDI.W  #$00FF,D6
00001B02  1E3C 0000               1577      MOVE.B  #0,D7
00001B06  4245                    1578      CLR     D5
00001B08  4243                    1579      CLR     D3
00001B0A  4241                    1580      CLR     D1
00001B0C  6100 0266               1581      BSR     MOVEM_LOOP
00001B10                          1582      
00001B10  14FC 0044               1583      MOVE.B  #'D',(A2)+
00001B14  0603 0030               1584      ADDI.B  #$30,D3
00001B18  14C3                    1585      MOVE.B  D3,(A2)+
00001B1A                          1586      
00001B1A                          1587      
00001B1A  0605 0030               1588      ADDI.B  #$30,D5
00001B1E  4241                    1589      CLR     D1
00001B20  323C 0000               1590      MOVE.W  #0,D1
00001B24                          1591      
00001B24  4EB9 00001BE8           1592      JSR MOVEM_CHECK_MULTIPLE
00001B2A                          1593      
00001B2A  14FC 002F               1594      MOVE.B  #'/',(A2)+
00001B2E                          1595      
00001B2E  2C02                    1596      MOVE.L  D2,D6
00001B30  4247                    1597      CLR D7
00001B32                          1598      
00001B32  0246 FF00               1599      ANDI.W  #$FF00,D6
00001B36  E04E                    1600      LSR.W   #8,D6
00001B38  1E3C 0000               1601      MOVE.B  #0,D7
00001B3C  4245                    1602      CLR     D5
00001B3E  4243                    1603      CLR     D3
00001B40  4241                    1604      CLR     D1
00001B42  14FC 0041               1605      MOVE.B  #'A',(A2)+
00001B46                          1606      
00001B46  6100 022C               1607      BSR     MOVEM_LOOP
00001B4A                          1608      
00001B4A  0603 0030               1609      ADDI.B  #$30,D3
00001B4E  14C3                    1610      MOVE.B  D3,(A2)+
00001B50                          1611      
00001B50  0605 0030               1612      ADDI.B  #$30,D5
00001B54  4241                    1613      CLR     D1
00001B56  323C 0001               1614      MOVE.W  #1,D1
00001B5A                          1615      
00001B5A  4EB9 00001BE8           1616      JSR MOVEM_CHECK_MULTIPLE
00001B60                          1617      
00001B60                          1618      
00001B60                          1619      ;handle second part now
00001B60                          1620      
00001B60  14FC 002C               1621      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001B64                          1622  
00001B64  41F9 00002014           1623      LEA     EA_MODE_TABLE,A0                ;load table
00001B6A                          1624      
00001B6A                          1625      ;isolate source mode
00001B6A  2800                    1626      MOVE.L  D0,D4
00001B6C  E64C                    1627      LSR.W   #3,D4   
00001B6E  0244 0007               1628      ANDI.W  #$7,D4
00001B72                          1629      
00001B72                          1630      ;check for mode 111 -> immediate data
00001B72  B87C 0007               1631      CMP.W   #$7,D4
00001B76                          1632      ;if immediate data, leave and get immediate data rather than another register
00001B76  6700 022A               1633      BEQ     EA_MOVEM_IMMEDIATE_DESTINATION     
00001B7A                          1634      
00001B7A  C8FC 0006               1635      MULU    #6,D4
00001B7E                          1636       
00001B7E                          1637      ;isolate source register
00001B7E  2A00                    1638      MOVE.L  D0,D5
00001B80  0245 0007               1639      ANDI.W  #$7,D5
00001B84                          1640      
00001B84  4EB9 00002010           1641      JSR    EA_JMP_HELPER
00001B8A  4EF8 19A2               1642      JMP     EA_FINISH
00001B8E                          1643  
00001B8E                          1644  EA_MOVEM_DATAREG_TO_MEM:    
00001B8E  2C02                    1645      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001B90  4247                    1646      CLR     D7
00001B92                          1647      
00001B92  1E3C 0000               1648      MOVE.B  #0,D7
00001B96  4245                    1649      CLR D5
00001B98  4243                    1650      CLR D3
00001B9A  4241                    1651      CLR D1
00001B9C                          1652      
00001B9C  14FC 0044               1653      MOVE.B  #'D',(A2)+                      ;add 'D' to buffer
00001BA0  6100 01D2               1654      BSR     MOVEM_LOOP                      ;enter loop to get number
00001BA4                          1655  
00001BA4                          1656      ;convert d3 to ascii and add to buffer
00001BA4  0603 0030               1657      ADDI.B  #$30,D3                         ;convert to ASCII
00001BA8  14C3                    1658      MOVE.B  D3,(A2)+                        ;put on buffer
00001BAA                          1659  
00001BAA                          1660      ;check d5 and handle
00001BAA  0605 0030               1661      ADDI.B  #$30,D5
00001BAE                          1662      
00001BAE  4241                    1663      CLR     D1
00001BB0  323C 0000               1664      MOVE.W  #0,D1                           ;FLAG TO INDICATE D
00001BB4                          1665      
00001BB4  4EB9 00001BE8           1666      JSR     MOVEM_CHECK_MULTIPLE
00001BBA                          1667      
00001BBA  14FC 002C               1668      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001BBE                          1669  
00001BBE  41F9 00002014           1670      LEA     EA_MODE_TABLE,A0                ;load table
00001BC4                          1671      
00001BC4                          1672      ;isolate source mode
00001BC4  2800                    1673      MOVE.L  D0,D4
00001BC6  E64C                    1674      LSR.W   #3,D4   
00001BC8  0244 0007               1675      ANDI.W  #$7,D4
00001BCC                          1676      
00001BCC                          1677      ;check for mode 111 -> immediate data
00001BCC  B87C 0007               1678      CMP.W   #$7,D4
00001BD0                          1679      ;if immediate data, leave and get immediate data rather than another register
00001BD0  6700 01D0               1680      BEQ     EA_MOVEM_IMMEDIATE_DESTINATION     
00001BD4                          1681      
00001BD4  C8FC 0006               1682      MULU    #6,D4
00001BD8                          1683       
00001BD8                          1684      ;isolate source register
00001BD8  2A00                    1685      MOVE.L  D0,D5
00001BDA  0245 0007               1686      ANDI.W  #$7,D5
00001BDE                          1687      
00001BDE  4EB9 00002010           1688      JSR    EA_JMP_HELPER
00001BE4  4EF8 19A2               1689      JMP     EA_FINISH
00001BE8                          1690  
00001BE8                          1691  
00001BE8                          1692      
00001BE8                          1693  MOVEM_CHECK_MULTIPLE:
00001BE8  BA43                    1694      CMP     D3,D5
00001BEA  6600 0004               1695      BNE     MOVEM_MULTIPLE
00001BEE  4E75                    1696      RTS
00001BF0                          1697      
00001BF0                          1698  MOVEM_MULTIPLE:
00001BF0  14FC 002D               1699      MOVE.B  #'-',(A2)+                      ;add '-' to buffer
00001BF4                          1700      ;CHECK D1 FOR A OR D
00001BF4  B27C 0000               1701      CMP.W   #0,D1                           ;check if 0 --> D
00001BF8  6700 000C               1702      BEQ     MOVEM_MULTIPLE_D
00001BFC  B27C 0001               1703      CMP.W   #1,D1
00001C00  6700 000C               1704      BEQ     MOVEM_MULTIPLE_A
00001C04                          1705  
00001C04  4E75                    1706      RTS
00001C06                          1707  
00001C06                          1708  MOVEM_MULTIPLE_D:
00001C06  14FC 0044               1709      MOVE.B  #'D',(A2)+                      ;add 'D' to buffer
00001C0A  14C5                    1710      MOVE.B  D5,(A2)+                        ;put on buffer
00001C0C  4E75                    1711      RTS
00001C0E                          1712  
00001C0E                          1713  MOVEM_MULTIPLE_A:
00001C0E  14FC 0041               1714      MOVE.B  #'A',(A2)+                      ;add 'D' to buffer
00001C12  14C5                    1715      MOVE.B  D5,(A2)+                        ;put on buffer
00001C14  4E75                    1716      RTS
00001C16                          1717  
00001C16                          1718  EA_MOVEM_ADDRREG_TO_MEM:
00001C16  2C02                    1719      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001C18  4247                    1720      CLR     D7
00001C1A                          1721      
00001C1A  1E3C 0000               1722      MOVE.B  #0,D7
00001C1E  4245                    1723      CLR D5
00001C20  4243                    1724      CLR D3
00001C22  4241                    1725      CLR D1
00001C24                          1726      
00001C24  14FC 0041               1727      MOVE.B  #'A',(A2)+                      ;add 'A' to buffer
00001C28  E04E                    1728      LSR.W   #8,D6                           ;shift 8 times
00001C2A  6100 0148               1729      BSR     MOVEM_LOOP                      ;enter loop to get number
00001C2E                          1730      
00001C2E                          1731      ;convert d3 to ascii and add to buffer
00001C2E  0603 0030               1732      ADDI.B  #$30,D3                         ;convert to ASCII
00001C32  14C3                    1733      MOVE.B  D3,(A2)+                        ;put on buffer
00001C34                          1734      
00001C34  0605 0030               1735      ADDI.B  #$30,D5
00001C38                          1736      
00001C38  4241                    1737      CLR     D1
00001C3A  323C 0001               1738      MOVE.W  #1,D1                           ;FLAG TO INDICATE A
00001C3E                          1739      
00001C3E  4EB8 1BE8               1740      JSR MOVEM_CHECK_MULTIPLE
00001C42                          1741      
00001C42  14FC 002C               1742      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001C46                          1743      ;MOVEM.s D7,
00001C46                          1744      
00001C46  41F9 00002014           1745      LEA     EA_MODE_TABLE,A0                ;load table
00001C4C                          1746      
00001C4C                          1747      ;isolate source mode
00001C4C  2800                    1748      MOVE.L  D0,D4
00001C4E  E64C                    1749      LSR.W   #3,D4
00001C50  0244 0007               1750      ANDI.W  #$7,D4
00001C54  C8FC 0006               1751      MULU    #6,D4
00001C58                          1752          
00001C58                          1753      ;isolate source register
00001C58  2A00                    1754      MOVE.L  D0,D5
00001C5A  0245 0007               1755      ANDI.W  #$7,D5
00001C5E                          1756      
00001C5E  4EB9 00002010           1757      JSR    EA_JMP_HELPER
00001C64  4EF8 19A2               1758      JMP     EA_FINISH
00001C68                          1759  
00001C68                          1760  ;MOVEM.W (A7),D/A2
00001C68                          1761  EA_MOVEM_MEM_TO_REG:                        ;bit 10 == 1
00001C68  41F9 00002014           1762      LEA     EA_MODE_TABLE,A0                ;load table
00001C6E                          1763      
00001C6E                          1764      ;isolate source mode
00001C6E  2800                    1765      MOVE.L  D0,D4
00001C70  E64C                    1766      LSR.W   #3,D4
00001C72  0244 0007               1767      ANDI.W  #$7,D4
00001C76                          1768  
00001C76                          1769      ;check for mode 111 -> immediate data
00001C76  B87C 0007               1770      CMP.W   #$7,D4
00001C7A                          1771      ;if immediate data, leave and get immediate data rather than another register
00001C7A  6700 0136               1772      BEQ     EA_MOVEM_IMMEDIATE_SOURCE
00001C7E                          1773  
00001C7E  C8FC 0006               1774      MULU    #6,D4
00001C82                          1775          
00001C82                          1776      ;isolate source register
00001C82  2A00                    1777      MOVE.L  D0,D5
00001C84  0245 0007               1778      ANDI.W  #$7,D5
00001C88                          1779  
00001C88  4EB9 00002010           1780      JSR    EA_JMP_HELPER
00001C8E  14FC 002C               1781      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001C92                          1782      
00001C92                          1783      ;our operand is in D2
00001C92  4246                    1784      CLR     D6
00001C94  3C02                    1785      MOVE.W  D2,D6
00001C96  0246 FF00               1786      ANDI.W  #$FF00,D6                       ;isolate nibble 1 and 2
00001C9A  BC7C 0000               1787      CMP.W   #0,D6                           ;check if 0
00001C9E  6700 0076               1788      BEQ     EA_MOVEM_MEM_TO_DATAREG        ;if 0, source is data register
00001CA2                          1789      
00001CA2  3C02                    1790      MOVE.W  D2,D6
00001CA4  0246 00FF               1791      ANDI.W  #$00FF,D6 
00001CA8  BC7C 0000               1792      CMP.W   #0,D6
00001CAC  6700 0096               1793      BEQ     EA_MOVEM_MEM_TO_ADDRREG        ;else it is address register
00001CB0                          1794  
00001CB0                          1795      ;else, both are populated and we need to handle mixture (D7/A5)
00001CB0  2C02                    1796      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001CB2  4247                    1797      CLR     D7
00001CB4                          1798  
00001CB4  0246 00FF               1799      ANDI.W  #$00FF,D6                       ;work on first half
00001CB8  1E3C 0000               1800      MOVE.B  #0,D7
00001CBC  4245                    1801      CLR D5
00001CBE  4243                    1802      CLR D3
00001CC0  4241                    1803      CLR D1
00001CC2  14FC 0044               1804      MOVE.B  #'D',(A2)+                      ;add 'D' to buffer
00001CC6  6100 00AC               1805      BSR     MOVEM_LOOP                      ;enter loop to get number
00001CCA                          1806      ;convert d7 to ascii and add to buffer
00001CCA  0603 0030               1807      ADDI.B  #$30,D3                         ;convert to ASCII
00001CCE  14C3                    1808      MOVE.B  D3,(A2)+                        ;put on buffer
00001CD0                          1809      ;check multiple
00001CD0  0605 0030               1810      ADDI.B  #$30,D5
00001CD4  4241                    1811      CLR     D1
00001CD6  323C 0000               1812      MOVE.W  #0,D1                           ;FLAG TO INDICATE D
00001CDA                          1813      
00001CDA  4EB8 1BE8               1814      JSR MOVEM_CHECK_MULTIPLE
00001CDE                          1815  
00001CDE  14FC 002F               1816      MOVE.B  #'/',(A2)+                      ;add '/' to buffer
00001CE2                          1817  
00001CE2  2C02                    1818      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001CE4  4247                    1819      CLR     D7
00001CE6                          1820  
00001CE6  0246 FF00               1821      ANDI.W  #$FF00,D6                       ;work on FIRST half
00001CEA  E04E                    1822      LSR.W   #8,D6                           ;shift 8 times
00001CEC  1E3C 0000               1823      MOVE.B  #0,D7
00001CF0  4245                    1824      CLR D5
00001CF2  4243                    1825      CLR D3
00001CF4  4241                    1826      CLR D1
00001CF6  14FC 0041               1827      MOVE.B  #'A',(A2)+                      ;add 'A' to buffer
00001CFA  6100 0078               1828      BSR     MOVEM_LOOP                      ;enter loop to get number
00001CFE                          1829      ;convert d7 to ascii and add to buffer
00001CFE  0603 0030               1830      ADDI.B  #$30,D3                         ;convert to ASCII
00001D02  14C3                    1831      MOVE.B  D3,(A2)+                        ;put on buffer
00001D04                          1832      ;check multiple
00001D04  0605 0030               1833      ADDI.B  #$30,D5
00001D08  4241                    1834      CLR     D1
00001D0A  323C 0001               1835      MOVE.W  #1,D1                           ;FLAG TO INDICATE A
00001D0E                          1836      
00001D0E  4EB8 1BE8               1837      JSR MOVEM_CHECK_MULTIPLE
00001D12                          1838  
00001D12  4EF8 19A2               1839      JMP     EA_FINISH    
00001D16                          1840          
00001D16                          1841  EA_MOVEM_MEM_TO_DATAREG: 
00001D16  2C02                    1842      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001D18  4247                    1843      CLR     D7
00001D1A                          1844      
00001D1A  1E3C 0000               1845      MOVE.B  #0,D7
00001D1E  4245                    1846      CLR D5
00001D20  4243                    1847      CLR D3
00001D22  4241                    1848      CLR D1
00001D24                          1849      
00001D24  14FC 0044               1850      MOVE.B  #'D',(A2)+                      ;add 'D' to buffer
00001D28  6100 004A               1851      BSR     MOVEM_LOOP                      ;enter loop to get number
00001D2C                          1852      
00001D2C                          1853      ;convert d7 to ascii and add to buffer
00001D2C  0603 0030               1854      ADDI.B  #$30,D3                         ;convert to ASCII
00001D30  14C3                    1855      MOVE.B  D3,(A2)+                        ;put on buffer
00001D32                          1856  
00001D32                          1857      ;check multiple
00001D32  0605 0030               1858      ADDI.B  #$30,D5
00001D36                          1859      
00001D36  4241                    1860      CLR     D1
00001D38  323C 0000               1861      MOVE.W  #0,D1                           ;FLAG TO INDICATE D
00001D3C                          1862      
00001D3C  4EB8 1BE8               1863      JSR MOVEM_CHECK_MULTIPLE
00001D40                          1864  
00001D40  4EF8 19A2               1865      JMP     EA_FINISH
00001D44                          1866     
00001D44                          1867  EA_MOVEM_MEM_TO_ADDRREG:
00001D44  2C02                    1868      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001D46  4247                    1869      CLR     D7  
00001D48                          1870      
00001D48  1E3C 0000               1871      MOVE.B  #0,D7
00001D4C  4245                    1872      CLR D5
00001D4E  4243                    1873      CLR D3
00001D50  4241                    1874      CLR D1
00001D52                          1875         
00001D52  14FC 0041               1876      MOVE.B  #'A',(A2)+                      ;add 'A' to buffer
00001D56  E04E                    1877      LSR.W   #8,D6                           ;shift 8 times
00001D58  6100 001A               1878      BSR     MOVEM_LOOP                      ;enter loop to get number
00001D5C                          1879      
00001D5C                          1880      ;convert d7 to ascii and add to buffer
00001D5C  0603 0030               1881      ADDI.B  #$30,D3                         ;convert to ASCII
00001D60  14C3                    1882      MOVE.B  D3,(A2)+                        ;put on buffer
00001D62                          1883  
00001D62                          1884      ;check multiple   
00001D62  0605 0030               1885      ADDI.B  #$30,D5 
00001D66  4241                    1886      CLR     D1
00001D68  323C 0001               1887      MOVE.W  #1,D1                           ;FLAG TO INDICATE A
00001D6C                          1888      
00001D6C  4EB8 1BE8               1889      JSR MOVEM_CHECK_MULTIPLE
00001D70                          1890  
00001D70  4EF8 19A2               1891      JMP     EA_FINISH
00001D74                          1892  
00001D74                          1893  MOVEM_LOOP  
00001D74                          1894      ;D1 = min_set_flag (0 = not set, 1 = set) | D3 = MIN | D5 = MAX | D7 = COUNTER (STARTS AT 0)
00001D74                          1895      ;D6 = OUR SECOND OPERAND
00001D74                          1896       
00001D74  E24E                    1897      LSR.W   #1,D6               ;1000
00001D76  6500 000C               1898      BCS     MOVEM_CARRY
00001D7A  5247                    1899      ADDI.W  #1,D7
00001D7C  BE7C 0008               1900      CMP     #8,D7
00001D80  6FF2                    1901      BLE     MOVEM_LOOP
00001D82  4E75                    1902      RTS
00001D84                          1903  
00001D84                          1904  MOVEM_CARRY:
00001D84  B27C 0000               1905      CMP         #0,D1
00001D88  6700 000A               1906      BEQ         MOVEM_SET_MIN
00001D8C                          1907      
00001D8C  3A07                    1908      MOVE.W      D7,D5
00001D8E  5247                    1909      ADDI.W      #1,D7  
00001D90  4EF8 1D74               1910      JMP         MOVEM_LOOP
00001D94                          1911  
00001D94                          1912  MOVEM_SET_MIN:
00001D94  3607                    1913      MOVE.W      D7,D3           ;set min
00001D96  3A07                    1914      MOVE.W      D7,D5           ;set max
00001D98  323C 0001               1915      MOVE.W      #1,D1           ;set flag
00001D9C  5247                    1916      ADDI.W      #1,D7  
00001D9E  4EF8 1D74               1917      JMP         MOVEM_LOOP
00001DA2                          1918  
00001DA2                          1919  
00001DA2                          1920  
00001DA2                          1921  EA_MOVEM_IMMEDIATE_DESTINATION:
00001DA2                          1922      ;GET NEXT WORD VALUE AT A5 AND INCREMENT
00001DA2  3E15                    1923      MOVE.W  (A5),D7                        ;immediate value is in D7 now
00001DA4  14FC 0024               1924      MOVE.B  #'$',(A2)+                      ;add '$' to buffer
00001DA8                          1925      
00001DA8                          1926      ;convert to ascii and put on buffer
00001DA8  4EB9 00002160           1927      JSR     EA_ITOA_WORD
00001DAE                          1928  
00001DAE  4EF8 19A2               1929      JMP     EA_FINISH
00001DB2                          1930  
00001DB2                          1931  EA_MOVEM_IMMEDIATE_SOURCE:
00001DB2                          1932      ;GET NEXT WORD VALUE AT A5 AND INCREMENT
00001DB2  3E15                    1933      MOVE.W  (A5),D7                        ;immediate value is in D7 now
00001DB4  14FC 0024               1934      MOVE.B  #'$',(A2)+                      ;add '$' to buffer
00001DB8                          1935      
00001DB8                          1936      ;convert to ascii and put on buffer
00001DB8  4EB9 00002160           1937      JSR     EA_ITOA_WORD
00001DBE                          1938  
00001DBE                          1939      ;TRY THIS
00001DBE  14FC 002C               1940      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001DC2                          1941      
00001DC2                          1942      ;our operand is in D2
00001DC2  4246                    1943      CLR     D6
00001DC4  3C02                    1944      MOVE.W  D2,D6
00001DC6  0246 FF00               1945      ANDI.W  #$FF00,D6                       ;isolate nibble 1 and 2
00001DCA  BC7C 0000               1946      CMP.W   #0,D6                           ;check if 0
00001DCE  6700 FF46               1947      BEQ     EA_MOVEM_MEM_TO_DATAREG        ;if 0, source is data register
00001DD2  6000 FF70               1948      BRA     EA_MOVEM_MEM_TO_ADDRREG        ;else it is address register
00001DD6                          1949  
00001DD6                          1950  
00001DD6                          1951  
00001DD6                          1952  
00001DD6                          1953  
00001DD6                          1954  
00001DD6                          1955  
00001DD6                          1956  EA_TRAP:
00001DD6                          1957  
00001DD6                          1958  
00001DD6                          1959  
00001DD6                          1960  
00001DD6                          1961  
00001DD6                          1962  EA_QUICK:
00001DD6                          1963      ;FIGURE WHAT KIND? (ADDQ,SUBQ,MOVEQ)
00001DD6                          1964      ;ADDQ/SUBQ  -->  opcode = 0101 (stored in D0)
00001DD6                          1965      ;MOVEQ      -->  opcode = 0111 (stored in D0)
00001DD6  14FC 0009               1966      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001DDA  14FC 0023               1967      MOVE.B  #'#',(A2)+                  ;add a # to buffer
00001DDE  14FC 0024               1968      MOVE.B  #'$',(A2)+                  ;add a $ to buffer
00001DE2                          1969      
00001DE2  2200                    1970      MOVE.L  D0,D1                       ;should move into D1
00001DE4                          1971      
00001DE4                          1972      ;check for MOVEQ
00001DE4  EC49                    1973      LSR.W   #right6,D1
00001DE6  EC49                    1974      LSR.W   #right6,D1  
00001DE8  B27C 0007               1975      CMP.W   #$7,D1
00001DEC  6700 003A               1976      BEQ     EA_QUICK_MOVEQ
00001DF0                          1977      
00001DF0  4241                    1978      CLR     D1                          ;else not MOVEQ, reset D1 and continue with ADDQ / SUBQ
00001DF2  2200                    1979      MOVE.L  D0,D1
00001DF4  0241 0E00               1980      ANDI.W  #dest_reg,D1                ;isolate destination register(11,10,9)
00001DF8  E049                    1981      LSR.W   #right8,D1                  ;shift 8 times
00001DFA  E249                    1982      LSR.W   #right1,D1                  ;shift 1 time for total of 9 times
00001DFC                          1983      
00001DFC                          1984      ;at this point we have our number, so convert to ASCII and put on buffer
00001DFC  0601 0030               1985      ADDI.B  #$30,D1                     ;convert to ASCII
00001E00  14C1                    1986      MOVE.B  D1,(A2)+                    ;put on buffer
00001E02                          1987      
00001E02                          1988      
00001E02                          1989      ;ready for destination address
00001E02  14FC 002C               1990      MOVE.B  #',',(A2)+                  ;add ',' to buffer  
00001E06  41F9 00002014           1991      LEA     EA_MODE_TABLE,A0            ;load table
00001E0C                          1992      
00001E0C                          1993      
00001E0C                          1994      ;isolate source mode
00001E0C  2800                    1995      MOVE.L  D0,D4
00001E0E  E64C                    1996      LSR.W   #3,D4
00001E10  0244 0007               1997      ANDI.W  #$7,D4
00001E14  C8FC 0006               1998      MULU    #6,D4
00001E18                          1999          
00001E18                          2000      ;isolate source register
00001E18  2A00                    2001      MOVE.L  D0,D5
00001E1A  0245 0007               2002      ANDI.W  #$7,D5
00001E1E                          2003      
00001E1E  4EB9 00002010           2004      JSR    EA_JMP_HELPER
00001E24                          2005      
00001E24  4EF8 19A2               2006      JMP     EA_FINISH
00001E28                          2007      
00001E28                          2008      ;LSR.W       #right12,D1         ;shift D1 by 12 bits, leaving just 4 bits      --> gives shift count error
00001E28                          2009      ;CMP.W       #$5,D1
00001E28                          2010      ;BEQ         EA_ADDQ_SUBQ
00001E28                          2011      
00001E28                          2012  EA_QUICK_MOVEQ:
00001E28  2200                    2013      MOVE.L  D0,D1
00001E2A  0241 00FF               2014      ANDI.W  #$00FF,D1               ;isolate bits 7-0
00001E2E                          2015      
00001E2E                          2016      ;our bits are isolated in D1, move to D7 for ITOA function
00001E2E  2E01                    2017      MOVE.L  D1,D7
00001E30  4EB9 0000219E           2018      JSR     EA_ITOA_BYTE_CONVERT
00001E36                          2019      
00001E36  14FC 002C               2020      MOVE.B  #',',(A2)+                  ;add ',' to buffer
00001E3A  14FC 0044               2021      MOVE.B  #'D',(A2)+                  ;add ',' to buffer
00001E3E  2200                    2022      MOVE.L  D0,D1
00001E40  0241 0F00               2023      ANDI.W  #nibble2,D1
00001E44  E049                    2024      LSR.W   #8,D1
00001E46  E249                    2025      LSR.W   #1,D1
00001E48                          2026      
00001E48                          2027      ;at this point we have our number, so convert to ASCII and put on buffer
00001E48  0601 0030               2028      ADDI.B  #$30,D1                     ;convert to ASCII
00001E4C  14C1                    2029      MOVE.B  D1,(A2)+                    ;put on buffer
00001E4E                          2030  
00001E4E  4EF8 19A2               2031      JMP     EA_FINISH
00001E52                          2032  
00001E52                          2033  EA_BRANCH:
00001E52                          2034      ;PROGRAM COUNTER @ A5
00001E52                          2035      ;BRA or BSR
00001E52                          2036      ;displacement bits are 7-0 
00001E52  2200                    2037      MOVE.L  D0,D1
00001E54  0241 00FF               2038      ANDI.W  #$00FF,D1               ;isolate bits 7-0
00001E58                          2039      ;PERFORM CHECKS 0000 0000 = WORD VALUE, 1111 1111 = LONG VALUE
00001E58                          2040      
00001E58  B23C 0000               2041      CMP.B   #$00,D1
00001E5C  6700 0086               2042      BEQ     EA_BRANCH_16
00001E60                          2043      
00001E60                          2044      ;if not 0
00001E60  B23C 00FF               2045      CMP.B   #$FF,D1
00001E64  6700 0096               2046      BEQ     EA_BRANCH_32
00001E68                          2047      
00001E68                          2048      ;OTHERWISE... HANDLE 8-BITDISPLACEMENT IN OPCODE!    
00001E68  2200                    2049      MOVE.L  D0,D1
00001E6A  0241 00FF               2050      ANDI.W  #$00FF,D1    
00001E6E  6000 0002               2051      BRA     EA_BRANCH_8_BIT_DISPLACEMENT
00001E72                          2052      
00001E72                          2053      
00001E72                          2054  
00001E72                          2055  EA_BRANCH_8_BIT_DISPLACEMENT:
00001E72                          2056      ;D0,D1 HAVE OPCODE
00001E72  EE49                    2057      LSR     #7,D1
00001E74                          2058      
00001E74  B23C 0000               2059      CMP.B   #0,D1
00001E78  6700 0006               2060      BEQ     EA_BRANCH_POSITIVE              ;bit = 0
00001E7C  6000 001A               2061      BRA     EA_BRANCH_NEGATIVE              ;bit = 1
00001E80                          2062  
00001E80                          2063  EA_BRANCH_POSITIVE:
00001E80  2200                    2064      MOVE.L  D0,D1
00001E82                          2065      ;D1 = 6004
00001E82                          2066      
00001E82  0241 00FF               2067      ANDI.W  #$00FF,D1                   ;isolate displacement
00001E86  3E0D                    2068      MOVE.W  A5,D7                       ;current address    
00001E88  DE41                    2069      ADD     D1,D7                       ;add    
00001E8A  14FC 0009               2070      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001E8E                          2071      
00001E8E  4EB9 00001EB2           2072      JSR     EA_BRANCH_ITOA_HELPER
00001E94  4EF8 19A2               2073      JMP     EA_FINISH
00001E98                          2074  
00001E98                          2075  EA_BRANCH_NEGATIVE:
00001E98  2200                    2076      MOVE.L  D0,D1
00001E9A  0241 00FF               2077      ANDI.W  #$00FF,D1
00001E9E  4401                    2078      NEG.B   D1  
00001EA0                          2079      
00001EA0  3E0D                    2080      MOVE.W  A5,D7
00001EA2  9E41                    2081      SUB     D1,D7
00001EA4                          2082  
00001EA4  14FC 0009               2083      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001EA8                          2084  
00001EA8  4EB9 00001EB2           2085      JSR     EA_BRANCH_ITOA_HELPER
00001EAE  4EF8 19A2               2086      JMP     EA_FINISH
00001EB2                          2087  
00001EB2                          2088  EA_BRANCH_ITOA_HELPER:
00001EB2                          2089      ;VALUE IN D2 --> 00000400
00001EB2  2407                    2090      MOVE.L  D7,D2                   ;PRESERVE COPY
00001EB4  E04F                    2091      LSR.W   #right8,D7
00001EB6  E04F                    2092      LSR.W   #right8,D7
00001EB8  E04F                    2093      LSR.W   #right8,D7
00001EBA  4EB9 0000219E           2094      JSR     EA_ITOA_BYTE_CONVERT
00001EC0                          2095  
00001EC0  2E02                    2096      MOVE.L  D2,D7
00001EC2  E04F                    2097      LSR.W   #right8,D7
00001EC4  E04F                    2098      LSR.W   #right8,D7    
00001EC6  4EB9 0000219E           2099      JSR     EA_ITOA_BYTE_CONVERT
00001ECC                          2100  
00001ECC  2E02                    2101      MOVE.L  D2,D7
00001ECE  E04F                    2102      LSR.W   #right8,D7
00001ED0  4EB9 0000219E           2103      JSR     EA_ITOA_BYTE_CONVERT
00001ED6                          2104  
00001ED6  2E02                    2105      MOVE.L  D2,D7
00001ED8  4EB9 0000219E           2106      JSR     EA_ITOA_BYTE_CONVERT
00001EDE                          2107  
00001EDE  4EF9 000021D6           2108      JMP     EA_ITOA_DONE
00001EE4                          2109  
00001EE4                          2110  EA_BRANCH_16:
00001EE4  3215                    2111      MOVE.W  (A5),D1                    ;CHECK WHERE POINTER IS WHEN HITS HERE
00001EE6                          2112      ;D1 WILL HAVE OUR DISPLACEMENT (0E32)
00001EE6                          2113      ;ADD 0E32 TO PC + 2
00001EE6  3E01                    2114      MOVE.W  D1,D7
00001EE8  DE4D                    2115      ADD.W   A5,D7
00001EEA                          2116      ;SUBI.B  #2,D7
00001EEA                          2117      
00001EEA  14FC 0009               2118      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001EEE  14FC 0024               2119      MOVE.B  #'$',(A2)+                  ;add '$' to buffer
00001EF2                          2120      
00001EF2                          2121      ;convert to ASCII and put on buffer
00001EF2                          2122      ;D7 HAS DISPLACEMENT   
00001EF2  4EB9 00001EFC           2123      JSR     BRANCH_16_ITOA
00001EF8                          2124      
00001EF8  4EF8 19A2               2125      JMP     EA_FINISH
00001EFC                          2126  
00001EFC                          2127  EA_BRANCH_32:
00001EFC                          2128      ;come back and implement branch 32
00001EFC                          2129  
00001EFC                          2130  
00001EFC                          2131  
00001EFC                          2132  BRANCH_16_ITOA:
00001EFC                          2133      ;D7 HAS OUR DISPLACEMENT... CONVERT TO ASCII!   ;D7 = 1234
00001EFC  E04F                    2134      LSR.W   #right8,D7                              ;D7 = 0012
00001EFE  4EB9 0000219E           2135      JSR     EA_ITOA_BYTE_CONVERT                    ;BUFFER WILL HAVE 12
00001F04  3E1D                    2136      MOVE.W  (A5)+,D7                                ;D7 = 0E32
00001F06  DE4D                    2137      ADD.W   A5,D7                                   ;D7 = 123
00001F08  5507                    2138      SUBI.B  #2,D7                                   ;SUBI 2 to account for post increment of A5
00001F0A  0247 00FF               2139      ANDI.W  #$00FF,D7                               ;D7 = 0034
00001F0E  4EB9 0000219E           2140      JSR     EA_ITOA_BYTE_CONVERT                    ;BUFFER WILL HAVE 1234
00001F14                          2141      
00001F14  4EF9 000021D6           2142      JMP     EA_ITOA_DONE
00001F1A                          2143  
00001F1A                          2144  
00001F1A                          2145  EA_MATH:
00001F1A                          2146      ;source mode 3, 4, 5 | source register 0, 1, 2 | destination register 11, 10, 9
00001F1A  14FC 0009               2147      MOVE.B  #$09, (A2)+             ;add a ' ' to buffer
00001F1E  41F9 00002014           2148      LEA     EA_MODE_TABLE,A0        ;load mode table
00001F24                          2149      
00001F24                          2150      ;isolate source mode
00001F24  2800                    2151      MOVE.L  D0,D4
00001F26  E64C                    2152      LSR.W   #3,D4
00001F28  0244 0007               2153      ANDI.W  #$7,D4
00001F2C  C8FC 0006               2154      MULU    #6,D4
00001F30                          2155      
00001F30                          2156      ;isolate source register
00001F30  2A00                    2157      MOVE.L  D0,D5
00001F32  0245 0007               2158      ANDI.W  #$7,D5
00001F36                          2159      
00001F36  4EB9 00002010           2160      JSR     EA_JMP_HELPER
00001F3C                          2161      
00001F3C  14FC 002C               2162      MOVE.B  #',',(A2)+              ;add a ',' to buffer
00001F40                          2163      
00001F40                          2164      ;condition for ADDA - opcode == 1101 && bits 7,6 == 11
00001F40                          2165      ;check for ADDA and leave if yes, otherwise continue
00001F40  2200                    2166      MOVE.L  D0,D1                   ;complete opcode in D1
00001F42  EC49                    2167      LSR.W   #6,D1                   ;shift right 6
00001F44  EC49                    2168      LSR.W   #6,D1                   ;shift another 6 to = 12 total
00001F46                          2169      
00001F46  B27C 000D               2170      CMP     #$D,D1                  ;check if opcode = 1101
00001F4A  6600 002C               2171      BNE     EA_MATH_CONTINUE        ;if not 1101, skip and go to math
00001F4E                          2172      
00001F4E                          2173      ;if we are here, we know opcode is 1101 and further check
00001F4E  2200                    2174      MOVE.L  D0,D1
00001F50  EC49                    2175      LSR.W   #6,D1
00001F52  0241 0003               2176      ANDI.W  #3,D1
00001F56  B23C 0003               2177      CMP.B   #3,D1
00001F5A  6600 001C               2178      BNE     EA_MATH_CONTINUE
00001F5E                          2179      
00001F5E                          2180      ;if d1 == 3, both conditions met so process as ADDA
00001F5E                          2181      ;destination mode is 1 (address register)
00001F5E  7801                    2182      MOVE.L  #1,D4
00001F60  C8FC 0006               2183      MULU    #6,D4
00001F64                          2184      
00001F64                          2185      ;isolate destination register 
00001F64  2A00                    2186      MOVE.L  D0,D5
00001F66  E84D                    2187      LSR.W   #4,D5
00001F68  EA4D                    2188      LSR.W   #5,D5                      
00001F6A  0245 0007               2189      ANDI.W  #$7,D5   
00001F6E                          2190   
00001F6E  4EB9 00002010           2191      JSR     EA_JMP_HELPER 
00001F74  4EF8 19A2               2192      JMP     EA_FINISH
00001F78                          2193          
00001F78                          2194  EA_MATH_CONTINUE:       
00001F78                          2195      ;destination mode is 0 (data register)
00001F78  7800                    2196      MOVE.L  #0,D4
00001F7A  C8FC 0006               2197      MULU    #6,D4
00001F7E                          2198      
00001F7E                          2199      ;isolate destination register 
00001F7E  2A00                    2200      MOVE.L  D0,D5
00001F80  E84D                    2201      LSR.W   #4,D5
00001F82  EA4D                    2202      LSR.W   #5,D5                      
00001F84  0245 0007               2203      ANDI.W  #$7,D5  
00001F88                          2204      
00001F88  4EB9 00002010           2205      JSR     EA_JMP_HELPER 
00001F8E  4EF8 19A2               2206      JMP     EA_FINISH
00001F92                          2207      
00001F92                          2208  
00001F92                          2209  EA_ROTATION:
00001F92  14FC 0009               2210      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001F96  2200                    2211      MOVE.L  D0,D1                       ;complete opcode
00001F98                          2212      
00001F98  0241 00FF               2213      ANDI.W  #$00FF,D1
00001F9C  EC49                    2214      LSR.W   #6,D1
00001F9E  B27C 0003               2215      CMP     #3,D1
00001FA2  6700 0016               2216      BEQ     EA_ROTATION_MODE_7
00001FA6                          2217      
00001FA6  2200                    2218      MOVE.L  D0,D1
00001FA8  EA49                    2219      LSR.W   #5,D1                       ;shift right 5
00001FAA  0241 0001               2220      ANDI.W  #1,D1
00001FAE                          2221      
00001FAE  B27C 0000               2222      CMP     #0,D1
00001FB2  6700 0050               2223      BEQ     EA_ROTATION_IMMEDIATE       ;it is immediate value
00001FB6  6000 0052               2224      BRA     EA_ROTATION_REGISTER        ;else register 
00001FBA                          2225      
00001FBA                          2226  EA_ROTATION_MODE_7:
00001FBA                          2227      ;WE KNOW IT IS MODE 7 - CHECK FOR IMMEDIATE SHORT OR IMMEDIATE LONG
00001FBA  2200                    2228      MOVE.L  D0,D1
00001FBC  0241 0007               2229      ANDI.W  #7,D1
00001FC0  B27C 0000               2230      CMP.W   #0,D1   
00001FC4  6700 000C               2231      BEQ     EA_111_ABSOLUTE_SHORT_HELPER
00001FC8  4EB9 000020D6           2232      JSR     EA_111_ABSOLUTE_LONG   
00001FCE  4EF8 19A2               2233      JMP     EA_FINISH
00001FD2                          2234  
00001FD2                          2235  EA_111_ABSOLUTE_SHORT_HELPER:
00001FD2  4EB9 000020C2           2236      JSR     EA_111_ABSOLUTE_SHORT
00001FD8  4EF8 19A2               2237      JMP     EA_FINISH
00001FDC                          2238  
00001FDC                          2239  EA_ROTATION_CONTINUE:
00001FDC  2200                    2240      MOVE.L  D0,D1                       ;get rotation value
00001FDE  0241 0F00               2241      ANDI.W  #nibble2,D1                 ;isolate nibble 2
00001FE2  E049                    2242      LSR.W   #8,D1
00001FE4  E249                    2243      LSR.W   #1,D1                       :total of 9 shifts right
00001FE6                          2244      
00001FE6                          2245      ;at this point we have our number, so convert to ASCII and put on buffer
00001FE6  0601 0030               2246      ADDI.B  #$30,D1                     ;convert to ASCII
00001FEA  14C1                    2247      MOVE.B  D1,(A2)+                    ;put on buffer
00001FEC                          2248      
00001FEC  14FC 002C               2249      MOVE.B  #',',(A2)+                  ;add ',' to buffer 
00001FF0  14FC 0044               2250      MOVE.B  #'D',(A2)+                  ;add 'D' to buffer
00001FF4                          2251      
00001FF4  2200                    2252      MOVE.L  D0,D1                       ;complete opcode
00001FF6  0241 0007               2253      ANDI.W  #7,D1                       
00001FFA                          2254      
00001FFA  0601 0030               2255      ADDI.B  #$30,D1                     ;convert to ASCII
00001FFE  14C1                    2256      MOVE.B  D1,(A2)+                    ;put on buffer
00002000                          2257      
00002000  4EF8 19A2               2258      JMP     EA_FINISH                   ;done
00002004                          2259  
00002004                          2260  EA_ROTATION_IMMEDIATE:
00002004  14FC 0023               2261      MOVE.B  #'#',(A2)+                  ;add '#' to buffer
00002008  60D2                    2262      BRA     EA_ROTATION_CONTINUE
0000200A                          2263      
0000200A                          2264  EA_ROTATION_REGISTER:
0000200A  14FC 0044               2265      MOVE.B  #'D',(A2)+                  ;add 'D' to buffer
0000200E  60CC                    2266      BRA     EA_ROTATION_CONTINUE
00002010                          2267      
00002010                          2268  EA_JMP_HELPER
00002010  4EF0 4000               2269      JMP     0(A0,D4)
00002014                          2270  
00002014                          2271  
00002014                          2272  ;********************************************  EA_MODE_TABLE  ****************************************************  
00002014                          2273  EA_MODE_TABLE:
00002014  4EF9 00002044           2274      JMP     EA_MODE_000
0000201A  4EF9 00002052           2275      JMP     EA_MODE_001
00002020  4EF9 00002060           2276      JMP     EA_MODE_010
00002026  4EF9 00002076           2277      JMP     EA_MODE_011
0000202C  4EF9 00002090           2278      JMP     EA_MODE_100
00002032  4EF9 000020AA           2279      JMP     EA_MODE_101
00002038  4EF9 000020AA           2280      JMP     EA_MODE_110
0000203E  4EF9 000020AA           2281      JMP     EA_MODE_111
00002044                          2282      ;JMP     EA_MODE_FINISH
00002044                          2283  
00002044                          2284  ;********************************************  EA_MODE_XXX  ****************************************************    
00002044                          2285  EA_MODE_000:                                        ;Data register 'Dn'
00002044  14FC 0044               2286      MOVE.B  #'D',(A2)+                              ;put D on buffer
00002048  1605                    2287      MOVE.B D5,D3                                    ;move to d3 for conversion
0000204A  4EB9 0000210A           2288      JSR     EA_HEX_TO_ASCII                         ;puts register on buffer  
00002050  4E75                    2289      RTS
00002052                          2290      
00002052                          2291  EA_MODE_001:                                        ;Address Register 'An'
00002052  14FC 0041               2292      MOVE.B  #'A',(A2)+                              ;put A on buffer
00002056  1605                    2293      MOVE.B  D5,D3                                   ;move to d3 for conversion
00002058  4EB9 0000210A           2294      JSR     EA_HEX_TO_ASCII                         ;puts register on buffer  
0000205E  4E75                    2295      RTS
00002060                          2296  
00002060                          2297  EA_MODE_010:                                        ;Address direct --> '(An)'
00002060  14FC 0028               2298      MOVE.B  #'(',(A2)+                              ;put ( on buffer
00002064  14FC 0041               2299      MOVE.B  #'A',(A2)+                              ;put A on buffer
00002068  1605                    2300      MOVE.B  D5,D3                                   ;move to D3 for conversion
0000206A  4EB9 0000210A           2301      JSR     EA_HEX_TO_ASCII                         ;convert and put on buffer   
00002070  14FC 0029               2302      MOVE.B  #')',(A2)+                              ;put ) on buffer
00002074  4E75                    2303      RTS
00002076                          2304  
00002076                          2305  EA_MODE_011:                                        ;Address with Postincrement --> '(An)+' 
00002076  14FC 0028               2306      MOVE.B  #'(',(A2)+                              ;put ( on buffer
0000207A  14FC 0041               2307      MOVE.B  #'A',(A2)+                              ;put A on buffer
0000207E  1605                    2308      MOVE.B  D5,D3                                   ;move to D3 for conversion
00002080  4EB9 0000210A           2309      JSR     EA_HEX_TO_ASCII                         ;convert and put on buffer   
00002086  14FC 0029               2310      MOVE.B  #')',(A2)+                              ;put ) on buffer
0000208A  14FC 002B               2311      MOVE.B  #'+',(A2)+                              ;put + on buffer
0000208E  4E75                    2312      RTS
00002090                          2313  
00002090                          2314  EA_MODE_100:                                        ;Address with Predecrement --> '-(An)'
00002090  14FC 002D               2315      MOVE.B  #'-',(A2)+                              ;put - on buffer
00002094  14FC 0028               2316      MOVE.B  #'(',(A2)+                              ;put ( on buffer
00002098  14FC 0041               2317      MOVE.B  #'A',(A2)+                              ;put A on buffer
0000209C  1605                    2318      MOVE.B  D5,D3                                   ;move to D3 for conversion
0000209E  4EB9 0000210A           2319      JSR     EA_HEX_TO_ASCII                         ;convert and put on buffer   
000020A4  14FC 0029               2320      MOVE.B  #')',(A2)+                              ;put ) on buffer
000020A8  4E75                    2321      RTS
000020AA                          2322  
000020AA                          2323  
000020AA                          2324  ;unsupported
000020AA                          2325  EA_MODE_101:                                        
000020AA                          2326  ;Address with Displacement --> '(d16, An)
000020AA                          2327      
000020AA                          2328  ;unsupported
000020AA                          2329  EA_MODE_110:
000020AA                          2330  
000020AA                          2331  
000020AA                          2332  
000020AA                          2333  ;some form of immediate data: short, long, immediate
000020AA                          2334  EA_MODE_111:
000020AA                          2335      ;D4 = MODE | D5 = register (000, 001, 100)
000020AA                          2336      ;000 = Absolute Short (xxx).w
000020AA                          2337      ;001 = Absolute Long (xxx).l
000020AA                          2338      ;100 = Immediate data
000020AA                          2339      
000020AA  BA3C 0000               2340      CMP.B   #000,D5
000020AE  6700 0012               2341      BEQ     EA_111_ABSOLUTE_SHORT
000020B2  BA3C 0001               2342      CMP.B   #001,D5
000020B6  6700 001E               2343      BEQ     EA_111_ABSOLUTE_LONG
000020BA  BA3C 0004               2344      CMP.B   #$4,D5
000020BE  6700 002A               2345      BEQ     EA_111_IMMEDIATE
000020C2                          2346      
000020C2                          2347      ;HANDLE ERROR
000020C2                          2348              
000020C2                          2349      
000020C2                          2350  EA_111_ABSOLUTE_SHORT:
000020C2                          2351      ;A5 is looking at correct spot
000020C2                          2352      ;ADD WORD VALUE AT A5 ON TO BUFFER AT A2 AND INCREMENT BY WORD
000020C2  14FC 0024               2353      MOVE.B  #'$',(A2)+                              ;put $ on buffer
000020C6  3E15                    2354      MOVE.W  (A5),D7
000020C8  4246                    2355      CLR     D6
000020CA  1C3C 0001               2356      MOVE.B  #01,D6                                  ;word size in EA_ITOA_IMMEDIATE
000020CE  4EB9 0000213C           2357      JSR     EA_ITOA_IMMEDIATE
000020D4  4E75                    2358      RTS
000020D6                          2359  
000020D6                          2360  EA_111_ABSOLUTE_LONG:
000020D6  14FC 0024               2361      MOVE.B  #'$',(A2)+                              ;put $ on buffer
000020DA  3E15                    2362      MOVE.W  (A5),D7
000020DC  4246                    2363      CLR     D6
000020DE  1C3C 0002               2364      MOVE.B  #02,D6                                  ;long size in EA_ITOA_IMMEDIATE        
000020E2  4EB9 0000213C           2365      JSR     EA_ITOA_IMMEDIATE
000020E8  4E75                    2366      RTS
000020EA                          2367  
000020EA                          2368  EA_111_IMMEDIATE:
000020EA  14FC 0023               2369      MOVE.B  #'#',(A2)+                              ;put $ on buffer
000020EE  14FC 0024               2370      MOVE.B  #'$',(A2)+                              ;put $ on buffer
000020F2                          2371      
000020F2  2200                    2372      MOVE.L  D0,D1
000020F4  0241 F000               2373      ANDI.W  #$F000,D1
000020F8  EC49                    2374      LSR.W   #6,D1
000020FA  EC49                    2375      LSR.W   #6,D1                           ;total of 12 times
000020FC                          2376      
000020FC                          2377      
000020FC                          2378      ;check size and branch accordingly
000020FC  3C01                    2379      MOVE.W  D1,D6
000020FE  3E15                    2380      MOVE.W  (A5),D7
00002100  4EB9 0000213C           2381      JSR EA_ITOA_IMMEDIATE
00002106                          2382      
00002106  4EF8 19A2               2383      JMP EA_FINISH
0000210A                          2384     
0000210A                          2385      
0000210A                          2386  
0000210A                          2387  EA_HEX_TO_ASCII:
0000210A  0603 0030               2388      ADDI.B      #$30,D3                     ;add $30 to D1 to convert
0000210E  14C3                    2389      MOVE.B      D3,(A2)+                    ;add to buffer and increment to next position
00002110  4E75                    2390      RTS     
00002112                          2391  
00002112                          2392  
00002112                          2393  EA_CHECK_SIZE:
00002112  4246                    2394      CLR     D6
00002114  2C00                    2395      MOVE.L  D0,D6                           ;complete opcode --> D6
00002116  0246 00F0               2396      ANDI.W  #nibble3,D6                     ;isolating nibble 3
0000211A  EC4E                    2397      LSR.W   #right6,D6                      ;shifting bits 7,6 --> 1,0
0000211C                          2398      
0000211C  BC7C 0000               2399      CMP     #00,D6
00002120  6700 000E               2400      BEQ     EA_SIZE_BYTE
00002124  BC7C 0001               2401      CMP     #01,D6
00002128  6700 000A               2402      BEQ     EA_SIZE_WORD
0000212C  6000 000A               2403      BRA     EA_SIZE_LONG
00002130                          2404  
00002130                          2405  EA_SIZE_BYTE:
00002130  3E1D                    2406      MOVE.W  (A5)+,D7
00002132                          2407      ;MOVE.B  #4,D3;                          SET UP COUNTER
00002132  4E75                    2408      RTS
00002134                          2409  
00002134                          2410  EA_SIZE_WORD:
00002134  3E15                    2411      MOVE.W  (A5),D7
00002136                          2412      ;MOVE.B  #4,D3;                          SET UP COUNTER
00002136  4E75                    2413      RTS
00002138                          2414  
00002138                          2415  EA_SIZE_LONG:
00002138  3E15                    2416      MOVE.W  (A5),D7
0000213A                          2417      ;MOVE.B  #8,D3;                          SET UP COUNTER
0000213A  4E75                    2418      RTS
0000213C                          2419  
0000213C                          2420  
0000213C                          2421  
0000213C                          2422  EA_ITOA_IMMEDIATE:
0000213C                          2423      ;D3 = counter, D7 = value to be converted, D6 = size
0000213C  BC3C 0000               2424      CMP.B   #%00,D6
00002140  6700 0012               2425      BEQ     EA_ITOA_BYTE
00002144  BC3C 0001               2426      CMP.B   #%01,D6
00002148  6700 0016               2427      BEQ     EA_ITOA_WORD
0000214C  BC3C 0002               2428      CMP.B   #%10,D6     
00002150  6700 0024               2429      BEQ     EA_ITOA_LONG
00002154                          2430      
00002154                          2431  
00002154                          2432  ;EA_IT0A_IMMEDIATE_LOOP
00002154                          2433  ;    CMP.B   #0,D3                       ;check if loop done
00002154                          2434  ;    BEQ     EA_ITOA_FINISH              ;if = 0, loop done
00002154                          2435      
00002154                          2436  EA_ITOA_BYTE:
00002154  4EB9 0000219E           2437      JSR     EA_ITOA_BYTE_CONVERT
0000215A                          2438      
0000215A  4EF9 000021D6           2439      JMP     EA_ITOA_DONE
00002160                          2440  
00002160                          2441  
00002160                          2442  EA_ITOA_WORD:
00002160  E04F                    2443      LSR.W   #right8,D7
00002162  4EB9 0000219E           2444      JSR     EA_ITOA_BYTE_CONVERT
00002168  3E1D                    2445      MOVE.W  (A5)+,D7
0000216A  4EB9 0000219E           2446      JSR     EA_ITOA_BYTE_CONVERT
00002170                          2447      
00002170  4EF9 000021D6           2448      JMP     EA_ITOA_DONE
00002176                          2449      
00002176                          2450  EA_ITOA_LONG:
00002176  E04F                    2451      LSR.W   #right8,D7
00002178  4EB9 0000219E           2452      JSR     EA_ITOA_BYTE_CONVERT
0000217E  3E1D                    2453      MOVE.W  (A5)+,D7
00002180  4EB9 0000219E           2454      JSR     EA_ITOA_BYTE_CONVERT
00002186                          2455  
00002186  3E15                    2456      MOVE.W  (A5),D7
00002188  E04F                    2457      LSR.W   #right8,D7
0000218A  4EB9 0000219E           2458      JSR     EA_ITOA_BYTE_CONVERT
00002190  3E1D                    2459      MOVE.W  (A5)+,D7
00002192  4EB9 0000219E           2460      JSR     EA_ITOA_BYTE_CONVERT
00002198                          2461  
00002198  4EF9 000021D6           2462      JMP     EA_ITOA_DONE
0000219E                          2463  
0000219E                          2464  EA_ITOA_BYTE_CONVERT:
0000219E  3607                    2465      MOVE.W  D7,D3
000021A0  0243 00F0               2466      ANDI.W  #$F0,D3
000021A4  E84B                    2467      LSR.W   #right4,D3
000021A6  4EB9 000021BA           2468      JSR     EA_ITOA_NIBBLE_CONVERT
000021AC                          2469      
000021AC  3607                    2470      MOVE.W  D7,D3
000021AE  0243 000F               2471      ANDI.W  #$0F,D3
000021B2  4EB9 000021BA           2472      JSR     EA_ITOA_NIBBLE_CONVERT
000021B8  4E75                    2473      RTS
000021BA                          2474  
000021BA                          2475  EA_ITOA_NIBBLE_CONVERT:
000021BA  B63C 0009               2476      CMP.B   #9,D3
000021BE  6E00 000E               2477      BGT     EA_ITOA_LETTER
000021C2  6000 0002               2478      BRA     EA_ITOA_NUMBER
000021C6                          2479  
000021C6                          2480  EA_ITOA_HEX2ASCII:
000021C6                          2481  
000021C6                          2482  
000021C6                          2483  
000021C6                          2484  EA_ITOA_NUMBER:
000021C6  0603 0030               2485      ADDI.B  #$30,D3
000021CA  14C3                    2486      MOVE.B  D3,(A2)+
000021CC  4E75                    2487      RTS
000021CE                          2488  
000021CE                          2489  EA_ITOA_LETTER:
000021CE  0603 0037               2490      ADDI.B  #$37,D3
000021D2  14C3                    2491      MOVE.B  D3,(A2)+
000021D4  4E75                    2492      RTS
000021D6                          2493  
000021D6                          2494  EA_ITOA_DONE
000021D6  4E75                    2495      RTS
000021D8                          2496  
000021D8                          2497      
000021D8                          2498  ;****************************************** MESSAGES ***************************************************
000021D8= 57 65 6C 63 6F 6D ...   2499  welcome_message         DC.B    'Welcome to 68k disassembler',CR,LF,0
000021F6                          2500  
000021F6= 50 6C 65 61 73 65 ...   2501  get_start_address       DC.B    'Please enter a starting address in hexadecimal',CR,LF,0
00002227                          2502  
00002227= 50 6C 65 61 73 65 ...   2503  get_end_address         DC.B    'Please enter an ending address in hexadecimal',CR,LF,0
00002257                          2504  
00002257= 49 6E 76 61 6C 69 ...   2505  atoi_error_invalid      DC.B    'Invalid address, characters must be $0-F',CR,LF,0
00002282                          2506  
00002282= 49 6E 76 61 6C 69 ...   2507  error_message_1         DC.B    'Invalid Address: Must be greater than 0',CR,LF,0
000022AC                          2508  
000022AC= 49 6E 76 61 6C 69 ...   2509  error_message_2         DC.B    'Invalid Address: Must be even',CR,LF,0
000022CC                          2510  
000022CC= 49 6E 76 61 6C 69 ...   2511  error_message_3         DC.B    'Invalid Address: Must be even',CR,LF,0
000022EC                          2512  
000022EC= 49 6E 76 61 6C 69 ...   2513  error_message_4         DC.B    'Invalid Address: Must be less than $00FFFFFF',CR,LF,0
0000231B                          2514  
0000231B= 49 6E 76 61 6C 69 ...   2515  error_message_5         DC.B    'Invalid Address: Must be greater than starting address',CR,LF,0
00002354                          2516  
00002354= 48 69 74 20 45 6E ...   2517  prompt_enter            DC.B    'Hit Enter to Continue',CR,LF,0
0000236C                          2518  
0000236C= 44 6F 20 59 6F 75 ...   2519  prompt_again            DC.B    'Do You Want to Run Program Again with New Memory Locations? Enter Y or N ',CR,LF,0
000023B8                          2520                                  
000023B8                          2521  
000023B8                          2522  ascii_start:
000023B8                          2523      DS.w    10          ;specify size later?
000023CC                          2524      
000023CC                          2525  ascii_end:
000023CC                          2526      DS.w    10          ;specify size later?
000023E0                          2527  
000023E0                          2528  buffer                  ;storing op code
000023E0                          2529      DS.W    64          ;do we leave as .w or change to .l ?
00002460                          2530      
00002460                          2531  ascii_y_or_n:
00002460                          2532      DS.W    8
00002470                          2533      
00002470                          2534  
00002470                          2535      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_END           23CC
ASCII_START         23B8
ASCII_Y_OR_N        2460
ATOI                182A
ATOI_DONE           189C
ATOI_ERROR          189C
ATOI_ERROR_INVALID  2257
ATOI_FORMAT         188C
ATOI_LOOP           1830
ATOI_LOWERCASE_LETTER  1882
ATOI_NUMBER         186E
ATOI_UPPERCASE_LETTER  1878
BRANCH_16_ITOA      1EFC
BUFFER              23E0
BUFFER_SIZE         40
CR                  D
DECODING_LOOP       108A
DEST_MODE           1C0
DEST_REG            E00
DONE                110E
EA_111_ABSOLUTE_LONG  20D6
EA_111_ABSOLUTE_SHORT  20C2
EA_111_ABSOLUTE_SHORT_HELPER  1FD2
EA_111_IMMEDIATE    20EA
EA_BRANCH           1E52
EA_BRANCH_16        1EE4
EA_BRANCH_32        1EFC
EA_BRANCH_8_BIT_DISPLACEMENT  1E72
EA_BRANCH_ITOA_HELPER  1EB2
EA_BRANCH_NEGATIVE  1E98
EA_BRANCH_POSITIVE  1E80
EA_CHECK_SIZE       2112
EA_DESTONLY         1AB2
EA_EXT              1AB2
EA_FINISH           19A2
EA_HEX_TO_ASCII     210A
EA_IMMEDIATE        19A4
EA_ITOA_BYTE        2154
EA_ITOA_BYTE_CONVERT  219E
EA_ITOA_DONE        21D6
EA_ITOA_HEX2ASCII   21C6
EA_ITOA_IMMEDIATE   213C
EA_ITOA_LETTER      21CE
EA_ITOA_LONG        2176
EA_ITOA_NIBBLE_CONVERT  21BA
EA_ITOA_NUMBER      21C6
EA_ITOA_WORD        2160
EA_JMP_HELPER       2010
EA_LEA              1A72
EA_MATH             1F1A
EA_MATH_CONTINUE    1F78
EA_MODE_000         2044
EA_MODE_001         2052
EA_MODE_010         2060
EA_MODE_011         2076
EA_MODE_100         2090
EA_MODE_101         20AA
EA_MODE_110         20AA
EA_MODE_111         20AA
EA_MODE_TABLE       2014
EA_MOVE             19E6
EA_MOVEA            1A2C
EA_MOVEM            1AB2
EA_MOVEM_ADDRREG_TO_MEM  1C16
EA_MOVEM_DATAREG_TO_MEM  1B8E
EA_MOVEM_IMMEDIATE_DESTINATION  1DA2
EA_MOVEM_IMMEDIATE_SOURCE  1DB2
EA_MOVEM_MEM_TO_ADDRREG  1D44
EA_MOVEM_MEM_TO_DATAREG  1D16
EA_MOVEM_MEM_TO_REG  1C68
EA_MOVEM_REG_TO_MEM  1ADC
EA_QUICK            1DD6
EA_QUICK_MOVEQ      1E28
EA_ROTATION         1F92
EA_ROTATION_CONTINUE  1FDC
EA_ROTATION_IMMEDIATE  2004
EA_ROTATION_MODE_7  1FBA
EA_ROTATION_REGISTER  200A
EA_SIZE_BYTE        2130
EA_SIZE_LONG        2138
EA_SIZE_WORD        2134
EA_START            1946
EA_TRAP             1DD6
EA_TYPE_BRANCH      9
EA_TYPE_DESTONLY    4
EA_TYPE_EXT         5
EA_TYPE_IMMEDIATE   0
EA_TYPE_LEA         3
EA_TYPE_MATH        A
EA_TYPE_MOVE        1
EA_TYPE_MOVEA       2
EA_TYPE_MOVEA6      C
EA_TYPE_MOVEM       6
EA_TYPE_QUICK       8
EA_TYPE_ROTATION    B
EA_TYPE_TABLE       1954
EA_TYPE_TRAP        7
ENDA_ERROR_LARGE    1926
ENDA_ERROR_LESS_THAN_STARTA  1936
ENDA_ERROR_NOT_EVEN  1916
ERROR_MESSAGE_1     2282
ERROR_MESSAGE_2     22AC
ERROR_MESSAGE_3     22CC
ERROR_MESSAGE_4     22EC
ERROR_MESSAGE_5     231B
FILLED_SCREEN       10F8
GET_ENDING_ADDRESS  104A
GET_END_ADDRESS     2227
GET_STARTING_ADDRESS  1012
GET_START_ADDRESS   21F6
ITOA                18A0
ITOA_ADDRESS        18AA
ITOA_ADDRESS_LOOP   18B8
ITOA_BYTE           18AA
ITOA_FINISH         18F4
ITOA_HEX2ASCII      18D4
ITOA_LETTER         18EC
ITOA_LONG           18AA
ITOA_LOOP           18A2
ITOA_NUMBER         18E4
ITOA_WORD           18AA
LF                  A
LINES_PER_SCREEN    F
MOVEM_CARRY         1D84
MOVEM_CHECK_MULTIPLE  1BE8
MOVEM_LOOP          1D74
MOVEM_MULTIPLE      1BF0
MOVEM_MULTIPLE_A    1C0E
MOVEM_MULTIPLE_D    1C06
MOVEM_SET_MIN       1D94
NIBBLE1             F000
NIBBLE2             F00
NIBBLE3             F0
NIBBLE4             F
OPCODE0000          11C4
OPCODE0001          11DE
OPCODE0010          11E4
OPCODE0011          11FE
OPCODE0100          1218
OPCODE0101          1232
OPCODE0110          124E
OPCODE0111          1268
OPCODE1000          126E
OPCODE1001          128A
OPCODE1010          1290
OPCODE1011          1296
OPCODE1100          129C
OPCODE1101          12B8
OPCODE1110          12D4
OPCODE1111          12F4
OP_0000_TABLE       12FA
OP_0100_TABLE       135A
OP_0110_TABLE       13BA
OP_ADD              172C
OP_ADDA             174A
OP_ADDI             147C
OP_ADDQ             15EC
OP_AND              172C
OP_ANDI             1438
OP_ASL              176C
OP_ASR              178A
OP_BEQ              1660
OP_BRA              1630
OP_BSR              1648
OP_CHECK_SIZE       17A8
OP_CHECK_SIZE_ADDA  180E
OP_CHECK_SIZE_MOVEM  17CC
OP_CLR              15EC
OP_CMP              16D6
OP_CMPI             14C0
OP_DATA_CLR         114E
OP_DATA_CLR_LOOP    115A
OP_DIVS             169C
OP_DIVU             1680
OP_EOR              16F4
OP_EORI             149E
OP_EXT              15EC
OP_FINISH           1148
OP_JMP              15EC
OP_JSR              15EC
OP_LEA              15D4
OP_LSL              17A8
OP_LSR              17A8
OP_MOVEAL           1506
OP_MOVEAW           1552
OP_MOVEB            14E2
OP_MOVEL            152E
OP_MOVEM            15AE
OP_MOVEQ            1660
OP_MOVEW            157A
OP_MULS             1710
OP_MULU             16F4
OP_NOP              159E
OP_NOT              15EC
OP_OR               16B8
OP_ORI              141A
OP_ROL              17A8
OP_ROR              17A8
OP_RTE              15EC
OP_RTS              15EC
OP_SIZE_BYTE        17F0
OP_SIZE_LONG        1804
OP_SIZE_WORD        17FA
OP_START            1112
OP_STOP             15EC
OP_SUB              16B8
OP_SUBI             145A
OP_SUBQ             160E
OP_TABLE            1164
OP_TRAP             15EC
OP_UNSUPPORTED_OPCODE  17A8
PROMPT_AGAIN        236C
PROMPT_ENTER        2354
REPEAT_OR_FINISH    10B6
RIGHT1              1
RIGHT10             A
RIGHT12             C
RIGHT16             10
RIGHT2              2
RIGHT24             18
RIGHT3              3
RIGHT4              4
RIGHT5              5
RIGHT6              6
RIGHT7              7
RIGHT8              8
RIGHT9              9
STACK               A0000
START               1000
STARTA_ERROR_LESS_THAN_ZERO  18F6
STARTA_ERROR_NOT_EVEN  1906
START_DECODING      1088
VALIDATE_BEGINNING  18F6
WELCOME             1006
WELCOME_MESSAGE     21D8
