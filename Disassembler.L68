00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/9/2021 12:24:14 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler V1.8(ish)
00000000                             3  * Written by : Brent and Parker
00000000                             4  * Date       : 3/4/21
00000000                             5  * Description: Final Project for CSS 422
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  ;************************ Define Constants ********************************* 
00000000  =0000000D                  9  CR                  EQU     $0D     ;carriage return
00000000  =0000000A                 10  LF                  EQU     $0a     ;line feed
00000000  =000A0000                 11  stack               EQU     $000A0000
00000000  =0000001E                 12  lines_per_screen    EQU     30
00000000  =00000040                 13  buffer_size         EQU     64      ;size of buffer
00000000  =0000F000                 14  nibble1             EQU     $F000   ;1st nibble in code (bits 15-12)
00000000  =00000F00                 15  nibble2             EQU     $0F00   ;2nd nibble in code (bits 11-8)
00000000  =000000F0                 16  nibble3             EQU     $00F0   ;3rd nibble in code (bits 7-4)
00000000  =0000000F                 17  nibble4             EQU     $000F   ;4th nibble in code (bits 3-0)
00000000  =00000001                 18  right1              EQU     1       ;shift 1 time
00000000  =00000002                 19  right2              EQU     2       ;shift 2 times
00000000  =00000003                 20  right3              EQU     3       ;shift 3 times to extract src mode
00000000  =00000004                 21  right4              EQU     4       ;shift 4 times to extract 3rd nibble
00000000  =00000005                 22  right5              EQU     5       ;shift 5 times (unused)
00000000  =00000006                 23  right6              EQU     6       ;shift 6 times to extract dst mode
00000000  =00000007                 24  right7              EQU     7       ;shift 7 times
00000000  =00000008                 25  right8              EQU     8       ;shift 8 to extract 2nd nibble
00000000  =00000009                 26  right9              EQU     9       ;shift 9 times to check 2nd nibble?
00000000  =0000000A                 27  right10             EQU     10      ;shift 10
00000000  =0000000C                 28  right12             EQU     12      ;shift 12 to extract 3rd byte
00000000  =00000010                 29  right16             EQU     16      ;shift 16 to extract 2nd byte
00000000  =00000018                 30  right24             EQU     24      ;shift 24 to extract 1st byte
00000000  =000001C0                 31  dest_mode           EQU     $01C0   ; --> 0000 0001 1100 0000 (used for destination in MOVE/MOVEA
00000000  =00000E00                 32  dest_reg            EQU     $0E00   ;destination register (0000 0111 0000 0000)
00000000                            33  
00000000  =00000000                 34  ea_type_immediate   EQU     0
00000000  =00000001                 35  ea_type_move        EQU     1
00000000  =00000002                 36  ea_type_movea       EQU     2
00000000  =0000000C                 37  ea_type_movea6      EQU     12
00000000  =00000003                 38  ea_type_lea         EQU     3
00000000  =00000004                 39  ea_type_destonly    EQU     4
00000000  =00000005                 40  ea_type_ext         EQU     5
00000000  =00000006                 41  ea_type_movem       EQU     6
00000000  =00000007                 42  ea_type_trap        EQU     7
00000000  =00000008                 43  ea_type_quick       EQU     8
00000000  =00000009                 44  ea_type_branch      EQU     9
00000000  =0000000A                 45  ea_type_math        EQU     10
00000000  =0000000B                 46  ea_type_rotation    EQU     11
00000000                            47  
00000000                            48  
00000000                            49  ;flags???
00000000                            50  
00000000                            51  
00000000                            52  
00001000                            53      ORG    $1000
00001000                            54  START:                              ;first instruction of program
00001000  4FF9 000A0000             55      LEA     stack, SP               ;SP @ $A0000
00001006                            56  
00001006                            57  
00001006                            58  
00001006                            59  ;********************************** Welcome Message ******************************************** 
00001006                            60  WELCOME:
00001006  43F9 00001D5E             61      LEA     welcome_message,A1      ;load the welcome message into A1
0000100C  103C 000E                 62      MOVE.B  #14,D0
00001010  4E4F                      63      TRAP    #15                     ;print contents of welcome_message
00001012                            64  
00001012                            65  
00001012                            66  ;*********************************** Get Starting Address *************************************** 
00001012                            67  GET_STARTING_ADDRESS:
00001012                            68      ;prompt for address
00001012  103C 000E                 69      MOVE.B  #14,D0    
00001016  43F9 00001D7C             70      LEA     get_start_address,A1    ;load the get_start_address message into A1
0000101C  4E4F                      71      TRAP    #15                     ;print get_start_address
0000101E                            72      
0000101E                            73      ;get user input address, store, and convert
0000101E  43F9 00001EDA             74      LEA     ascii_start,A1          ;store
00001024  103C 0002                 75      MOVE.B  #2,D0                   ;get user input    
00001028  4E4F                      76      TRAP    #15                     ;another trap to get input
0000102A  4EB9 00001782             77      JSR     ATOI                    ;address is now in hex format in memory location
00001030                            78      
00001030                            79      
00001030                            80      ;at this point our address is in D4 in hex
00001030                            81      ;check if > 0
00001030  B8BC 00000000             82      CMP.L   #0,D4                       ;compare to D4
00001036  6F00 0816                 83      BLE     STARTA_ERROR_LESS_THAN_ZERO ;branch to ERROR_LESS_THAN_ZERO if less than 0
0000103A                            84      
0000103A                            85      ;?? MOVE.L  (A1),D3
0000103A                            86      
0000103A                            87      ;address is > 0 so check if even / odd
0000103A  E29C                      88      ROR.L   #1,D4
0000103C  6500 0820                 89      BCS     STARTA_ERROR_NOT_EVEN
00001040  E39C                      90      ROL.L   #1,D4    
00001042                            91      
00001042                            92      ;address is > 0 and verified even
00001042  2A39 00001EDA             93      MOVE.l    (ascii_start),D5      ;load into A5
00001048  2A45                      94      MOVE.l    D5,A5                ;load into A5
0000104A                            95  
0000104A                            96  
0000104A                            97  ;******************************** Get Ending Address ******************************************** 
0000104A                            98  GET_ENDING_ADDRESS:
0000104A                            99      ;prompt for address 
0000104A  103C 000E                100      MOVE.B  #14,D0
0000104E  43F9 00001DAD            101      LEA     get_end_address,A1      ;load the get_end_address message into A1  
00001054  4E4F                     102      TRAP    #15                     ;print get_end_address
00001056                           103      
00001056                           104      ;get user input address, store, and convert
00001056  43F9 00001EEE            105      LEA     ascii_end,A1            ;store 
0000105C  103C 0002                106      MOVE.B  #2,D0                   ;get user input
00001060  4E4F                     107      TRAP    #15                     ;another trap to get intput
00001062  4EB9 00001782            108      JSR ATOI
00001068                           109  
00001068                           110      ;perform checks:
00001068                           111      ;1.) even
00001068  E29C                     112      ROR.L   #1,D4
0000106A  6500 0802                113      BCS     ENDA_ERROR_NOT_EVEN
0000106E  E39C                     114      ROL.L   #1,D4    
00001070                           115      
00001070                           116      ;2.) less than 00FFFFFF
00001070  B8BC 00FFFFFF            117      CMP.L   #$00FFFFFF,D4
00001076  6C00 0806                118      BGE     ENDA_ERROR_LARGE    
0000107A                           119      
0000107A                           120      ;3.) greater than starting address
0000107A  BBC4                     121      CMP.L   D4,A5
0000107C  6C00 0810                122      BGE     ENDA_ERROR_LESS_THAN_STARTA
00001080                           123      
00001080                           124      ;good --> store in A6
00001080  2C39 00001EEE            125      MOVE.l    (ascii_end),D6      ;load into D6
00001086  2C46                     126      MOVE.l    D6,A6               ;load into A6
00001088                           127  
00001088                           128  
00001088                           129  ;************************************ Main Loop???? ***********************************************
00001088                           130  ;get pointer to first given address
00001088                           131  ;pull hex code from that address and store in A1?
00001088                           132  ;take hex code and go to OP_TABLE
00001088                           133  
00001088                           134  
00001088                           135  ;A5 = starting address
00001088                           136  ;A6 = ending address
00001088                           137  START_DECODING:
00001088                           138      ;CLR.L   D2                             ;clear screen line counter
00001088                           139  
00001088                           140  DECODING_LOOP:
00001088  4EB9 00001092            141      JSR     OP_START                       ;get complete line of instruction to decode   
0000108E                           142      
0000108E                           143  
0000108E                           144      ;print tot screen
0000108E                           145      
0000108E                           146      ;check if finished or if screen is filled
0000108E                           147      ;handle checks
0000108E                           148     
0000108E                           149      
0000108E                           150  DONE:
0000108E  FFFF FFFF                151      SIMHALT                                 ; halt simulator
00001092                           152  
00001092                           153  
00001092                           154  
00001092                           155  ;************************************ OP Stuff *************************************************************************************************************************** 
00001092                           156  
00001092                           157  ;A0 = POINTER TO OP_TABLE???
00001092                           158  ;A1 = 
00001092                           159  ;A2 = buffer (this is our decoded string that will print to screen)
00001092                           160  ;A3 = 
00001092                           161  ;A4 = current memory address for buffer (used for clearing????)
00001092                           162  ;A5 = starting address / current address in memory
00001092                           163  ;A6 = ending address
00001092                           164  ;A7 = SP
00001092                           165  
00001092                           166  ;D0
00001092                           167  ;D1
00001092                           168  ;D2 = ?
00001092                           169  ;D3 = buffer size (used for loop = 64)
00001092                           170  ;D4 = 
00001092                           171  ;D5
00001092                           172  ;D6
00001092                           173  ;D7
00001092                           174  
00001092                           175  OP_START
00001092                           176      ;get complete line? 
00001092                           177      ;everything happens in here
00001092                           178      
00001092                           179      ;MOVEM.L         D2/A6, -(SP)
00001092                           180  
00001092  4EB9 000010CA            181      JSR         OP_DATA_CLR         ;clear buffer
00001098  45F9 00001F02            182      LEA         buffer, A2          ;A2 now points to buffer, which is cleared
0000109E                           183      
0000109E                           184  
0000109E                           185      ;print out current mem address by putting into buffer and then adding a ' ' (tab)
0000109E  7403                     186      MOVE.L      #$0003,D2           ;? BINARY --> 0011 ?
000010A0  4EB9 00001802            187      JSR         ITOA_ADDRESS        ;convert A5 (current address) to ASCII and put in buffer
000010A6  14FC 0009                188      MOVE.B      #$09, (A2)+         ;adds a ' ' to buffer
000010AA                           189      
000010AA                           190      ;at this point buffer has the memory address and a space, ready for op code                     !!TESTED UP UNTIL THIS POINT AND GOOD!!
000010AA                           191      
000010AA  41F9 000010E0            192      LEA         OP_TABLE, A0
000010B0  4280                     193      CLR.L       D0
000010B2  301D                     194      MOVE.W      (A5)+,D0            ;moves opcode from current address into D0
000010B4  2200                     195      MOVE.L      D0,D1               ;should move into D1
000010B6  143C 000C                196      MOVE.B      #right12,D2         ;move immediate value 12 into D2
000010BA  E469                     197      LSR.W       D2,D1               ;shift D1 by 12 bits, leaving just 4 bits (this is our opcode???)
000010BC  C2FC 0006                198      MULU        #6,D1               ;computes opcode table jump displacement
000010C0  4EF0 1000                199      JMP         0(A0,D1)            ;jumps to opcode table entry (A0 = OP_TABLE)
000010C4                           200  
000010C4                           201  OP_FINISH:
000010C4  4CDF 4004                202      MOVEM.L     (SP)+, D2/A6
000010C8  4E75                     203      RTS                             ;returns to DECODING_LOOP !?!?!?!?!?
000010CA                           204  
000010CA                           205  
000010CA                           206  OP_DATA_CLR:
000010CA  4283                     207      CLR.L       D3                  ; ? What is D3????
000010CC                           208      ;MOVE.B      #buffer_size,D3     ; put 64 into D3
000010CC  163C 000A                209      MOVE.B      #10,D3     ; put 10 into D3                                                                 ;delete after testing and use 64
000010D0  49F9 00001F02            210      LEA         buffer, A4          ; what address register?
000010D6                           211  
000010D6                           212  OP_DATA_CLR_LOOP:
000010D6  18FC 0000                213      MOVE.B      #0, (A4)+
000010DA  5343                     214      SUBI        #1, D3
000010DC  6EF8                     215      BGT         OP_DATA_CLR_LOOP
000010DE  4E75                     216      RTS                                 ;need RTS to return
000010E0                           217  
000010E0                           218  
000010E0                           219  ;********************************* jump table ****************************************
000010E0                           220  OP_TABLE:
000010E0  4EF9 00001140            221      JMP         opcode0000              ;ORI (ANDI, SUBI, ADDI, EORI, CMPI)                                 $0
000010E6  4EF9 0000115A            222      JMP         opcode0001              ;MOVE.B                                                             $1    
000010EC  4EF9 00001160            223      JMP         opcode0010              ;MOVEA.L, MOVE.L                                                    $2
000010F2  4EF9 0000117A            224      JMP         opcode0011              ;MOVEA.W MOVE.W                                                     $3
000010F8  4EF9 00001194            225      JMP         opcode0100              ;NOP, MOVEM, LEA (CLR, NOT, EXT, TRAP, STOP, RTE, RTS, JSR, JMP     $4
000010FE  4EF9 000011AE            226      JMP         opcode0101              ;ADDQ (SUBQ)                                                        $5
00001104  4EF9 000011CA            227      JMP         opcode0110              ;BRA.bw, BSR.bw (BEQ)                                               $6
0000110A  4EF9 000011E4            228      JMP         opcode0111              ;MOVEQ.l                                                            $7
00001110  4EF9 000011EA            229      JMP         opcode1000              ;DIVU (DIVS, OR)                                                    $8
00001116  4EF9 00001206            230      JMP         opcode1001              ;SUB                                                                $9
0000111C  4EF9 0000120C            231      JMP         opcode1010              ;not assigned                                                       $A
00001122  4EF9 00001212            232      JMP         opcode1011              ;CMP (EOR)                                                          $B
00001128  4EF9 00001218            233      JMP         opcode1100              ;MULU (MULS, AND)                                                   $C
0000112E  4EF9 00001234            234      JMP         opcode1101              ;ADD, ADDA                                                          $D
00001134  4EF9 00001250            235      JMP         opcode1110              ;ASL, ASR (LSL, LSR, ROL, ROR)                                      $E
0000113A  4EF9 00001270            236      JMP         opcode1111              ;not assigned                                                       $F
00001140                           237  
00001140                           238  
00001140                           239  
00001140                           240  
00001140                           241  ;A0 = POINTER TO OP_TABLE???
00001140                           242  ;A1 = 
00001140                           243  ;A2 = buffer (this is our decoded string that will print to screen)
00001140                           244  ;A3 = pointer to op_xxx_table
00001140                           245  ;A4 = current memory address for buffer (used for clearing????)
00001140                           246  ;A5 = starting address / current address in memory
00001140                           247  ;A6 = ending address
00001140                           248  ;A7 = SP
00001140                           249  
00001140                           250  ;D0 = full instruction
00001140                           251  ;D1 = full instruction for manipulating (temporary)
00001140                           252  ;D2 = will store immediate value for comparing
00001140                           253  ;D3 = buffer size (used for loop = 64)
00001140                           254  ;D4 = 
00001140                           255  ;D5 = 
00001140                           256  ;D6 = 
00001140                           257  ;D7 = 
00001140                           258  
00001140                           259  
00001140                           260  
00001140                           261  ;ORI (ANDI, SUBI, ADDI, EORI, CMPI)                                 $0
00001140                           262  opcode0000:                                 
00001140  2200                     263      MOVE.L      D0,D1                   ;D1 has full instruction
00001142  0241 0F00                264      ANDI.W      #nibble2,D1             ;check bits 11,10,9,8
00001146  143C 0008                265      MOVE.B      #right8, D2             ;store immediate value 8 in D2
0000114A  E469                     266      LSR.W       D2, D1                  ;shift to isolate next nibble (bits 11-8)
0000114C  C2FC 0006                267      MULU        #6, D1                  ;multiply by 6 to get displacement
00001150  47F9 00001276            268      LEA         OP_0000_TABLE, A3       ;load op_0000_table into address register
00001156  4EF3 1000                269      JMP         0(A3,D1)                ;jumps to opcode table entry (A0 = OP_TABLE)
0000115A                           270  
0000115A                           271  ;MOVE.B                                                             $1
0000115A                           272  opcode0001:
0000115A  4EF9 0000145E            273      JMP         OP_MOVEB                ;no need to break down, only MOVE.B
00001160                           274  
00001160                           275  
00001160                           276  ;MOVEA.L, MOVE.L                                                    $2
00001160                           277  opcode0010:
00001160  2200                     278      MOVE.L      D0,D1                   ;D1 has full instruction
00001162  0241 01C0                279      ANDI        #dest_mode, D1          ;0000 0001 1100 0000
00001166  143C 0006                280      MOVE.B      #right6, D2             ;D2 now 00000111
0000116A  E469                     281      LSR.W       D2, D1                  ;shifting destination mode in D1 to far right by 3
0000116C  B23C 0001                282      CMP.B       #1,D1                   ;does d1 = 001?
00001170  6700 0310                283      BEQ         OP_MOVEAL               ;if d1 = 001, go to MOVEA
00001174  4EF9 000014AA            284      JMP         OP_MOVEL                ;else jump to MOVEL
0000117A                           285      
0000117A                           286  
0000117A                           287  
0000117A                           288  
0000117A                           289  ;MOVEA.W MOVE.W                                                     $3
0000117A                           290  opcode0011:
0000117A  2200                     291      MOVE.L      D0,D1                   ;D1 has full instruction
0000117C  0241 01C0                292      ANDI        #dest_mode, D1          ;0000 0001 1100 0000
00001180  143C 0006                293      MOVE.B      #right6, D2             ;D2 now 00000111
00001184  E469                     294      LSR.W       D2, D1                  ;shifting destination mode in D1 to far right by 3
00001186  B23C 0001                295      CMP.B       #1,D1                   ;does d1 = 001?
0000118A  6700 0342                296      BEQ         OP_MOVEAW               ;if d1 = 001, go to MOVEAW
0000118E  4EF9 000014F6            297      JMP         OP_MOVEW                ;else jump to MOVEW
00001194                           298  
00001194                           299  
00001194                           300  
00001194                           301  
00001194                           302  ;NOP, MOVEM, LEA (CLR, NOT, EXT, TRAP, STOP, RTE, RTS, JSR, JMP)     $4
00001194                           303  opcode0100:
00001194  2200                     304      MOVE.L      D0,D1                   ;D1 has full instruction
00001196  0241 0F00                305      ANDI.W      #nibble2,D1             ;check bits 11,10,9,8
0000119A  143C 0008                306      MOVE.B      #right8, D2             ;store immediate value 8 in D2
0000119E  E469                     307      LSR.W       D2, D1                  ;shift to isolate next nibble (bits 11-8)
000011A0  C2FC 0006                308      MULU        #6, D1                  ;multiply by 6 to get displacement
000011A4  47F9 000012D6            309      LEA         OP_0100_TABLE, A3       ;load op_0000_table into address register
000011AA  4EF3 1000                310      JMP         0(A3,D1)                ;jumps to opcode table entry (A0 = OP_TABLE)
000011AE                           311  
000011AE                           312  
000011AE                           313  ;ADDQ (SUBQ)                                                        $5
000011AE                           314  opcode0101:
000011AE                           315      ;JMP         OP_ADDQ
000011AE                           316      
000011AE                           317      
000011AE                           318      ;3/8/21
000011AE  2200                     319      MOVE.L      D0,D1
000011B0  0241 0F00                320      ANDI.W      #nibble2,D1
000011B4  E049                     321      LSR.W       #right8,D1
000011B6  0241 0001                322      ANDI.W      #1,D1
000011BA  B23C 0000                323      CMP.B       #0,D1
000011BE  6700 03A8                324      BEQ         OP_ADDQ
000011C2  B23C 0001                325      CMP.B       #1,D1   
000011C6  6700 03C2                326      BEQ         OP_SUBQ
000011CA                           327      ;HANDLE ERROR
000011CA                           328  
000011CA                           329  
000011CA                           330  ;EA_ADDQ_SUBQ:
000011CA                           331  ;    ;CHECK BIT 8 FOR ADDQ OR SUBQ
000011CA                           332  ;    CMP.W       #nibble2,D1
000011CA                           333  ;    LSR.W       #right7,D1     
000011CA                           334  ;    ANDI.W      #1,D1
000011CA                           335  ;    CMP.B       #0,D1
000011CA                           336  ;    BEQ         EA_ADDQ
000011CA                           337  ;    CMP.B       #1,D1  
000011CA                           338  ;    BEQ         EA_SUBQ
000011CA                           339  ;    ;HANDLE ERROR      
000011CA                           340  
000011CA                           341  
000011CA                           342  ;BRA.bw, BSR.bw (BEQ)                                               $6
000011CA                           343  opcode0110:
000011CA  2200                     344      MOVE.L      D0,D1                   ;D1 has full instruction
000011CC  0241 0F00                345      ANDI.W      #nibble2,D1             ;check bits 11,10,9,8
000011D0  143C 0008                346      MOVE.B      #right8, D2             ;store immediate value 8 in D2
000011D4  E469                     347      LSR.W       D2, D1                  ;shift to isolate next nibble (bits 11-8)
000011D6  C2FC 0006                348      MULU        #6, D1                  ;multiply by 6 to get displacement
000011DA  47F9 00001336            349      LEA         OP_0110_TABLE, A3       ;load op_0110_table into address register
000011E0  4EF3 1000                350      JMP         0(A3,D1)                ;jumps to opcode table entry (A0 = OP_TABLE)
000011E4                           351      
000011E4                           352      ;come back and check when debugging. if this does not work then skip jump table
000011E4                           353  
000011E4                           354  
000011E4                           355  ;MOVEQ                                                            $7
000011E4                           356  opcode0111:
000011E4  4EF9 000015DC            357      JMP         OP_MOVEQ
000011EA                           358  
000011EA                           359  
000011EA                           360  
000011EA                           361  ;DIVU (DIVS, OR)                                                    $8
000011EA                           362  opcode1000:
000011EA  2200                     363      MOVE.L      D0,D1
000011EC  0241 0F00                364      ANDI.W      #nibble2,D1
000011F0  E049                     365      LSR.W       #8,D1
000011F2  0201 0001                366      ANDI.B      #1,D1
000011F6  B23C 0000                367      CMP.B       #0,D1
000011FA  6700 0400                368      BEQ         OP_DIVU
000011FE  B23C 0001                369      CMP.B       #1,D1
00001202  6700 0414                370      BEQ         OP_DIVS
00001206                           371      ;HANDLE ERROR
00001206                           372  
00001206                           373  ;SUB                                                                $9
00001206                           374  opcode1001:
00001206  4EF9 00001634            375      JMP         OP_SUB
0000120C                           376  
0000120C                           377  
0000120C                           378  ;not assigned                                                       $A
0000120C                           379  opcode1010:
0000120C  4EF9 00001724            380      JMP         OP_UNSUPPORTED_OPCODE
00001212                           381  
00001212                           382  
00001212                           383  ;CMP (EOR)                                                          $B
00001212                           384  opcode1011:
00001212  4EF9 00001652            385      JMP         OP_CMP
00001218                           386  
00001218                           387  
00001218                           388  ;MULU (MULS, AND)                                                   $C
00001218                           389  opcode1100:
00001218  2200                     390      MOVE.L      D0,D1
0000121A  0241 0F00                391      ANDI.W      #nibble2,D1
0000121E  E049                     392      LSR.W       #8,D1
00001220  0201 0001                393      ANDI.B      #1,D1
00001224  B23C 0000                394      CMP.B       #0,D1
00001228  6700 0446                395      BEQ         OP_MULU
0000122C  B23C 0001                396      CMP.B       #1,D1
00001230  6700 045A                397      BEQ         OP_MULS
00001234                           398      ;HANDLE ERROR
00001234                           399  
00001234                           400  ;ADD, ADDA                                                          $D
00001234                           401  opcode1101:
00001234                           402      ;ADD and ADDA differ on bits 6,7... ADD will never be 11 for bits 6,7... use as check
00001234  4241                     403      CLR         D1
00001236  4242                     404      CLR         D2
00001238  2200                     405      MOVE.L      D0,D1
0000123A  0241 00F0                406      ANDI.W      #nibble3, D1
0000123E  143C 0006                407      MOVE.B      #right6, D2
00001242  E469                     408      LSR.W       D2,D1
00001244                           409      
00001244                           410      ;at this point we have our bits of interest in bits 1,0
00001244                           411      
00001244  B27C 0003                412      CMP         #3,D1                              ;check if bits == 11
00001248  6700 047C                413      BEQ         OP_ADDA                             ;if yes, branch ADDA
0000124C  6000 045A                414      BRA         OP_ADD                              ;else branch ADD
00001250                           415  
00001250                           416  
00001250                           417  
00001250                           418  ;ASL, ASR (LSL, LSR, ROL, ROR)                                      $E
00001250                           419  opcode1110:
00001250  4241                     420      CLR D1
00001252  4242                     421      CLR D2
00001254  2200                     422      MOVE.L      D0, D1
00001256  0241 0F00                423      ANDI.W      #nibble2, D1
0000125A  143C 0008                424      MOVE.B      #right8, D2
0000125E  E469                     425      LSR.W       D2, D1                              ;D1 has 0003 or 0004
00001260  0241 0001                426      ANDI.W      #0001,D1                           ;isolate single bit
00001264                           427      
00001264                           428      ;at this point we have our single bit of interest in bit 0
00001264                           429      
00001264  B27C 0000                430      CMP         #0,D1                           ;check if bit == 0
00001268  6700 049C                431      BEQ         OP_ASR                          ;if yes, branch to ASR
0000126C  6000 047A                432      BRA         OP_ASL                          ;else, branch to ASL
00001270                           433  
00001270                           434  
00001270                           435  ;not assigned                                                       $F
00001270                           436  opcode1111:
00001270  4EF9 00001724            437      JMP         OP_UNSUPPORTED_OPCODE
00001276                           438  
00001276                           439  
00001276                           440  ;******************************** OP_XXX_TABLES ************************************
00001276                           441  ;once in OP_XXX_TABLE , we will use these entries to jump to specific op code to put into buffer
00001276                           442  
00001276                           443  OP_0000_TABLE:
00001276  4EF9 00001396            444      jmp OP_ORI                                      ;0  
0000127C  4EF9 00001724            445      jmp OP_UNSUPPORTED_OPCODE                       ;1
00001282  4EF9 000013B4            446      jmp OP_ANDI                                     ;2
00001288  4EF9 00001724            447      jmp OP_UNSUPPORTED_OPCODE                       ;3
0000128E  4EF9 000013D6            448      jmp OP_SUBI                                     ;4
00001294  4EF9 00001724            449      jmp OP_UNSUPPORTED_OPCODE                       ;5
0000129A  4EF9 000013F8            450      jmp OP_ADDI                                     ;6
000012A0  4EF9 00001724            451      jmp OP_UNSUPPORTED_OPCODE                       ;7
000012A6  4EF9 00001724            452      jmp OP_UNSUPPORTED_OPCODE                       ;8
000012AC  4EF9 00001724            453      jmp OP_UNSUPPORTED_OPCODE                       ;9
000012B2  4EF9 0000141A            454      jmp OP_EORI                                     ;10
000012B8  4EF9 00001724            455      jmp OP_UNSUPPORTED_OPCODE                       ;11
000012BE  4EF9 0000143C            456      jmp OP_CMPI                                     ;12
000012C4  4EF9 00001724            457      jmp OP_UNSUPPORTED_OPCODE                       ;13
000012CA  4EF9 00001724            458      jmp OP_UNSUPPORTED_OPCODE                       ;14
000012D0  4EF9 00001724            459      jmp OP_UNSUPPORTED_OPCODE                       ;15
000012D6                           460  
000012D6                           461  ;OP_0001_TABLE:
000012D6                           462  ;    jmp OP_MOVEB
000012D6                           463  
000012D6                           464  
000012D6                           465  ;OP_0010_TABLE:
000012D6                           466  ;   jmp OP_MOVEAL
000012D6                           467  ;   jmp OP_MOVEL
000012D6                           468  
000012D6                           469  
000012D6                           470  ;OP_0011_TABLE:
000012D6                           471  
000012D6                           472  
000012D6                           473  
000012D6                           474  ;NOP, MOVEM, LEA (CLR, NOT, EXT, TRAP, STOP, RTE, RTS, JSR, JMP     $4
000012D6                           475  ;NOP    1110
000012D6                           476  ;MOVEM  1D00
000012D6                           477  ;LEA    AN1
000012D6                           478  OP_0100_TABLE:
000012D6  4EF9 00001724            479      jmp OP_UNSUPPORTED_OPCODE                           ;0  
000012DC  4EF9 00001550            480      jmp OP_LEA                                          ;1      (address 0001)
000012E2  4EF9 00001724            481      jmp OP_UNSUPPORTED_OPCODE                           ;2
000012E8  4EF9 00001550            482      jmp OP_LEA                                          ;3      (address 0011)
000012EE  4EF9 00001724            483      jmp OP_UNSUPPORTED_OPCODE                           ;4 
000012F4  4EF9 00001550            484      jmp OP_LEA                                          ;5      (address 0101)
000012FA  4EF9 00001724            485      jmp OP_UNSUPPORTED_OPCODE                           ;6 
00001300  4EF9 00001550            486      jmp OP_LEA                                          ;7      (address 0111) 
00001306  4EF9 0000152A            487      jmp OP_MOVEM                                        ;8                          ;jmp OP_MOVEM_R2M
0000130C  4EF9 00001550            488      jmp OP_LEA                                          ;9      (address 1001) 
00001312  4EF9 00001724            489      jmp OP_UNSUPPORTED_OPCODE                           ;10 
00001318  4EF9 00001550            490      jmp OP_LEA                                          ;11     (address 1011) 
0000131E  4EF9 0000152A            491      jmp OP_MOVEM                                        ;12                         ;jmp OP_MOVEM_M2R    
00001324  4EF9 00001550            492      jmp OP_LEA                                          ;13     (address 1101)
0000132A  4EF9 0000151A            493      jmp OP_NOP                                          ;14
00001330  4EF9 00001550            494      jmp OP_LEA                                          ;15     (address 1111)
00001336                           495  
00001336                           496  
00001336                           497  ;OP_0101_TABLE:
00001336                           498  
00001336                           499  
00001336                           500  
00001336                           501  ;BRA nibble 2 = 0000 (0) , BSR nibble 2 = 0001 (1)
00001336                           502  OP_0110_TABLE:
00001336  4EF9 000015AC            503      jmp OP_BRA                                          ;0
0000133C  4EF9 000015C4            504      jmp OP_BSR                                          ;1
00001342  4EF9 00001724            505      jmp OP_UNSUPPORTED_OPCODE                           ;2
00001348  4EF9 00001724            506      jmp OP_UNSUPPORTED_OPCODE                           ;3
0000134E  4EF9 00001724            507      jmp OP_UNSUPPORTED_OPCODE                           ;4
00001354  4EF9 00001724            508      jmp OP_UNSUPPORTED_OPCODE                           ;5
0000135A  4EF9 00001724            509      jmp OP_UNSUPPORTED_OPCODE                           ;6
00001360  4EF9 00001724            510      jmp OP_UNSUPPORTED_OPCODE                           ;7
00001366  4EF9 00001724            511      jmp OP_UNSUPPORTED_OPCODE                           ;8
0000136C  4EF9 00001724            512      jmp OP_UNSUPPORTED_OPCODE                           ;9
00001372  4EF9 00001724            513      jmp OP_UNSUPPORTED_OPCODE                           ;10
00001378  4EF9 00001724            514      jmp OP_UNSUPPORTED_OPCODE                           ;11
0000137E  4EF9 00001724            515      jmp OP_UNSUPPORTED_OPCODE                           ;12
00001384  4EF9 00001724            516      jmp OP_UNSUPPORTED_OPCODE                           ;13
0000138A  4EF9 00001724            517      jmp OP_UNSUPPORTED_OPCODE                           ;14
00001390  4EF9 00001724            518      jmp OP_UNSUPPORTED_OPCODE                           ;15
00001396                           519  
00001396                           520  
00001396                           521  ;OP_0111_TABLE:
00001396                           522  ;implement later if needed
00001396                           523  
00001396                           524  
00001396                           525  ;OP_1000_TABLE:
00001396                           526  ;implement later if needed
00001396                           527  
00001396                           528  
00001396                           529  ;OP_1001_TABLE:
00001396                           530  ;implement later if needed
00001396                           531  
00001396                           532  
00001396                           533  ;OP_1010_TABLE:
00001396                           534  ;implement later if needed
00001396                           535  
00001396                           536  
00001396                           537  ;OP_1011_TABLE:
00001396                           538  ;implement later if needed
00001396                           539  
00001396                           540  
00001396                           541  ;OP_1100_TABLE:
00001396                           542  ;implement later if needed
00001396                           543  
00001396                           544  
00001396                           545  ;OP_1101_TABLE:
00001396                           546  ;implement later if needed
00001396                           547  
00001396                           548  
00001396                           549  ;OP_1110_TABLE:
00001396                           550  ;implement later if needed
00001396                           551  
00001396                           552  
00001396                           553  ;OP_1111_TABLE:
00001396                           554  ;implement later if needed
00001396                           555  
00001396                           556  
00001396                           557  
00001396                           558  
00001396                           559  ;******************************** OP_INSTRUCTION_XXXX******************************************
00001396                           560  ;this is where we are putting ascii text into buffer
00001396                           561  
00001396                           562  
00001396                           563  OP_ORI:
00001396  14FC 004F                564      MOVE.B  #'O', (A2)+
0000139A  14FC 0052                565      MOVE.B  #'R', (A2)+
0000139E  14FC 0049                566      MOVE.B  #'I', (A2)+
000013A2                           567      
000013A2                           568      ;call OP_CHECK_SIZE to append a .b/.w/.l
000013A2  4EB9 00001724            569      JSR     OP_CHECK_SIZE
000013A8                           570      
000013A8  7200                     571      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
000013AA                           572  
000013AA  4EB9 0000189E            573      JSR     EA_START
000013B0  4EF8 10C4                574      JMP     OP_FINISH
000013B4                           575  
000013B4                           576  OP_ANDI:  ;(optional)
000013B4  14FC 0041                577      MOVE.B  #'A', (A2)+
000013B8  14FC 004E                578      MOVE.B  #'N', (A2)+
000013BC  14FC 0044                579      MOVE.B  #'D', (A2)+
000013C0  14FC 0049                580      MOVE.B  #'I', (A2)+
000013C4                           581      
000013C4                           582      ;call OP_CHECK_SIZE to append a .b/.w/.l
000013C4  4EB9 00001724            583      JSR     OP_CHECK_SIZE
000013CA                           584      
000013CA  7200                     585      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
000013CC                           586  
000013CC  4EB9 0000189E            587      JSR     EA_START
000013D2  4EF8 10C4                588      JMP     OP_FINISH
000013D6                           589  
000013D6                           590  
000013D6                           591  OP_SUBI:  ;(optional)
000013D6  14FC 0053                592      MOVE.B  #'S', (A2)+
000013DA  14FC 0055                593      MOVE.B  #'U', (A2)+
000013DE  14FC 0042                594      MOVE.B  #'B', (A2)+
000013E2  14FC 0049                595      MOVE.B  #'I', (A2)+
000013E6                           596      
000013E6                           597      ;call OP_CHECK_SIZE to append a .b/.w/.l
000013E6  4EB9 00001724            598      JSR     OP_CHECK_SIZE
000013EC                           599      
000013EC  7200                     600      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
000013EE                           601  
000013EE  4EB9 0000189E            602      JSR     EA_START
000013F4  4EF8 10C4                603      JMP     OP_FINISH
000013F8                           604  
000013F8                           605  
000013F8                           606  OP_ADDI:  ;(optional)
000013F8  14FC 0041                607      MOVE.B  #'A', (A2)+
000013FC  14FC 0044                608      MOVE.B  #'D', (A2)+
00001400  14FC 0044                609      MOVE.B  #'D', (A2)+
00001404  14FC 0049                610      MOVE.B  #'I', (A2)+
00001408                           611      
00001408                           612      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001408  4EB9 00001724            613      JSR     OP_CHECK_SIZE
0000140E                           614     
0000140E  7200                     615      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
00001410                           616  
00001410  4EB9 0000189E            617      JSR     EA_START
00001416  4EF8 10C4                618      JMP     OP_FINISH
0000141A                           619  
0000141A                           620  
0000141A                           621  OP_EORI:  ;(optional)
0000141A  14FC 0045                622      MOVE.B  #'E', (A2)+
0000141E  14FC 004F                623      MOVE.B  #'O', (A2)+
00001422  14FC 0052                624      MOVE.B  #'R', (A2)+
00001426  14FC 0049                625      MOVE.B  #'I', (A2)+
0000142A                           626      
0000142A                           627      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000142A  4EB9 00001724            628      JSR     OP_CHECK_SIZE
00001430                           629      
00001430  7200                     630      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
00001432                           631      
00001432  4EB9 0000189E            632      JSR     EA_START
00001438  4EF8 10C4                633      JMP     OP_FINISH
0000143C                           634  
0000143C                           635  
0000143C                           636  OP_CMPI:  ;(optional)
0000143C  14FC 0043                637      MOVE.B  #'C', (A2)+
00001440  14FC 004D                638      MOVE.B  #'M', (A2)+
00001444  14FC 0050                639      MOVE.B  #'P', (A2)+
00001448  14FC 0049                640      MOVE.B  #'I', (A2)+
0000144C                           641      
0000144C                           642      
0000144C                           643      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000144C  4EB9 00001724            644      JSR     OP_CHECK_SIZE
00001452                           645  
00001452  7200                     646      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
00001454                           647  
00001454  4EB9 0000189E            648      JSR     EA_START
0000145A  4EF8 10C4                649      JMP     OP_FINISH
0000145E                           650  
0000145E                           651  
0000145E                           652  OP_MOVEB:
0000145E  14FC 004D                653      MOVE.B  #'M', (A2)+
00001462  14FC 004F                654      MOVE.B  #'O', (A2)+
00001466  14FC 0056                655      MOVE.B  #'V', (A2)+
0000146A  14FC 0045                656      MOVE.B  #'E', (A2)+
0000146E  14FC 002E                657      MOVE.B  #'.', (A2)+
00001472  14FC 0042                658      MOVE.B  #'B', (A2)+
00001476                           659      
00001476  7201                     660      MOVE.L  #ea_type_move, D1                   ;preps for EA_START and puts 1 into D1
00001478                           661      
00001478  4EB9 0000189E            662      JSR     EA_START
0000147E  4EF8 10C4                663      JMP     OP_FINISH
00001482                           664  
00001482                           665  OP_MOVEAL:
00001482  14FC 004D                666      MOVE.B  #'M', (A2)+
00001486  14FC 004F                667      MOVE.B  #'O', (A2)+
0000148A  14FC 0056                668      MOVE.B  #'V', (A2)+
0000148E  14FC 0045                669      MOVE.B  #'E', (A2)+
00001492  14FC 0041                670      MOVE.B  #'A', (A2)+
00001496  14FC 002E                671      MOVE.B  #'.', (A2)+
0000149A  14FC 004C                672      MOVE.B  #'L', (A2)+
0000149E                           673      
0000149E  7202                     674      MOVE.L  #ea_type_movea, D1                   ;preps for EA_START and puts 2 into D1
000014A0                           675      
000014A0  4EB9 0000189E            676      JSR     EA_START
000014A6  4EF8 10C4                677      JMP     OP_FINISH
000014AA                           678  
000014AA                           679  OP_MOVEL:
000014AA  14FC 004D                680      MOVE.B  #'M', (A2)+
000014AE  14FC 004F                681      MOVE.B  #'O', (A2)+
000014B2  14FC 0056                682      MOVE.B  #'V', (A2)+
000014B6  14FC 0045                683      MOVE.B  #'E', (A2)+
000014BA  14FC 002E                684      MOVE.B  #'.', (A2)+
000014BE  14FC 004C                685      MOVE.B  #'L', (A2)+
000014C2                           686      
000014C2  7201                     687      MOVE.L  #ea_type_move, D1                   ;preps for EA_START and puts 1 into D1
000014C4                           688      
000014C4  4EB9 0000189E            689      JSR     EA_START
000014CA  4EF8 10C4                690      JMP     OP_FINISH
000014CE                           691  
000014CE                           692  
000014CE                           693  OP_MOVEAW:
000014CE  14FC 004D                694      MOVE.B  #'M', (A2)+
000014D2  14FC 004F                695      MOVE.B  #'O', (A2)+
000014D6  14FC 0056                696      MOVE.B  #'V', (A2)+
000014DA  14FC 0045                697      MOVE.B  #'E', (A2)+
000014DE  14FC 0041                698      MOVE.B  #'A', (A2)+
000014E2  14FC 002E                699      MOVE.B  #'.', (A2)+
000014E6  14FC 0057                700      MOVE.B  #'W', (A2)+
000014EA                           701      
000014EA  7202                     702      MOVE.L  #ea_type_movea, D1                   ;preps for EA_START and puts 2 into D1
000014EC                           703      
000014EC  4EB9 0000189E            704      JSR     EA_START
000014F2  4EF8 10C4                705      JMP     OP_FINISH
000014F6                           706  
000014F6                           707  
000014F6                           708  OP_MOVEW:
000014F6  14FC 004D                709      MOVE.B  #'M', (A2)+
000014FA  14FC 004F                710      MOVE.B  #'O', (A2)+
000014FE  14FC 0056                711      MOVE.B  #'V', (A2)+
00001502  14FC 0045                712      MOVE.B  #'E', (A2)+
00001506  14FC 002E                713      MOVE.B  #'.', (A2)+
0000150A  14FC 0057                714      MOVE.B  #'W', (A2)+
0000150E                           715      
0000150E  7201                     716      MOVE.L  #ea_type_move, D1                   ;preps for EA_START and puts 1 into D1
00001510                           717      
00001510  4EB9 0000189E            718      JSR     EA_START
00001516  4EF8 10C4                719      JMP     OP_FINISH
0000151A                           720  
0000151A                           721  
0000151A                           722  OP_NOP:
0000151A  14FC 004E                723      MOVE.B  #'N', (A2)+
0000151E  14FC 004F                724      MOVE.B  #'O', (A2)+
00001522  14FC 0050                725      MOVE.B  #'P', (A2)+
00001526                           726      
00001526                           727      ;NO EA
00001526  4EF8 10C4                728      JMP     OP_FINISH
0000152A                           729  
0000152A                           730  
0000152A                           731  OP_MOVEM:
0000152A                           732      ;see movemd2r or movemr2d... see below at bottom ?????
0000152A                           733      
0000152A  14FC 004D                734      MOVE.B  #'M', (A2)+
0000152E  14FC 004F                735      MOVE.B  #'O', (A2)+
00001532  14FC 0056                736      MOVE.B  #'V', (A2)+
00001536  14FC 0045                737      MOVE.B  #'E', (A2)+
0000153A  14FC 004D                738      MOVE.B  #'M', (A2)+
0000153E                           739      
0000153E                           740      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000153E  4EB9 00001724            741      JSR     OP_CHECK_SIZE
00001544                           742      
00001544  7206                     743      MOVE.L  #ea_type_movem, D1                   ;preps for EA_START and puts 6 into D1
00001546                           744      
00001546  4EB9 0000189E            745      JSR     EA_START
0000154C  4EF8 10C4                746      JMP     OP_FINISH
00001550                           747  
00001550                           748  OP_LEA:
00001550  14FC 004C                749      MOVE.B  #'L', (A2)+
00001554  14FC 0045                750      MOVE.B  #'E', (A2)+
00001558  14FC 0041                751      MOVE.B  #'A', (A2)+
0000155C                           752      
0000155C  7203                     753      MOVE.L  #ea_type_lea, D1                   ;preps for EA_START and puts 3 into D1
0000155E                           754      
0000155E  4EB9 0000189E            755      JSR     EA_START
00001564  4EF8 10C4                756      JMP     OP_FINISH
00001568                           757  
00001568                           758  OP_CLR:  ;(optional)
00001568                           759  ;implement later if needed
00001568                           760  
00001568                           761  
00001568                           762  OP_NOT:  ;(optional)
00001568                           763  ;implement later if needed
00001568                           764  
00001568                           765  
00001568                           766  OP_EXT:  ;(optional)
00001568                           767  ;implement later if needed
00001568                           768  
00001568                           769  
00001568                           770  OP_TRAP:  ;(optional)
00001568                           771  ;implement later if needed
00001568                           772  
00001568                           773   
00001568                           774  OP_STOP:  ;(optional)
00001568                           775  ;implement later if needed
00001568                           776  
00001568                           777  
00001568                           778  OP_RTE:  ;(optional)
00001568                           779  ;implement later if needed
00001568                           780  
00001568                           781  
00001568                           782  OP_RTS:  ;(optional)
00001568                           783  ;implement later if needed
00001568                           784  
00001568                           785  
00001568                           786  OP_JSR:  ;(optional)
00001568                           787  ;implement later if needed
00001568                           788  
00001568                           789  
00001568                           790  OP_JMP:  ;(optional)
00001568                           791  ;implement later if needed
00001568                           792  
00001568                           793  
00001568                           794  OP_ADDQ:
00001568  14FC 0041                795      MOVE.B  #'A', (A2)+
0000156C  14FC 0044                796      MOVE.B  #'D', (A2)+
00001570  14FC 0044                797      MOVE.B  #'D', (A2)+
00001574  14FC 0051                798      MOVE.B  #'Q', (A2)+
00001578                           799      
00001578                           800      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001578  4EB9 00001724            801      JSR     OP_CHECK_SIZE
0000157E                           802  
0000157E  7208                     803      MOVE.L  #ea_type_quick, D1                   ;preps for EA_START and puts 8 into D1
00001580                           804  
00001580  4EB9 0000189E            805      JSR     EA_START
00001586  4EF8 10C4                806      JMP     OP_FINISH
0000158A                           807  
0000158A                           808  OP_SUBQ:  ;(optional)
0000158A  14FC 0053                809      MOVE.B  #'S', (A2)+
0000158E  14FC 0055                810      MOVE.B  #'U', (A2)+
00001592  14FC 0042                811      MOVE.B  #'B', (A2)+
00001596  14FC 0051                812      MOVE.B  #'Q', (A2)+
0000159A                           813      
0000159A                           814      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000159A  4EB9 00001724            815      JSR     OP_CHECK_SIZE
000015A0                           816      
000015A0  7208                     817      MOVE.L  #ea_type_quick, D1                   ;preps for EA_START and puts 8 into D1
000015A2                           818  
000015A2  4EB9 0000189E            819      JSR     EA_START
000015A8  4EF8 10C4                820      JMP     OP_FINISH
000015AC                           821  
000015AC                           822  OP_BRA:                                     ;???? DO WE DEFINE SIZE HERE OR AFTER????
000015AC  14FC 0042                823      MOVE.B  #'B', (A2)+
000015B0  14FC 0052                824      MOVE.B  #'R', (A2)+
000015B4  14FC 0041                825      MOVE.B  #'A', (A2)+
000015B8                           826  
000015B8  7209                     827      MOVE.L  #ea_type_branch,D1
000015BA                           828      
000015BA  4EB9 0000189E            829      JSR     EA_START
000015C0  4EF8 10C4                830      JMP     OP_FINISH
000015C4                           831  
000015C4                           832  
000015C4                           833  OP_BSR:
000015C4  14FC 0042                834      MOVE.B  #'B', (A2)+
000015C8  14FC 0053                835      MOVE.B  #'S', (A2)+
000015CC  14FC 0052                836      MOVE.B  #'R', (A2)+
000015D0                           837      
000015D0  7209                     838      MOVE.L  #ea_type_branch,D1
000015D2                           839      
000015D2  4EB9 0000189E            840      JSR     EA_START                        ;DO WE HAVE EA?
000015D8  4EF8 10C4                841      JMP     OP_FINISH
000015DC                           842  
000015DC                           843  
000015DC                           844  OP_BEQ:
000015DC                           845  ;implement later if needed
000015DC                           846  
000015DC                           847  
000015DC                           848  OP_MOVEQ:
000015DC  14FC 004D                849      MOVE.B  #'M', (A2)+
000015E0  14FC 004F                850      MOVE.B  #'O', (A2)+
000015E4  14FC 0056                851      MOVE.B  #'V', (A2)+
000015E8  14FC 0045                852      MOVE.B  #'E', (A2)+
000015EC  14FC 0051                853      MOVE.B  #'Q', (A2)+
000015F0                           854      
000015F0                           855      ;DO WE NEED A .L ?
000015F0                           856      
000015F0  7208                     857      MOVE.L  #ea_type_quick, D1                   ;preps for EA_START and puts 8 into D1
000015F2                           858      
000015F2  4EB9 0000189E            859      JSR     EA_START
000015F8  4EF8 10C4                860      JMP     OP_FINISH
000015FC                           861  
000015FC                           862  
000015FC                           863  OP_DIVU:
000015FC  14FC 0044                864      MOVE.B  #'D', (A2)+
00001600  14FC 0049                865      MOVE.B  #'I', (A2)+
00001604  14FC 0056                866      MOVE.B  #'V', (A2)+
00001608  14FC 0055                867      MOVE.B  #'U', (A2)+
0000160C                           868    
0000160C  720A                     869      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
0000160E                           870    
0000160E  4EB9 0000189E            871      JSR     EA_START
00001614  4EF8 10C4                872      JMP     OP_FINISH    
00001618                           873  
00001618                           874  
00001618                           875  OP_DIVS  ;(optional)
00001618  14FC 0044                876      MOVE.B  #'D', (A2)+
0000161C  14FC 0049                877      MOVE.B  #'I', (A2)+
00001620  14FC 0056                878      MOVE.B  #'V', (A2)+
00001624  14FC 0053                879      MOVE.B  #'S', (A2)+
00001628                           880    
00001628  720A                     881      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
0000162A                           882    
0000162A  4EB9 0000189E            883      JSR     EA_START
00001630  4EF8 10C4                884      JMP     OP_FINISH   
00001634                           885  
00001634                           886  
00001634                           887  OP_OR  ;(optional)
00001634                           888  ;implement later if needed
00001634                           889  
00001634                           890  
00001634                           891  OP_SUB:
00001634  14FC 0053                892      MOVE.B  #'S', (A2)+
00001638  14FC 0055                893      MOVE.B  #'U', (A2)+
0000163C  14FC 0042                894      MOVE.B  #'B', (A2)+
00001640                           895  
00001640  4EB9 00001724            896      JSR     OP_CHECK_SIZE                       ;call OP_CHECK_SIZE to append a .b/.w/.l
00001646                           897      
00001646  720A                     898      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
00001648                           899      
00001648                           900      ;at this point it will return with SUB.X and go to EA_START
00001648  4EB9 0000189E            901      JSR     EA_START
0000164E  4EF8 10C4                902      JMP     OP_FINISH    
00001652                           903  
00001652                           904  
00001652                           905  OP_CMP:
00001652  14FC 0043                906      MOVE.B  #'C', (A2)+
00001656  14FC 004D                907      MOVE.B  #'M', (A2)+
0000165A  14FC 0050                908      MOVE.B  #'P', (A2)+
0000165E                           909    
0000165E  4EB9 00001724            910      JSR     OP_CHECK_SIZE                       ;call OP_CHECK_SIZE to append a .b/.w/.l  
00001664                           911      
00001664  720A                     912      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
00001666                           913      
00001666                           914      ;at this point it will return with SUB.X and go to EA_START
00001666  4EB9 0000189E            915      JSR     EA_START
0000166C  4EF8 10C4                916      JMP     OP_FINISH    
00001670                           917      
00001670                           918  
00001670                           919  
00001670                           920  OP_EOR:  ;(optional)
00001670                           921  ;implement later if needed
00001670                           922  
00001670                           923  
00001670                           924  OP_MULU:
00001670  14FC 004D                925      MOVE.B  #'M', (A2)+
00001674  14FC 0055                926      MOVE.B  #'U', (A2)+
00001678  14FC 004C                927      MOVE.B  #'L', (A2)+
0000167C  14FC 0055                928      MOVE.B  #'U', (A2)+
00001680                           929  
00001680  720A                     930      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
00001682                           931      
00001682  4EB9 0000189E            932      JSR     EA_START
00001688  4EF8 10C4                933      JMP     OP_FINISH    
0000168C                           934  
0000168C                           935  OP_MULS:  ;(optional)
0000168C  14FC 004D                936      MOVE.B  #'M', (A2)+
00001690  14FC 0055                937      MOVE.B  #'U', (A2)+
00001694  14FC 004C                938      MOVE.B  #'L', (A2)+
00001698  14FC 0053                939      MOVE.B  #'S', (A2)+
0000169C                           940  
0000169C  720A                     941      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
0000169E                           942  
0000169E  4EB9 0000189E            943      JSR     EA_START
000016A4  4EF8 10C4                944      JMP     OP_FINISH
000016A8                           945  
000016A8                           946  
000016A8                           947  OP_AND:  ;(optional)
000016A8                           948  ;implement later if needed
000016A8                           949  
000016A8                           950  
000016A8                           951  OP_ADD:
000016A8  14FC 0041                952      MOVE.B  #'A', (A2)+
000016AC  14FC 0044                953      MOVE.B  #'D', (A2)+
000016B0  14FC 0044                954      MOVE.B  #'D', (A2)+
000016B4                           955  
000016B4                           956      ;call OP_CHECK_SIZE to append a .b/.w/.l
000016B4  4EB9 00001724            957      JSR     OP_CHECK_SIZE
000016BA                           958      
000016BA  720A                     959      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
000016BC                           960  
000016BC  4EB9 0000189E            961      JSR     EA_START
000016C2  4EF8 10C4                962      JMP     OP_FINISH
000016C6                           963  
000016C6                           964  OP_ADDA:
000016C6  14FC 0041                965      MOVE.B  #'A', (A2)+
000016CA  14FC 0044                966      MOVE.B  #'D', (A2)+
000016CE  14FC 0044                967      MOVE.B  #'D', (A2)+
000016D2  14FC 0041                968      MOVE.B  #'A', (A2)+
000016D6                           969  
000016D6                           970      ;call OP_CHECK_SIZE to append a .b/.w/.l
000016D6  4EB9 00001766            971      JSR     OP_CHECK_SIZE_ADDA
000016DC                           972      
000016DC  720A                     973      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
000016DE                           974  
000016DE  4EB9 0000189E            975      JSR     EA_START
000016E4  4EF8 10C4                976      JMP     OP_FINISH
000016E8                           977  
000016E8                           978  
000016E8                           979  OP_ASL:
000016E8  14FC 0041                980      MOVE.B  #'A', (A2)+
000016EC  14FC 0053                981      MOVE.B  #'S', (A2)+
000016F0  14FC 004C                982      MOVE.B  #'L', (A2)+
000016F4                           983  
000016F4                           984      ;call OP_CHECK_SIZE to append a .b/.w/.l
000016F4  4EB9 00001724            985      JSR     OP_CHECK_SIZE
000016FA                           986      
000016FA  720B                     987      MOVE.L  #ea_type_rotation, D1                   ;preps for EA_START and puts 10 into D1
000016FC                           988      
000016FC  4EB9 0000189E            989      JSR     EA_START
00001702  4EF8 10C4                990      JMP     OP_FINISH
00001706                           991  
00001706                           992  
00001706                           993  OP_ASR:
00001706  14FC 0041                994      MOVE.B  #'A', (A2)+
0000170A  14FC 0053                995      MOVE.B  #'S', (A2)+
0000170E  14FC 0052                996      MOVE.B  #'R', (A2)+
00001712                           997  
00001712                           998      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001712  4EB9 00001724            999      JSR     OP_CHECK_SIZE
00001718                          1000      
00001718  720B                    1001      MOVE.L  #ea_type_rotation, D1                   ;preps for EA_START and puts 10 into D1
0000171A                          1002  
0000171A  4EB9 0000189E           1003      JSR     EA_START
00001720  4EF8 10C4               1004      JMP     OP_FINISH
00001724                          1005  
00001724                          1006  OP_LSL:  ;(optional)
00001724                          1007  ;implement later if needed
00001724                          1008  
00001724                          1009  
00001724                          1010  
00001724                          1011  OP_LSR:  ;(optional)
00001724                          1012  ;implement later if needed
00001724                          1013  
00001724                          1014  
00001724                          1015  
00001724                          1016  OP_ROL:  ;(optional)
00001724                          1017  ;implement later if needed
00001724                          1018  
00001724                          1019  
00001724                          1020  
00001724                          1021  OP_ROR:  ;(optional)
00001724                          1022  ;implement later if needed
00001724                          1023  
00001724                          1024  
00001724                          1025  
00001724                          1026  ;OP_MOVEM_R2M:
00001724                          1027  ;    MOVE.B  #'M', (A2)+
00001724                          1028  ;    MOVE.B  #'O', (A2)+
00001724                          1029  ;    MOVE.B  #'V', (A2)+
00001724                          1030  ;    MOVE.B  #'E', (A2)+
00001724                          1031  ;    MOVE.B  #'M', (A2)+
00001724                          1032      
00001724                          1033  ;    ;call OP_CHECK_SIZE to append a .b/.w/.l
00001724                          1034  ;    JSR     OP_CHECK_SIZE
00001724                          1035      
00001724                          1036  ;    MOVE.L  #ea_type_movem, D1                   ;preps for EA_START and puts 6 into D1
00001724                          1037      
00001724                          1038  ;    JSR     EA_START
00001724                          1039  ;    JMP     OP_FINISH
00001724                          1040  
00001724                          1041  
00001724                          1042  ;OP_MOVEM_M2R:
00001724                          1043  ;    MOVE.B  #'M', (A2)+
00001724                          1044  ;    MOVE.B  #'O', (A2)+
00001724                          1045  ;    MOVE.B  #'V', (A2)+
00001724                          1046  ;    MOVE.B  #'E', (A2)+
00001724                          1047  ;    MOVE.B  #'M', (A2)+
00001724                          1048      
00001724                          1049  ;    ;call OP_CHECK_SIZE to append a .b/.w/.l
00001724                          1050  ;    JSR     OP_CHECK_SIZE
00001724                          1051      
00001724                          1052  ;    MOVE.L  #ea_type_movem, D1                   ;preps for EA_START and puts 6 into D1
00001724                          1053      
00001724                          1054  ;    JSR     EA_START
00001724                          1055  ;    JMP     OP_FINISH
00001724                          1056  
00001724                          1057  
00001724                          1058  OP_UNSUPPORTED_OPCODE:
00001724                          1059  ;fill out
00001724                          1060  
00001724                          1061  ;D0 HAS COMPLETE INSTRUCTION
00001724                          1062  OP_CHECK_SIZE:
00001724  4241                    1063      CLR     D1                                  ;CLEAR D1
00001726  4242                    1064      CLR     D2                                  ;clear D2
00001728  2200                    1065      MOVE.L  D0,D1                               ;D0 and D1 both have complete opcode
0000172A  0241 00F0               1066      ANDI.W  #nibble3,D1                         ;isolate nibble 3
0000172E  143C 0006               1067      MOVE.B  #right6, D2                         ;putting immediate value 6 in D2
00001732  E469                    1068      LSR.W   D2, D1                              ;bits 7,6 --> bits 1,0
00001734                          1069      
00001734                          1070       
00001734  B27C 0000               1071      CMP     #00,D1                              ;compare bits 1,0 to 00
00001738  6700 000E               1072      BEQ     OP_SIZE_BYTE                        ;if bits == 00, size byte
0000173C  B27C 0001               1073      CMP     #01,D1                              ;compare bits to 01
00001740  6700 0010               1074      BEQ     OP_SIZE_WORD                        ;if bits == 01, size word
00001744  6000 0016               1075      BRA     OP_SIZE_LONG                        ;else size long
00001748                          1076  
00001748                          1077  OP_SIZE_BYTE
00001748  14FC 002E               1078      MOVE.B  #'.', (A2)+
0000174C  14FC 0042               1079      MOVE.B  #'B', (A2)+
00001750  4E75                    1080      RTS
00001752                          1081  
00001752                          1082  OP_SIZE_WORD
00001752  14FC 002E               1083      MOVE.B  #'.', (A2)+
00001756  14FC 0057               1084      MOVE.B  #'W', (A2)+
0000175A  4E75                    1085      RTS
0000175C                          1086  
0000175C                          1087  
0000175C                          1088  OP_SIZE_LONG
0000175C  14FC 002E               1089      MOVE.B  #'.', (A2)+
00001760  14FC 004C               1090      MOVE.B  #'L', (A2)+
00001764  4E75                    1091      RTS
00001766                          1092  
00001766                          1093  
00001766                          1094  OP_CHECK_SIZE_ADDA:
00001766  4241                    1095      CLR     D1                                  ;CLEAR D1
00001768  4242                    1096      CLR     D2                                  ;clear D2
0000176A  2200                    1097      MOVE.L  D0,D1                               ;D0 and D1 both have complete opcode
0000176C  0241 0F00               1098      ANDI.W  #nibble2,D1                         ;isolate nibble 2
00001770  143C 0008               1099      MOVE.B  #right8, D2                         ;putting immediate value 8 in D2
00001774  E469                    1100      LSR.W   D2, D1                              ;
00001776                          1101      
00001776                          1102      ;at this point we have our single bit in bit 0
00001776                          1103      
00001776  0241 0001               1104      ANDI.W  #0001,D1                            ;isolate bit 0
0000177A  B27C 0000               1105      CMP     #0,D1                               ;check if bit == 0
0000177E  67D2                    1106      BEQ     OP_SIZE_WORD                        ;if yes, size = word
00001780  60DA                    1107      BRA     OP_SIZE_LONG                        ;else, size = long
00001782                          1108   
00001782                          1109  
00001782                          1110  ;******************************** ATOI ******************************************************************************************************************************
00001782                          1111  ATOI:
00001782  2401                    1112          MOVE.L      D1,D2                   ;loop variable (size) is in D2
00001784  2449                    1113          MOVEA.L     A1,A2                   ;pointer to next char
00001786  4284                    1114          CLR.L       D4
00001788                          1115  
00001788                          1116  ATOI_LOOP  
00001788  4243                    1117          CLR         D3                      ;clear d3
0000178A                          1118          ;CMP.B       #0,D2
0000178A                          1119          ;BEQ         ATOI_DONE               ;DONE
0000178A  5382                    1120          SUBI.L      #1,D2                   ;subtract 1 from loop counter
0000178C  161A                    1121          MOVE.B      (A2)+,D3                 ;move current byte to D3, then increment to next
0000178E  B63C 002F               1122          CMP.B       #$2F,D3
00001792  6F00 0060               1123          BLE         ATOI_ERROR              ;if less than 30, not a number, branch to error
00001796  B63C 0039               1124          CMP.B       #$39,D3                 ;check byte to see if number or letter
0000179A  6F00 002A               1125          BLE         ATOI_NUMBER             ;30<x<39 --> number
0000179E  B63C 0040               1126          CMP.B       #$40,D3
000017A2  6F00 0050               1127          BLE         ATOI_ERROR
000017A6  B63C 0046               1128          CMP.B       #$46,D3
000017AA  6F00 0024               1129          BLE         ATOI_UPPERCASE_LETTER   ;less than 47, it is uppercase letter
000017AE  B63C 0060               1130          CMP.B       #$60,D3
000017B2  6F00 0040               1131          BLE         ATOI_ERROR
000017B6  B63C 0066               1132          CMP.B       #$66,D3
000017BA  6F00 001E               1133          BLE         ATOI_LOWERCASE_LETTER
000017BE  B63C 0067               1134          CMP.B       #$67,D3
000017C2  6C00 0030               1135          BGE         ATOI_ERROR
000017C6                          1136          
000017C6                          1137          ;BNE         ATOI_LOOP                    ;run loop
000017C6                          1138      
000017C6                          1139  
000017C6                          1140  ATOI_NUMBER
000017C6                          1141  ;number --> d1 = d1 - $30
000017C6  0403 0030               1142      SUBI.B          #$30, D3                    ;subtract 30 if number
000017CA                          1143      ;MOVE.B          D3,(A2)+                    ;move into A2 and post increment pointer
000017CA  4EF9 000017E4           1144      JMP             ATOI_FORMAT                 ;testing
000017D0                          1145      ;JMP            ATOI_LOOP                   ;loop
000017D0                          1146  
000017D0                          1147  ATOI_UPPERCASE_LETTER
000017D0                          1148  ;letter --> d1 = d1 - $37
000017D0  0403 0037               1149      SUBI.B          #$37,D3                     ;subtract 37 if UPPER case letter
000017D4                          1150      ;MOVE.B          D3,(A2)+                    ;move into A2 and post increment pointer
000017D4  4EF9 000017E4           1151      JMP             ATOI_FORMAT                 ;testing
000017DA                          1152      ;JMP            ATOI_LOOP                   ;loop
000017DA                          1153  
000017DA                          1154  ATOI_LOWERCASE_LETTER
000017DA  0403 0057               1155      SUBI.B          #$57,D3                     ;subtract 57(20 + 37)
000017DE                          1156      ;MOVE.B          D3,(A2)+                    ;move into A2 and post increment pointer
000017DE  4EF9 000017E4           1157      JMP             ATOI_FORMAT                 ;testing
000017E4                          1158      ;JMP            ATOI_LOOP                  ;loop
000017E4                          1159  
000017E4                          1160  
000017E4                          1161  ATOI_FORMAT
000017E4  D803                    1162      ADD.B           D3,D4                       ;add the byte to D4 so can add later   
000017E6  B43C 0000               1163      CMP.B           #0,D2                       
000017EA  6700 0008               1164      BEQ             ATOI_DONE                   ;check if done (loop counter D2 is at 0)
000017EE  E984                    1165      ASL.L           #4,D4                       ;logical shift left to make room
000017F0  4EF8 1788               1166      JMP             ATOI_LOOP                   ;go back to loop
000017F4                          1167  
000017F4                          1168  ATOI_ERROR
000017F4                          1169      ;come back to handle error when out of range
000017F4                          1170      
000017F4                          1171  
000017F4                          1172  ATOI_DONE 
000017F4  2284                    1173      MOVE.L         D4,(A1)                      ;at this point, move the new address in D4 to mem location                                
000017F6  4E75                    1174      RTS                                         ;used to RTS after a branch statement
000017F8                          1175  
000017F8                          1176  ;************************************* ITOA *******************************************************************************************************************
000017F8                          1177  ;A0
000017F8                          1178  ;A1
000017F8                          1179  ;A2 = buffer (this is our decoded string that will print to screen)
000017F8                          1180  ;A3
000017F8                          1181  ;A4 = current memory address for buffer
000017F8                          1182  ;A5 = starting address / current address in memory
000017F8                          1183  ;A6 = ending address
000017F8                          1184  ;A7 = SP
000017F8                          1185  
000017F8                          1186  ;D0 = counter
000017F8                          1187  ;D1 = 
000017F8                          1188  ;D2 = ?
000017F8                          1189  ;D3 = buffer size (used for loop = 64)
000017F8                          1190  ;D4 = value being converted
000017F8                          1191  ;D5 =
000017F8                          1192  ;D6 = 
000017F8                          1193  ;D7 = 
000017F8                          1194  ITOA:
000017F8  280D                    1195      MOVE.L         A5,D4                    ;D4 has data to convert to ascii
000017FA                          1196  
000017FA                          1197  ITOA_LOOP:
000017FA  BA3C 0000               1198      CMP.B           #0,D5
000017FE  6700 004C               1199      BEQ             ITOA_FINISH             ;when 0, branch to finish to complete
00001802                          1200  
00001802                          1201  
00001802                          1202  
00001802                          1203  
00001802                          1204  ITOA_BYTE:
00001802                          1205  
00001802                          1206  
00001802                          1207  
00001802                          1208  ITOA_WORD:
00001802                          1209  
00001802                          1210  
00001802                          1211  
00001802                          1212  ITOA_LONG:
00001802                          1213  
00001802                          1214  
00001802                          1215  
00001802                          1216  ITOA_ADDRESS:
00001802  4284                    1217      CLR.L       D4                          ;D4 = 0000 0000
00001804  280D                    1218      MOVE.L      A5,D4                       ;our address is now in D4 and ready to deconstruct
00001806  103C 0008               1219      MOVE.B      #8,D0                       ;counter
0000180A  4EF9 00001810           1220      JMP         ITOA_ADDRESS_LOOP
00001810                          1221  ITOA_ADDRESS_LOOP:
00001810  B03C 0000               1222      CMP.B       #0,D0                       ;check if done
00001814  6700 0036               1223      BEQ         ITOA_FINISH                 ;if at 0, branch to ITOA_FINISH
00001818  E99C                    1224      ROL.L       #4,D4                       ;rotate left 4 bits, to get MSB to beginning 
0000181A  1204                    1225      MOVE.B      D4,D1                       ;store in D1 (this will be whole byte, we want half)
0000181C  0241 000F               1226      ANDI.W      #$000F,D1                   ;character is now isolated
00001820                          1227      
00001820  4EB9 0000182C           1228      JSR         ITOA_HEX2ASCII              ;JSR to convert
00001826  5340                    1229      SUBI        #1,D0                       ;subtract 1 from counter
00001828  4EF8 1810               1230      JMP         ITOA_ADDRESS_LOOP           ;loop again!
0000182C                          1231  
0000182C                          1232  ITOA_HEX2ASCII:
0000182C  B23C 000A               1233      CMP.B       #$A,D1                      ;compare byte in D1 to hex value A
00001830  6C00 0012               1234      BGE         ITOA_LETTER                 ;if greater than/equal A, it is letter
00001834  B23C 000A               1235      CMP.B       #$A,D1                      ;compare byte in D1 to hex value A
00001838  6D00 0002               1236      BLT         ITOA_NUMBER                 ;if less than, it is number
0000183C                          1237  
0000183C                          1238  ITOA_NUMBER:
0000183C  0601 0030               1239      ADDI.B      #$30,D1                     ;add $30 to D1 to convert
00001840  14C1                    1240      MOVE.B      D1,(A2)+                    ;add to buffer and increment to next position
00001842  4E75                    1241      RTS
00001844                          1242  
00001844                          1243  ITOA_LETTER:
00001844  0601 0037               1244      ADDI.B      #$37,D1                     ;add 37 to D1 to convert
00001848  14C1                    1245      MOVE.B      D1,(A2)+                    ;add to buffer and increment to next position
0000184A  4E75                    1246      RTS
0000184C                          1247  
0000184C                          1248  ITOA_FINISH:
0000184C  4E75                    1249      RTS
0000184E                          1250  
0000184E                          1251  
0000184E                          1252  ;************************************ Validate Addresses ******************************************
0000184E                          1253  
0000184E                          1254  VALIDATE_BEGINNING:
0000184E                          1255      
0000184E                          1256  
0000184E                          1257  
0000184E                          1258  
0000184E                          1259  ;******************************** Message Error Handling ***************************************************************************************************************** 
0000184E                          1260  STARTA_ERROR_LESS_THAN_ZERO:
0000184E  103C 000E               1261      MOVE.B  #14,D0
00001852  43F9 00001E08           1262      LEA     error_message_1,A1      ;load the get_end_address message into A1
00001858  4E4F                    1263      TRAP    #15    
0000185A  4EF8 1012               1264      JMP     GET_STARTING_ADDRESS
0000185E                          1265  
0000185E                          1266  STARTA_ERROR_NOT_EVEN:
0000185E  103C 000E               1267      MOVE.B  #14,D0
00001862  43F9 00001E32           1268      LEA     error_message_2,A1      ;load error_message_2
00001868  4E4F                    1269      TRAP    #15    
0000186A  4EF8 1012               1270      JMP     GET_STARTING_ADDRESS
0000186E                          1271  
0000186E                          1272  ENDA_ERROR_NOT_EVEN:
0000186E  103C 000E               1273      MOVE.B  #14,D0
00001872  43F9 00001E52           1274      LEA     error_message_3,A1      ;load error_message_3
00001878  4E4F                    1275      TRAP    #15
0000187A  4EF8 104A               1276      JMP     GET_ENDING_ADDRESS
0000187E                          1277  
0000187E                          1278  ENDA_ERROR_LARGE:
0000187E  103C 000E               1279      MOVE.B  #14,D0
00001882  43F9 00001E72           1280      LEA     error_message_4,A1      ;load error_message_4
00001888  4E4F                    1281      TRAP    #15
0000188A  4EF8 104A               1282      JMP     GET_ENDING_ADDRESS
0000188E                          1283      
0000188E                          1284  ENDA_ERROR_LESS_THAN_STARTA:
0000188E  103C 000E               1285      MOVE.B  #14,D0
00001892  43F9 00001EA1           1286      LEA     error_message_5,A1      ;load error_message_5
00001898  4E4F                    1287      TRAP    #15
0000189A  4EF8 104A               1288      JMP     GET_ENDING_ADDRESS
0000189E                          1289  
0000189E                          1290  ;****************************************** EA Stuff ********************************************************************************************************************* 
0000189E                          1291  
0000189E                          1292  EA_START:
0000189E  41F9 000018AC           1293      LEA         EA_TYPE_TABLE, A0
000018A4                          1294      
000018A4  C2FC 0006               1295      MULU        #6,D1               ;computes opcode table jump displacement
000018A8  4EF0 1000               1296      JMP         0(A0,D1)            ;jump to correct table input
000018AC                          1297  
000018AC                          1298  
000018AC                          1299  EA_TYPE_TABLE:
000018AC  4EF9 000018FC           1300      JMP         EA_IMMEDIATE        ;0  DONE
000018B2  4EF9 0000193E           1301      JMP         EA_MOVE             ;1  DONE
000018B8  4EF9 00001984           1302      JMP         EA_MOVEA            ;2  DONE
000018BE  4EF9 000019CA           1303      JMP         EA_LEA              ;3  DONE
000018C4  4EF9 00001A0A           1304      JMP         EA_DESTONLY         ;4  JMP, CLR
000018CA  4EF9 00001A0A           1305      JMP         EA_EXT              ;5
000018D0  4EF9 00001A0A           1306      JMP         EA_MOVEM            ;6
000018D6  4EF9 00001A30           1307      JMP         EA_TRAP             ;7
000018DC  4EF9 00001A30           1308      JMP         EA_QUICK            ;8  DONE
000018E2  4EF9 00001AAC           1309      JMP         EA_BRANCH           ;9  DONE
000018E8  4EF9 00001AF4           1310      JMP         EA_MATH             ;10 DONE    DIVU, DIVS, SUB, CMP, MULU, ADD, ADDA
000018EE  4EF9 00001B6C           1311      JMP         EA_ROTATION         ;11         ASL, ASR, ???  
000018F4  4EF9 000018FA           1312      JMP         EA_FINISH           ;
000018FA                          1313  
000018FA                          1314  EA_FINISH:
000018FA  4E75                    1315      RTS ; TAKE OUT LATER
000018FC                          1316      
000018FC                          1317  
000018FC                          1318  
000018FC                          1319  ;********************************************  EA_TYPE  ****************************************************   
000018FC                          1320  
000018FC                          1321  EA_IMMEDIATE:                               ;value 0
000018FC  14FC 0009               1322      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001900  14FC 0023               1323      MOVE.B  #'#',(A2)+                      ;add a # to buffer
00001904  14FC 0024               1324      MOVE.B  #'$',(A2)+                      ;add a $ to buffer
00001908                          1325      
00001908                          1326      ;check size which is bits 6,7 and store in D6
00001908                          1327      ;get immediate value from memory based off size and store in D7
00001908  4EB9 00001C98           1328      JSR     EA_CHECK_SIZE
0000190E                          1329      
0000190E                          1330      ;at this point our size is in D6 and data is in D7 and memory has been advanced
0000190E                          1331      ;convert immediate data to ascii and put on buffer
0000190E  4EB9 00001CC2           1332      JSR     EA_ITOA_IMMEDIATE
00001914                          1333      
00001914  41F9 00001BBC           1334      LEA     EA_MODE_TABLE,A0                ;load table
0000191A  14FC 002C               1335      MOVE.B  #',',(A2)+                      ;add a # to buffer
0000191E  14FC 0009               1336      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001922                          1337      
00001922                          1338      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
00001922                          1339      
00001922                          1340      ;isolate source mode - bits 3,4,5 and store in D4
00001922  2800                    1341      MOVE.L  D0,D4
00001924  E64C                    1342      LSR.W   #3,D4
00001926  0244 0007               1343      ANDI.W  #$7,D4
0000192A  C8FC 0006               1344      MULU    #6,D4
0000192E                          1345      
0000192E                          1346      ;isolate source register - bits 0,1,2 and store in D5
0000192E  2A00                    1347      MOVE.L  D0,D5
00001930  0245 0007               1348      ANDI.W  #$7,D5
00001934                          1349  
00001934  4EB9 00001BB8           1350      JSR     EA_JMP_HELPER
0000193A  4EF8 18FA               1351      JMP     EA_FINISH
0000193E                          1352  
0000193E                          1353  ;D4 = mode      --> source / destination
0000193E                          1354  ;D5 = register  --> source / destination   
0000193E                          1355  EA_MOVE:
0000193E  14FC 0009               1356      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001942  41F9 00001BBC           1357      LEA     EA_MODE_TABLE,A0                ;load table
00001948                          1358      
00001948                          1359      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
00001948                          1360      
00001948                          1361      ;isolate source mode
00001948  2800                    1362      MOVE.L  D0,D4
0000194A  E64C                    1363      LSR.W   #3,D4
0000194C  0244 0007               1364      ANDI.W  #$7,D4
00001950  C8FC 0006               1365      MULU    #6,D4
00001954                          1366          
00001954                          1367      ;isolate source register
00001954  2A00                    1368      MOVE.L  D0,D5
00001956  0245 0007               1369      ANDI.W  #$7,D5
0000195A                          1370      
0000195A  4EB9 00001BB8           1371      JSR    EA_JMP_HELPER
00001960  14FC 002C               1372      MOVE.B  #',',(A2)+                  ;add ',' to buffer  
00001964                          1373      
00001964                          1374      ;isolate destination mode
00001964  2800                    1375      MOVE.L  D0,D4
00001966  EC4C                    1376      LSR.W   #6,D4
00001968  0244 0007               1377      ANDI.W  #$7,D4
0000196C  C8FC 0006               1378      MULU    #6,D4
00001970                          1379      
00001970                          1380      ;isolate destination register 
00001970  2A00                    1381      MOVE.L  D0,D5
00001972  E84D                    1382      LSR.W   #4,D5
00001974  EA4D                    1383      LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
00001976  0245 0007               1384      ANDI.W  #$7,D5   
0000197A  4EB9 00001BB8           1385      JSR     EA_JMP_HELPER
00001980                          1386  
00001980  4EF8 18FA               1387      JMP     EA_FINISH
00001984                          1388      
00001984                          1389  
00001984                          1390  EA_MOVEA:
00001984  14FC 0009               1391      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001988  41F9 00001BBC           1392      LEA     EA_MODE_TABLE,A0                ;load table
0000198E                          1393  
0000198E                          1394      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
0000198E                          1395      
0000198E                          1396      ;isolate source mode
0000198E  2800                    1397      MOVE.L  D0,D4
00001990  E64C                    1398      LSR.W   #3,D4
00001992  0244 0007               1399      ANDI.W  #$7,D4
00001996  C8FC 0006               1400      MULU    #6,D4
0000199A                          1401          
0000199A                          1402      ;isolate source register
0000199A  2A00                    1403      MOVE.L  D0,D5
0000199C  0245 0007               1404      ANDI.W  #$7,D5
000019A0                          1405      
000019A0  4EB9 00001BB8           1406      JSR    EA_JMP_HELPER
000019A6  14FC 002C               1407      MOVE.B  #',',(A2)+                  ;add ',' to buffer
000019AA                          1408      
000019AA                          1409      ;isolate destination mode --> SHOULD ALWAYS BE 001 AND GO TO ADDRESS REGISTER
000019AA  2800                    1410      MOVE.L  D0,D4
000019AC  EC4C                    1411      LSR.W   #6,D4
000019AE  0244 0007               1412      ANDI.W  #$7,D4
000019B2  C8FC 0006               1413      MULU    #6,D4
000019B6                          1414      
000019B6                          1415      ;isolate destination register 
000019B6  2A00                    1416      MOVE.L  D0,D5
000019B8  E84D                    1417      LSR.W   #4,D5
000019BA  EA4D                    1418      LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
000019BC  0245 0007               1419      ANDI.W  #$7,D5   
000019C0  4EB9 00001BB8           1420      JSR     EA_JMP_HELPER
000019C6                          1421  
000019C6  4EF8 18FA               1422      JMP     EA_FINISH
000019CA                          1423  
000019CA                          1424  EA_LEA:
000019CA  14FC 0009               1425      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
000019CE  41F9 00001BBC           1426      LEA     EA_MODE_TABLE,A0                ;load table
000019D4                          1427      
000019D4                          1428      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
000019D4                          1429      
000019D4                          1430      ;isolate source mode
000019D4  2800                    1431      MOVE.L  D0,D4
000019D6  E64C                    1432      LSR.W   #3,D4
000019D8  0244 0007               1433      ANDI.W  #$7,D4
000019DC  C8FC 0006               1434      MULU    #6,D4
000019E0                          1435          
000019E0                          1436      ;isolate source register
000019E0  2A00                    1437      MOVE.L  D0,D5
000019E2  0245 0007               1438      ANDI.W  #$7,D5
000019E6                          1439      
000019E6  4EB9 00001BB8           1440      JSR    EA_JMP_HELPER
000019EC  14FC 002C               1441      MOVE.B  #',',(A2)+                  ;add ',' to buffer
000019F0                          1442      
000019F0                          1443      ;destination always An
000019F0                          1444      ;MOVE.B  #'A',(A2)+                  ;add 'A' to buffer
000019F0                          1445      
000019F0                          1446      ;isolate destination register 
000019F0                          1447      ;MOVE.L  D0,D5
000019F0                          1448      ;LSR.W   #4,D5
000019F0                          1449      ;LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
000019F0                          1450      ;ANDI.W  #$7,D5
000019F0                          1451  
000019F0                          1452      ;isolate destination mode --> SHOULD ALWAYS BE 001 AND GO TO ADDRESS REGISTER
000019F0  7801                    1453      MOVE.L  #1,D4
000019F2  C8FC 0006               1454      MULU    #6,D4
000019F6                          1455      
000019F6                          1456      ;isolate destination register 
000019F6  2A00                    1457      MOVE.L  D0,D5
000019F8  E84D                    1458      LSR.W   #4,D5
000019FA  EA4D                    1459      LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
000019FC  0245 0007               1460      ANDI.W  #$7,D5   
00001A00  4EB9 00001BB8           1461      JSR     EA_JMP_HELPER
00001A06                          1462  
00001A06  4EF8 18FA               1463      JMP     EA_FINISH
00001A0A                          1464  
00001A0A                          1465  EA_DESTONLY:        ;JMP, CLR
00001A0A                          1466  
00001A0A                          1467  
00001A0A                          1468  
00001A0A                          1469  
00001A0A                          1470  
00001A0A                          1471  EA_EXT:
00001A0A                          1472  
00001A0A                          1473  
00001A0A                          1474  
00001A0A                          1475  
00001A0A                          1476  
00001A0A                          1477  EA_MOVEM:
00001A0A  14FC 0009               1478      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001A0E  41F9 00001BBC           1479      LEA     EA_MODE_TABLE,A0                ;load table
00001A14                          1480      
00001A14                          1481      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
00001A14                          1482      
00001A14                          1483      ;isolate source mode
00001A14  2800                    1484      MOVE.L  D0,D4
00001A16  E64C                    1485      LSR.W   #3,D4
00001A18  0244 0007               1486      ANDI.W  #$7,D4
00001A1C  C8FC 0006               1487      MULU    #6,D4
00001A20                          1488          
00001A20                          1489      ;isolate source register
00001A20  2A00                    1490      MOVE.L  D0,D5
00001A22  0245 0007               1491      ANDI.W  #$7,D5
00001A26                          1492      
00001A26  4EB9 00001BB8           1493      JSR    EA_JMP_HELPER
00001A2C  14FC 002C               1494      MOVE.B  #',',(A2)+                  ;add ',' to buffer
00001A30                          1495  
00001A30                          1496  EA_TRAP:
00001A30                          1497  
00001A30                          1498  
00001A30                          1499  
00001A30                          1500  
00001A30                          1501  
00001A30                          1502  EA_QUICK:
00001A30                          1503      ;FIGURE WHAT KIND? (ADDQ,SUBQ,MOVEQ)
00001A30                          1504      ;ADDQ/SUBQ  -->  opcode = 0101 (stored in D0)
00001A30                          1505      ;MOVEQ      -->  opcode = 0111 (stored in D0)
00001A30  14FC 0009               1506      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001A34  14FC 0023               1507      MOVE.B  #'#',(A2)+                  ;add a # to buffer
00001A38  14FC 0024               1508      MOVE.B  #'$',(A2)+                  ;add a $ to buffer
00001A3C                          1509      
00001A3C  2200                    1510      MOVE.L  D0,D1                       ;should move into D1
00001A3E                          1511      
00001A3E                          1512      ;check for MOVEQ
00001A3E  EC49                    1513      LSR.W   #right6,D1
00001A40  EC49                    1514      LSR.W   #right6,D1  
00001A42  B27C 0007               1515      CMP.W   #$7,D1
00001A46  6700 003A               1516      BEQ     EA_QUICK_MOVEQ
00001A4A                          1517      
00001A4A  4241                    1518      CLR     D1                          ;else not MOVEQ, reset D1 and continue with ADDQ / SUBQ
00001A4C  2200                    1519      MOVE.L  D0,D1
00001A4E  0241 0E00               1520      ANDI.W  #dest_reg,D1                ;isolate destination register(11,10,9)
00001A52  E049                    1521      LSR.W   #right8,D1                  ;shift 8 times
00001A54  E249                    1522      LSR.W   #right1,D1                  ;shift 1 time for total of 9 times
00001A56                          1523      
00001A56                          1524      ;at this point we have our number, so convert to ASCII and put on buffer
00001A56  0601 0030               1525      ADDI.B  #$30,D1                     ;convert to ASCII
00001A5A  14C1                    1526      MOVE.B  D1,(A2)+                    ;put on buffer
00001A5C                          1527      
00001A5C                          1528      
00001A5C                          1529      ;ready for destination address
00001A5C  14FC 002C               1530      MOVE.B  #',',(A2)+                  ;add ',' to buffer  
00001A60  41F9 00001BBC           1531      LEA     EA_MODE_TABLE,A0            ;load table
00001A66                          1532      
00001A66                          1533      
00001A66                          1534      ;isolate source mode
00001A66  2800                    1535      MOVE.L  D0,D4
00001A68  E64C                    1536      LSR.W   #3,D4
00001A6A  0244 0007               1537      ANDI.W  #$7,D4
00001A6E  C8FC 0006               1538      MULU    #6,D4
00001A72                          1539          
00001A72                          1540      ;isolate source register
00001A72  2A00                    1541      MOVE.L  D0,D5
00001A74  0245 0007               1542      ANDI.W  #$7,D5
00001A78                          1543      
00001A78  4EB9 00001BB8           1544      JSR    EA_JMP_HELPER
00001A7E                          1545      
00001A7E  4EF8 18FA               1546      JMP     EA_FINISH
00001A82                          1547      
00001A82                          1548      ;LSR.W       #right12,D1         ;shift D1 by 12 bits, leaving just 4 bits      --> gives shift count error
00001A82                          1549      ;CMP.W       #$5,D1
00001A82                          1550      ;BEQ         EA_ADDQ_SUBQ
00001A82                          1551      
00001A82                          1552  EA_QUICK_MOVEQ:
00001A82  2200                    1553      MOVE.L  D0,D1
00001A84  0241 00FF               1554      ANDI.W  #$00FF,D1               ;isolate bits 7-0
00001A88                          1555      
00001A88                          1556      ;our bits are isolated in D1, move to D7 for ITOA function
00001A88  2E01                    1557      MOVE.L  D1,D7
00001A8A  4EB9 00001D24           1558      JSR     EA_ITOA_BYTE_CONVERT
00001A90                          1559      
00001A90  14FC 002C               1560      MOVE.B  #',',(A2)+                  ;add ',' to buffer
00001A94  14FC 0044               1561      MOVE.B  #'D',(A2)+                  ;add ',' to buffer
00001A98  2200                    1562      MOVE.L  D0,D1
00001A9A  0241 0F00               1563      ANDI.W  #nibble2,D1
00001A9E  E049                    1564      LSR.W   #8,D1
00001AA0  E249                    1565      LSR.W   #1,D1
00001AA2                          1566      
00001AA2                          1567      ;at this point we have our number, so convert to ASCII and put on buffer
00001AA2  0601 0030               1568      ADDI.B  #$30,D1                     ;convert to ASCII
00001AA6  14C1                    1569      MOVE.B  D1,(A2)+                    ;put on buffer
00001AA8                          1570  
00001AA8  4EF8 18FA               1571      JMP     EA_FINISH
00001AAC                          1572  
00001AAC                          1573  EA_BRANCH:
00001AAC                          1574      ;PROGRAM COUNTER @ A5
00001AAC                          1575      ;BRA or BSR
00001AAC                          1576      ;displacement bits are 7-0 
00001AAC  2200                    1577      MOVE.L  D0,D1
00001AAE  0241 00FF               1578      ANDI.W  #$00FF,D1               ;isolate bits 7-0
00001AB2                          1579      ;PERFORM CHECKS 0000 0000 = WORD VALUE, 1111 1111 = LONG VALUE
00001AB2                          1580      
00001AB2  B23C 0000               1581      CMP.B   #$00,D1
00001AB6  6700 0006               1582      BEQ     EA_BRANCH_16
00001ABA  6000 001A               1583      BRA     EA_BRANCH_32
00001ABE                          1584  
00001ABE                          1585  
00001ABE                          1586  
00001ABE                          1587  EA_BRANCH_16:
00001ABE  3215                    1588      MOVE.W  (A5),D1                    ;CHECK WHERE POINTER IS WHEN HITS HERE
00001AC0                          1589      ;D1 WILL HAVE OUR DISPLACEMENT (0E32)
00001AC0                          1590      ;ADD 0E32 TO PC + 2
00001AC0  3E01                    1591      MOVE.W  D1,D7
00001AC2  DE4D                    1592      ADD.W   A5,D7
00001AC4                          1593      ;SUBI.B  #2,D7
00001AC4                          1594      
00001AC4  14FC 0009               1595      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001AC8  14FC 0024               1596      MOVE.B  #'$',(A2)+                  ;add '$' to buffer
00001ACC                          1597      
00001ACC                          1598      ;convert to ASCII and put on buffer
00001ACC                          1599      ;D7 HAS DISPLACEMENT   
00001ACC  4EB9 00001AD6           1600      JSR     BRANCH_16_ITOA
00001AD2                          1601      
00001AD2  4EF8 18FA               1602      JMP     EA_FINISH
00001AD6                          1603  
00001AD6                          1604  EA_BRANCH_32:
00001AD6                          1605      ;come back and implement branch 32
00001AD6                          1606  
00001AD6                          1607  
00001AD6                          1608  
00001AD6                          1609  BRANCH_16_ITOA:
00001AD6                          1610      ;D7 HAS OUR DISPLACEMENT... CONVERT TO ASCII!   ;D7 = 1234
00001AD6  E04F                    1611      LSR.W   #right8,D7                              ;D7 = 0012
00001AD8  4EB9 00001D24           1612      JSR     EA_ITOA_BYTE_CONVERT                    ;BUFFER WILL HAVE 12
00001ADE  3E1D                    1613      MOVE.W  (A5)+,D7                                ;D7 = 0E32
00001AE0  DE4D                    1614      ADD.W   A5,D7                                   ;D7 = 123
00001AE2  5507                    1615      SUBI.B  #2,D7                                   ;SUBI 2 to account for post increment of A5
00001AE4  0247 00FF               1616      ANDI.W  #$00FF,D7                               ;D7 = 0034
00001AE8  4EB9 00001D24           1617      JSR     EA_ITOA_BYTE_CONVERT                    ;BUFFER WILL HAVE 1234
00001AEE                          1618      
00001AEE  4EF9 00001D5C           1619      JMP     EA_ITOA_DONE
00001AF4                          1620  
00001AF4                          1621  
00001AF4                          1622  EA_MATH:
00001AF4                          1623      ;source mode 3, 4, 5 | source register 0, 1, 2 | destination register 11, 10, 9
00001AF4  14FC 0009               1624      MOVE.B  #$09, (A2)+             ;add a ' ' to buffer
00001AF8  41F9 00001BBC           1625      LEA     EA_MODE_TABLE,A0        ;load mode table
00001AFE                          1626      
00001AFE                          1627      ;isolate source mode
00001AFE  2800                    1628      MOVE.L  D0,D4
00001B00  E64C                    1629      LSR.W   #3,D4
00001B02  0244 0007               1630      ANDI.W  #$7,D4
00001B06  C8FC 0006               1631      MULU    #6,D4
00001B0A                          1632      
00001B0A                          1633      ;isolate source register
00001B0A  2A00                    1634      MOVE.L  D0,D5
00001B0C  0245 0007               1635      ANDI.W  #$7,D5
00001B10                          1636      
00001B10  4EB9 00001BB8           1637      JSR     EA_JMP_HELPER
00001B16                          1638      
00001B16  14FC 002C               1639      MOVE.B  #',',(A2)+              ;add a ',' to buffer
00001B1A                          1640      
00001B1A                          1641      ;condition for ADDA - opcode == 1101 && bits 7,6 == 11
00001B1A                          1642      ;check for ADDA and leave if yes, otherwise continue
00001B1A  2200                    1643      MOVE.L  D0,D1                   ;complete opcode in D1
00001B1C  EC49                    1644      LSR.W   #6,D1                   ;shift right 6
00001B1E  EC49                    1645      LSR.W   #6,D1                   ;shift another 6 to = 12 total
00001B20                          1646      
00001B20  B27C 000D               1647      CMP     #$D,D1                  ;check if opcode = 1101
00001B24  6600 002C               1648      BNE     EA_MATH_CONTINUE        ;if not 1101, skip and go to math
00001B28                          1649      
00001B28                          1650      ;if we are here, we know opcode is 1101 and further check
00001B28  2200                    1651      MOVE.L  D0,D1
00001B2A  EC49                    1652      LSR.W   #6,D1
00001B2C  0241 0003               1653      ANDI.W  #3,D1
00001B30  B23C 0003               1654      CMP.B   #3,D1
00001B34  6600 001C               1655      BNE     EA_MATH_CONTINUE
00001B38                          1656      
00001B38                          1657      ;if d1 == 3, both conditions met so process as ADDA
00001B38                          1658      ;destination mode is 1 (address register)
00001B38  7801                    1659      MOVE.L  #1,D4
00001B3A  C8FC 0006               1660      MULU    #6,D4
00001B3E                          1661      
00001B3E                          1662      ;isolate destination register 
00001B3E  2A00                    1663      MOVE.L  D0,D5
00001B40  E84D                    1664      LSR.W   #4,D5
00001B42  EA4D                    1665      LSR.W   #5,D5                      
00001B44  0245 0007               1666      ANDI.W  #$7,D5   
00001B48                          1667   
00001B48  4EB9 00001BB8           1668      JSR     EA_JMP_HELPER 
00001B4E  4EF8 18FA               1669      JMP     EA_FINISH
00001B52                          1670          
00001B52                          1671  EA_MATH_CONTINUE:       
00001B52                          1672      ;destination mode is 0 (data register)
00001B52  7800                    1673      MOVE.L  #0,D4
00001B54  C8FC 0006               1674      MULU    #6,D4
00001B58                          1675      
00001B58                          1676      ;isolate destination register 
00001B58  2A00                    1677      MOVE.L  D0,D5
00001B5A  E84D                    1678      LSR.W   #4,D5
00001B5C  EA4D                    1679      LSR.W   #5,D5                      
00001B5E  0245 0007               1680      ANDI.W  #$7,D5  
00001B62                          1681      
00001B62  4EB9 00001BB8           1682      JSR     EA_JMP_HELPER 
00001B68  4EF8 18FA               1683      JMP     EA_FINISH
00001B6C                          1684      
00001B6C                          1685  
00001B6C                          1686  EA_ROTATION:
00001B6C  14FC 0009               1687      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001B70  2200                    1688      MOVE.L  D0,D1                       ;complete opcode
00001B72  EA49                    1689      LSR.W   #5,D1                       ;shift right 5
00001B74  0241 0001               1690      ANDI.W  #1,D1
00001B78                          1691      
00001B78  B27C 0000               1692      CMP     #0,D1
00001B7C  6700 002E               1693      BEQ     EA_ROTATION_IMMEDIATE       ;it is immediate value
00001B80  6000 0030               1694      BRA     EA_ROTATION_REGISTER        ;else register 
00001B84                          1695  
00001B84                          1696  EA_ROTATION_CONTINUE:
00001B84  2200                    1697      MOVE.L  D0,D1                       ;get rotation value
00001B86  0241 0F00               1698      ANDI.W  #nibble2,D1                 ;isolate nibble 2
00001B8A  E049                    1699      LSR.W   #8,D1
00001B8C  E249                    1700      LSR.W   #1,D1                       :total of 9 shifts right
00001B8E                          1701      
00001B8E                          1702      ;at this point we have our number, so convert to ASCII and put on buffer
00001B8E  0601 0030               1703      ADDI.B  #$30,D1                     ;convert to ASCII
00001B92  14C1                    1704      MOVE.B  D1,(A2)+                    ;put on buffer
00001B94                          1705      
00001B94  14FC 002C               1706      MOVE.B  #',',(A2)+                  ;add ',' to buffer 
00001B98  14FC 0044               1707      MOVE.B  #'D',(A2)+                  ;add 'D' to buffer
00001B9C                          1708      
00001B9C  2200                    1709      MOVE.L  D0,D1                       ;complete opcode
00001B9E  0241 0007               1710      ANDI.W  #7,D1                       
00001BA2                          1711      
00001BA2  0601 0030               1712      ADDI.B  #$30,D1                     ;convert to ASCII
00001BA6  14C1                    1713      MOVE.B  D1,(A2)+                    ;put on buffer
00001BA8                          1714      
00001BA8  4EF8 18FA               1715      JMP     EA_FINISH                   ;done
00001BAC                          1716  
00001BAC                          1717  EA_ROTATION_IMMEDIATE:
00001BAC  14FC 0023               1718      MOVE.B  #'#',(A2)+                  ;add '#' to buffer
00001BB0  60D2                    1719      BRA     EA_ROTATION_CONTINUE
00001BB2                          1720      
00001BB2                          1721  EA_ROTATION_REGISTER:
00001BB2  14FC 0044               1722      MOVE.B  #'D',(A2)+                  ;add '#' to buffer
00001BB6  60CC                    1723      BRA     EA_ROTATION_CONTINUE
00001BB8                          1724      
00001BB8                          1725  EA_JMP_HELPER
00001BB8  4EF0 4000               1726      JMP     0(A0,D4)
00001BBC                          1727  
00001BBC                          1728  
00001BBC                          1729  ;********************************************  EA_MODE_TABLE  ****************************************************  
00001BBC                          1730  EA_MODE_TABLE:
00001BBC  4EF9 00001BEC           1731      JMP     EA_MODE_000
00001BC2  4EF9 00001BFA           1732      JMP     EA_MODE_001
00001BC8  4EF9 00001C08           1733      JMP     EA_MODE_010
00001BCE  4EF9 00001C1E           1734      JMP     EA_MODE_011
00001BD4  4EF9 00001C38           1735      JMP     EA_MODE_100
00001BDA  4EF9 00001C50           1736      JMP     EA_MODE_101
00001BE0  4EF9 00001C50           1737      JMP     EA_MODE_110
00001BE6  4EF9 00001C50           1738      JMP     EA_MODE_111
00001BEC                          1739      ;JMP     EA_MODE_FINISH
00001BEC                          1740  
00001BEC                          1741  ;********************************************  EA_MODE_XXX  ****************************************************    
00001BEC                          1742  EA_MODE_000:                                        ;Data register 'Dn'
00001BEC  14FC 0044               1743      MOVE.B  #'D',(A2)+                              ;put D on buffer
00001BF0  1605                    1744      MOVE.B D5,D3                                    ;move to d3 for conversion
00001BF2  4EB9 00001C90           1745      JSR     EA_HEX_TO_ASCII                         ;puts register on buffer  
00001BF8  4E75                    1746      RTS
00001BFA                          1747      
00001BFA                          1748  EA_MODE_001:                                        ;Address Register 'An'
00001BFA  14FC 0041               1749      MOVE.B  #'A',(A2)+                              ;put A on buffer
00001BFE  1605                    1750      MOVE.B  D5,D3                                   ;move to d3 for conversion
00001C00  4EB9 00001C90           1751      JSR     EA_HEX_TO_ASCII                         ;puts register on buffer  
00001C06  4E75                    1752      RTS
00001C08                          1753  
00001C08                          1754  EA_MODE_010:                                        ;Address direct --> '(An)'
00001C08  14FC 0028               1755      MOVE.B  #'(',(A2)+                              ;put ( on buffer
00001C0C  14FC 0041               1756      MOVE.B  #'A',(A2)+                              ;put A on buffer
00001C10  1605                    1757      MOVE.B  D5,D3                                   ;move to D3 for conversion
00001C12  4EB9 00001C90           1758      JSR     EA_HEX_TO_ASCII                         ;convert and put on buffer   
00001C18  14FC 0029               1759      MOVE.B  #')',(A2)+                              ;put ) on buffer
00001C1C  4E75                    1760      RTS
00001C1E                          1761  
00001C1E                          1762  EA_MODE_011:                                        ;Address with Postincrement --> '(An)+' 
00001C1E  14FC 0028               1763      MOVE.B  #'(',(A2)+                              ;put ( on buffer
00001C22  14FC 0041               1764      MOVE.B  #'A',(A2)+                              ;put A on buffer
00001C26  1605                    1765      MOVE.B  D5,D3                                   ;move to D3 for conversion
00001C28  4EB9 00001C90           1766      JSR     EA_HEX_TO_ASCII                         ;convert and put on buffer   
00001C2E  14FC 0029               1767      MOVE.B  #')',(A2)+                              ;put ) on buffer
00001C32  14FC 002B               1768      MOVE.B  #'+',(A2)+                              ;put + on buffer
00001C36  4E75                    1769      RTS
00001C38                          1770  
00001C38                          1771  EA_MODE_100:                                        ;Address with Predecrement --> '-(An)'
00001C38  14FC 002D               1772      MOVE.B  #'-',(A2)+                              ;put - on buffer
00001C3C  14FC 0028               1773      MOVE.B  #'(',(A2)+                              ;put ( on buffer
00001C40  14FC 0041               1774      MOVE.B  #'A',(A2)+                              ;put A on buffer
00001C44  1605                    1775      MOVE.B  D5,D3                                   ;move to D3 for conversion
00001C46  4EB9 00001C90           1776      JSR     EA_HEX_TO_ASCII                         ;convert and put on buffer   
00001C4C  14FC 0029               1777      MOVE.B  #')',(A2)+                              ;put ) on buffer
00001C50                          1778  
00001C50                          1779  
00001C50                          1780  
00001C50                          1781  ;unsupported
00001C50                          1782  EA_MODE_101:                                        
00001C50                          1783  ;Address with Displacement --> '(d16, An)
00001C50                          1784      
00001C50                          1785  ;unsupported
00001C50                          1786  EA_MODE_110:
00001C50                          1787  
00001C50                          1788  
00001C50                          1789  
00001C50                          1790  ;some form of immediate data: short, long, immediate
00001C50                          1791  EA_MODE_111:
00001C50                          1792      ;D4 = MODE | D5 = register (000, 001, 100)
00001C50                          1793      ;000 = Absolute Short (xxx).w
00001C50                          1794      ;001 = Absolute Long (xxx).l
00001C50                          1795      ;100 = Immediate data
00001C50                          1796      
00001C50  BA3C 0000               1797      CMP.B   #000,D5
00001C54  6700 0012               1798      BEQ     EA_111_ABSOLUTE_SHORT
00001C58  BA3C 0001               1799      CMP.B   #001,D5
00001C5C  6700 001E               1800      BEQ     EA_111_ABSOLUTE_LONG
00001C60  BA3C 0064               1801      CMP.B   #100,D5
00001C64  6700 002A               1802      BEQ     EA_111_IMMEDIATE
00001C68                          1803      
00001C68                          1804      ;HANDLE ERROR
00001C68                          1805              
00001C68                          1806      
00001C68                          1807  EA_111_ABSOLUTE_SHORT:
00001C68                          1808      ;A5 is looking at correct spot
00001C68                          1809      ;ADD WORD VALUE AT A5 ON TO BUFFER AT A2 AND INCREMENT BY WORD
00001C68  14FC 0024               1810      MOVE.B  #'$',(A2)+                              ;put $ on buffer
00001C6C  3E15                    1811      MOVE.W  (A5),D7
00001C6E  4246                    1812      CLR     D6
00001C70  1C3C 0001               1813      MOVE.B  #01,D6                                  ;word size in EA_ITOA_IMMEDIATE
00001C74  4EB9 00001CC2           1814      JSR     EA_ITOA_IMMEDIATE
00001C7A  4E75                    1815      RTS
00001C7C                          1816  
00001C7C                          1817  EA_111_ABSOLUTE_LONG:
00001C7C  14FC 0024               1818      MOVE.B  #'$',(A2)+                              ;put $ on buffer
00001C80  3E15                    1819      MOVE.W  (A5),D7
00001C82  4246                    1820      CLR     D6
00001C84  1C3C 0002               1821      MOVE.B  #02,D6                                  ;long size in EA_ITOA_IMMEDIATE        
00001C88  4EB9 00001CC2           1822      JSR     EA_ITOA_IMMEDIATE
00001C8E  4E75                    1823      RTS
00001C90                          1824  
00001C90                          1825  EA_111_IMMEDIATE:
00001C90                          1826      
00001C90                          1827  
00001C90                          1828     
00001C90                          1829      
00001C90                          1830  
00001C90                          1831  EA_HEX_TO_ASCII:
00001C90  0603 0030               1832      ADDI.B      #$30,D3                     ;add $30 to D1 to convert
00001C94  14C3                    1833      MOVE.B      D3,(A2)+                    ;add to buffer and increment to next position
00001C96  4E75                    1834      RTS     
00001C98                          1835  
00001C98                          1836  
00001C98                          1837  EA_CHECK_SIZE:
00001C98  4246                    1838      CLR     D6
00001C9A  2C00                    1839      MOVE.L  D0,D6                           ;complete opcode --> D6
00001C9C  0246 00F0               1840      ANDI.W  #nibble3,D6                     ;isolating nibble 3
00001CA0  EC4E                    1841      LSR.W   #right6,D6                      ;shifting bits 7,6 --> 1,0
00001CA2                          1842      
00001CA2  BC7C 0000               1843      CMP     #00,D6
00001CA6  6700 000E               1844      BEQ     EA_SIZE_BYTE
00001CAA  BC7C 0001               1845      CMP     #01,D6
00001CAE  6700 000A               1846      BEQ     EA_SIZE_WORD
00001CB2  6000 000A               1847      BRA     EA_SIZE_LONG
00001CB6                          1848  
00001CB6                          1849  EA_SIZE_BYTE:
00001CB6  3E1D                    1850      MOVE.W  (A5)+,D7
00001CB8                          1851      ;MOVE.B  #4,D3;                          SET UP COUNTER
00001CB8  4E75                    1852      RTS
00001CBA                          1853  
00001CBA                          1854  EA_SIZE_WORD:
00001CBA  3E15                    1855      MOVE.W  (A5),D7
00001CBC                          1856      ;MOVE.B  #4,D3;                          SET UP COUNTER
00001CBC  4E75                    1857      RTS
00001CBE                          1858  
00001CBE                          1859  EA_SIZE_LONG:
00001CBE  3E15                    1860      MOVE.W  (A5),D7
00001CC0                          1861      ;MOVE.B  #8,D3;                          SET UP COUNTER
00001CC0  4E75                    1862      RTS
00001CC2                          1863  
00001CC2                          1864  
00001CC2                          1865  
00001CC2                          1866  EA_ITOA_IMMEDIATE:
00001CC2                          1867      ;D3 = counter, D7 = value to be converted, D6 = size
00001CC2  BC3C 0000               1868      CMP.B   #%00,D6
00001CC6  6700 0012               1869      BEQ     EA_ITOA_BYTE
00001CCA  BC3C 0001               1870      CMP.B   #%01,D6
00001CCE  6700 0016               1871      BEQ     EA_ITOA_WORD
00001CD2  BC3C 0002               1872      CMP.B   #%10,D6     
00001CD6  6700 0024               1873      BEQ     EA_ITOA_LONG
00001CDA                          1874      
00001CDA                          1875  
00001CDA                          1876  ;EA_IT0A_IMMEDIATE_LOOP
00001CDA                          1877  ;    CMP.B   #0,D3                       ;check if loop done
00001CDA                          1878  ;    BEQ     EA_ITOA_FINISH              ;if = 0, loop done
00001CDA                          1879      
00001CDA                          1880  EA_ITOA_BYTE:
00001CDA  4EB9 00001D24           1881      JSR     EA_ITOA_BYTE_CONVERT
00001CE0                          1882      
00001CE0  4EF9 00001D5C           1883      JMP     EA_ITOA_DONE
00001CE6                          1884  
00001CE6                          1885  
00001CE6                          1886  EA_ITOA_WORD:
00001CE6  E04F                    1887      LSR.W   #right8,D7
00001CE8  4EB9 00001D24           1888      JSR     EA_ITOA_BYTE_CONVERT
00001CEE  3E1D                    1889      MOVE.W  (A5)+,D7
00001CF0  4EB9 00001D24           1890      JSR     EA_ITOA_BYTE_CONVERT
00001CF6                          1891      
00001CF6  4EF9 00001D5C           1892      JMP     EA_ITOA_DONE
00001CFC                          1893      
00001CFC                          1894  EA_ITOA_LONG:
00001CFC  E04F                    1895      LSR.W   #right8,D7
00001CFE  4EB9 00001D24           1896      JSR     EA_ITOA_BYTE_CONVERT
00001D04  3E1D                    1897      MOVE.W  (A5)+,D7
00001D06  4EB9 00001D24           1898      JSR     EA_ITOA_BYTE_CONVERT
00001D0C                          1899  
00001D0C  3E15                    1900      MOVE.W  (A5),D7
00001D0E  E04F                    1901      LSR.W   #right8,D7
00001D10  4EB9 00001D24           1902      JSR     EA_ITOA_BYTE_CONVERT
00001D16  3E1D                    1903      MOVE.W  (A5)+,D7
00001D18  4EB9 00001D24           1904      JSR     EA_ITOA_BYTE_CONVERT
00001D1E                          1905  
00001D1E  4EF9 00001D5C           1906      JMP     EA_ITOA_DONE
00001D24                          1907  
00001D24                          1908  EA_ITOA_BYTE_CONVERT:
00001D24  3607                    1909      MOVE.W  D7,D3
00001D26  0243 00F0               1910      ANDI.W  #$F0,D3
00001D2A  E84B                    1911      LSR.W   #right4,D3
00001D2C  4EB9 00001D40           1912      JSR     EA_ITOA_NIBBLE_CONVERT
00001D32                          1913      
00001D32  3607                    1914      MOVE.W  D7,D3
00001D34  0243 000F               1915      ANDI.W  #$0F,D3
00001D38  4EB9 00001D40           1916      JSR     EA_ITOA_NIBBLE_CONVERT
00001D3E  4E75                    1917      RTS
00001D40                          1918  
00001D40                          1919  EA_ITOA_NIBBLE_CONVERT:
00001D40  B63C 0009               1920      CMP.B   #9,D3
00001D44  6E00 000E               1921      BGT     EA_ITOA_LETTER
00001D48  6000 0002               1922      BRA     EA_ITOA_NUMBER
00001D4C                          1923  
00001D4C                          1924  EA_ITOA_HEX2ASCII:
00001D4C                          1925  
00001D4C                          1926  
00001D4C                          1927  
00001D4C                          1928  EA_ITOA_NUMBER:
00001D4C  0603 0030               1929      ADDI.B  #$30,D3
00001D50  14C3                    1930      MOVE.B  D3,(A2)+
00001D52  4E75                    1931      RTS
00001D54                          1932  
00001D54                          1933  EA_ITOA_LETTER:
00001D54  0603 0037               1934      ADDI.B  #$37,D3
00001D58  14C3                    1935      MOVE.B  D3,(A2)+
00001D5A  4E75                    1936      RTS
00001D5C                          1937  
00001D5C                          1938  EA_ITOA_DONE
00001D5C  4E75                    1939      RTS
00001D5E                          1940  
00001D5E                          1941      
00001D5E                          1942  ;****************************************** MESSAGES ***************************************************
00001D5E= 57 65 6C 63 6F 6D ...   1943  welcome_message         DC.B    'Welcome to 68k disassembler',CR,LF,0
00001D7C                          1944  
00001D7C= 50 6C 65 61 73 65 ...   1945  get_start_address       DC.B    'Please enter a starting address in hexadecimal',CR,LF,0
00001DAD                          1946  
00001DAD= 50 6C 65 61 73 65 ...   1947  get_end_address         DC.B    'Please enter an ending address in hexadecimal',CR,LF,0
00001DDD                          1948  
00001DDD= 49 6E 76 61 6C 69 ...   1949  atoi_error_invalid      DC.B    'Invalid address, characters must be $0-F',CR,LF,0
00001E08                          1950  
00001E08                          1951  
00001E08= 49 6E 76 61 6C 69 ...   1952  error_message_1         DC.B    'Invalid Address: Must be greater than 0',CR,LF,0
00001E32                          1953  
00001E32= 49 6E 76 61 6C 69 ...   1954  error_message_2         DC.B    'Invalid Address: Must be even',CR,LF,0
00001E52                          1955  
00001E52= 49 6E 76 61 6C 69 ...   1956  error_message_3         DC.B    'Invalid Address: Must be even',CR,LF,0
00001E72                          1957  
00001E72= 49 6E 76 61 6C 69 ...   1958  error_message_4         DC.B    'Invalid Address: Must be less than $00FFFFFF',CR,LF,0
00001EA1                          1959  
00001EA1= 49 6E 76 61 6C 69 ...   1960  error_message_5         DC.B    'Invalid Address: Must be greater than starting address',CR,LF,0
00001EDA                          1961  
00001EDA                          1962  
00001EDA                          1963  ascii_start:
00001EDA                          1964      DS.w    10          ;specify size later?
00001EEE                          1965      
00001EEE                          1966  ascii_end:
00001EEE                          1967      DS.w    10          ;specify size later?
00001F02                          1968  
00001F02                          1969  buffer                  ;storing op code
00001F02                          1970      DS.W    64          ;do we leave as .w or change to .l ?
00001F82                          1971      
00001F82                          1972  
00001F82                          1973      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_END           1EEE
ASCII_START         1EDA
ATOI                1782
ATOI_DONE           17F4
ATOI_ERROR          17F4
ATOI_ERROR_INVALID  1DDD
ATOI_FORMAT         17E4
ATOI_LOOP           1788
ATOI_LOWERCASE_LETTER  17DA
ATOI_NUMBER         17C6
ATOI_UPPERCASE_LETTER  17D0
BRANCH_16_ITOA      1AD6
BUFFER              1F02
BUFFER_SIZE         40
CR                  D
DECODING_LOOP       1088
DEST_MODE           1C0
DEST_REG            E00
DONE                108E
EA_111_ABSOLUTE_LONG  1C7C
EA_111_ABSOLUTE_SHORT  1C68
EA_111_IMMEDIATE    1C90
EA_BRANCH           1AAC
EA_BRANCH_16        1ABE
EA_BRANCH_32        1AD6
EA_CHECK_SIZE       1C98
EA_DESTONLY         1A0A
EA_EXT              1A0A
EA_FINISH           18FA
EA_HEX_TO_ASCII     1C90
EA_IMMEDIATE        18FC
EA_ITOA_BYTE        1CDA
EA_ITOA_BYTE_CONVERT  1D24
EA_ITOA_DONE        1D5C
EA_ITOA_HEX2ASCII   1D4C
EA_ITOA_IMMEDIATE   1CC2
EA_ITOA_LETTER      1D54
EA_ITOA_LONG        1CFC
EA_ITOA_NIBBLE_CONVERT  1D40
EA_ITOA_NUMBER      1D4C
EA_ITOA_WORD        1CE6
EA_JMP_HELPER       1BB8
EA_LEA              19CA
EA_MATH             1AF4
EA_MATH_CONTINUE    1B52
EA_MODE_000         1BEC
EA_MODE_001         1BFA
EA_MODE_010         1C08
EA_MODE_011         1C1E
EA_MODE_100         1C38
EA_MODE_101         1C50
EA_MODE_110         1C50
EA_MODE_111         1C50
EA_MODE_TABLE       1BBC
EA_MOVE             193E
EA_MOVEA            1984
EA_MOVEM            1A0A
EA_QUICK            1A30
EA_QUICK_MOVEQ      1A82
EA_ROTATION         1B6C
EA_ROTATION_CONTINUE  1B84
EA_ROTATION_IMMEDIATE  1BAC
EA_ROTATION_REGISTER  1BB2
EA_SIZE_BYTE        1CB6
EA_SIZE_LONG        1CBE
EA_SIZE_WORD        1CBA
EA_START            189E
EA_TRAP             1A30
EA_TYPE_BRANCH      9
EA_TYPE_DESTONLY    4
EA_TYPE_EXT         5
EA_TYPE_IMMEDIATE   0
EA_TYPE_LEA         3
EA_TYPE_MATH        A
EA_TYPE_MOVE        1
EA_TYPE_MOVEA       2
EA_TYPE_MOVEA6      C
EA_TYPE_MOVEM       6
EA_TYPE_QUICK       8
EA_TYPE_ROTATION    B
EA_TYPE_TABLE       18AC
EA_TYPE_TRAP        7
ENDA_ERROR_LARGE    187E
ENDA_ERROR_LESS_THAN_STARTA  188E
ENDA_ERROR_NOT_EVEN  186E
ERROR_MESSAGE_1     1E08
ERROR_MESSAGE_2     1E32
ERROR_MESSAGE_3     1E52
ERROR_MESSAGE_4     1E72
ERROR_MESSAGE_5     1EA1
GET_ENDING_ADDRESS  104A
GET_END_ADDRESS     1DAD
GET_STARTING_ADDRESS  1012
GET_START_ADDRESS   1D7C
ITOA                17F8
ITOA_ADDRESS        1802
ITOA_ADDRESS_LOOP   1810
ITOA_BYTE           1802
ITOA_FINISH         184C
ITOA_HEX2ASCII      182C
ITOA_LETTER         1844
ITOA_LONG           1802
ITOA_LOOP           17FA
ITOA_NUMBER         183C
ITOA_WORD           1802
LF                  A
LINES_PER_SCREEN    1E
NIBBLE1             F000
NIBBLE2             F00
NIBBLE3             F0
NIBBLE4             F
OPCODE0000          1140
OPCODE0001          115A
OPCODE0010          1160
OPCODE0011          117A
OPCODE0100          1194
OPCODE0101          11AE
OPCODE0110          11CA
OPCODE0111          11E4
OPCODE1000          11EA
OPCODE1001          1206
OPCODE1010          120C
OPCODE1011          1212
OPCODE1100          1218
OPCODE1101          1234
OPCODE1110          1250
OPCODE1111          1270
OP_0000_TABLE       1276
OP_0100_TABLE       12D6
OP_0110_TABLE       1336
OP_ADD              16A8
OP_ADDA             16C6
OP_ADDI             13F8
OP_ADDQ             1568
OP_AND              16A8
OP_ANDI             13B4
OP_ASL              16E8
OP_ASR              1706
OP_BEQ              15DC
OP_BRA              15AC
OP_BSR              15C4
OP_CHECK_SIZE       1724
OP_CHECK_SIZE_ADDA  1766
OP_CLR              1568
OP_CMP              1652
OP_CMPI             143C
OP_DATA_CLR         10CA
OP_DATA_CLR_LOOP    10D6
OP_DIVS             1618
OP_DIVU             15FC
OP_EOR              1670
OP_EORI             141A
OP_EXT              1568
OP_FINISH           10C4
OP_JMP              1568
OP_JSR              1568
OP_LEA              1550
OP_LSL              1724
OP_LSR              1724
OP_MOVEAL           1482
OP_MOVEAW           14CE
OP_MOVEB            145E
OP_MOVEL            14AA
OP_MOVEM            152A
OP_MOVEQ            15DC
OP_MOVEW            14F6
OP_MULS             168C
OP_MULU             1670
OP_NOP              151A
OP_NOT              1568
OP_OR               1634
OP_ORI              1396
OP_ROL              1724
OP_ROR              1724
OP_RTE              1568
OP_RTS              1568
OP_SIZE_BYTE        1748
OP_SIZE_LONG        175C
OP_SIZE_WORD        1752
OP_START            1092
OP_STOP             1568
OP_SUB              1634
OP_SUBI             13D6
OP_SUBQ             158A
OP_TABLE            10E0
OP_TRAP             1568
OP_UNSUPPORTED_OPCODE  1724
RIGHT1              1
RIGHT10             A
RIGHT12             C
RIGHT16             10
RIGHT2              2
RIGHT24             18
RIGHT3              3
RIGHT4              4
RIGHT5              5
RIGHT6              6
RIGHT7              7
RIGHT8              8
RIGHT9              9
STACK               A0000
START               1000
STARTA_ERROR_LESS_THAN_ZERO  184E
STARTA_ERROR_NOT_EVEN  185E
START_DECODING      1088
VALIDATE_BEGINNING  184E
WELCOME             1006
WELCOME_MESSAGE     1D5E
