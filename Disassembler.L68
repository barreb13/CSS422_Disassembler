00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/16/2021 12:39:12 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler V1.8
00000000                             3  * Written by : Brent and Parker
00000000                             4  * Date       : 3/16/21
00000000                             5  * Description: Final Project for CSS 422
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  ;************************ Define Constants ********************************* 
00000000  =0000000D                  9  CR                  EQU     $0D     ;carriage return
00000000  =0000000A                 10  LF                  EQU     $0a     ;line feed
00000000  =000A0000                 11  stack               EQU     $000A0000
00000000  =0000000F                 12  lines_per_screen    EQU     15
00000000  =00000040                 13  buffer_size         EQU     64      ;size of buffer
00000000  =0000F000                 14  nibble1             EQU     $F000   ;1st nibble in code (bits 15-12)
00000000  =00000F00                 15  nibble2             EQU     $0F00   ;2nd nibble in code (bits 11-8)
00000000  =000000F0                 16  nibble3             EQU     $00F0   ;3rd nibble in code (bits 7-4)
00000000  =0000000F                 17  nibble4             EQU     $000F   ;4th nibble in code (bits 3-0)
00000000  =00000001                 18  right1              EQU     1       ;shift 1 time
00000000  =00000002                 19  right2              EQU     2       ;shift 2 times
00000000  =00000003                 20  right3              EQU     3       ;shift 3 times to extract src mode
00000000  =00000004                 21  right4              EQU     4       ;shift 4 times to extract 3rd nibble
00000000  =00000005                 22  right5              EQU     5       ;shift 5 times (unused)
00000000  =00000006                 23  right6              EQU     6       ;shift 6 times to extract dst mode
00000000  =00000007                 24  right7              EQU     7       ;shift 7 times
00000000  =00000008                 25  right8              EQU     8       ;shift 8 to extract 2nd nibble
00000000  =00000009                 26  right9              EQU     9       ;shift 9 times to check 2nd nibble?
00000000  =0000000A                 27  right10             EQU     10      ;shift 10
00000000  =0000000C                 28  right12             EQU     12      ;shift 12 to extract 3rd byte
00000000  =00000010                 29  right16             EQU     16      ;shift 16 to extract 2nd byte
00000000  =00000018                 30  right24             EQU     24      ;shift 24 to extract 1st byte
00000000  =000001C0                 31  dest_mode           EQU     $01C0   ; --> 0000 0001 1100 0000 (used for destination in MOVE/MOVEA
00000000  =00000E00                 32  dest_reg            EQU     $0E00   ;destination register (0000 0111 0000 0000)
00000000                            33  
00000000  =00000000                 34  ea_type_immediate   EQU     0
00000000  =00000001                 35  ea_type_move        EQU     1
00000000  =00000002                 36  ea_type_movea       EQU     2
00000000  =0000000C                 37  ea_type_movea6      EQU     12
00000000  =00000003                 38  ea_type_lea         EQU     3
00000000  =00000004                 39  ea_type_destonly    EQU     4
00000000  =00000005                 40  ea_type_ext         EQU     5
00000000  =00000006                 41  ea_type_movem       EQU     6
00000000  =00000007                 42  ea_type_trap        EQU     7
00000000  =00000008                 43  ea_type_quick       EQU     8
00000000  =00000009                 44  ea_type_branch      EQU     9
00000000  =0000000A                 45  ea_type_math        EQU     10
00000000  =0000000B                 46  ea_type_rotation    EQU     11
00000000                            47  
00000000                            48  
00000000                            49  ;flags???
00000000                            50  
00000000                            51  
00000000                            52  
00001000                            53      ORG    $1000
00001000                            54  START:                              ;first instruction of program
00001000  4FF9 000A0000             55      LEA     stack, SP               ;SP @ $A0000
00001006                            56  
00001006                            57  
00001006                            58  
00001006                            59  ;********************************** Welcome Message ******************************************** 
00001006                            60  WELCOME:
00001006  43F9 00002172             61      LEA     welcome_message,A1      ;load the welcome message into A1
0000100C  103C 000E                 62      MOVE.B  #14,D0
00001010  4E4F                      63      TRAP    #15                     ;print contents of welcome_message
00001012                            64  
00001012                            65  
00001012                            66  ;*********************************** Get Starting Address *************************************** 
00001012                            67  GET_STARTING_ADDRESS:
00001012                            68      ;prompt for address
00001012  103C 000E                 69      MOVE.B  #14,D0    
00001016  43F9 00002190             70      LEA     get_start_address,A1    ;load the get_start_address message into A1
0000101C  4E4F                      71      TRAP    #15                     ;print get_start_address
0000101E                            72      
0000101E                            73      ;get user input address, store, and convert
0000101E  43F9 00002306             74      LEA     ascii_start,A1          ;store
00001024  103C 0002                 75      MOVE.B  #2,D0                   ;get user input    
00001028  4E4F                      76      TRAP    #15                     ;another trap to get input
0000102A  4EB9 000017E4             77      JSR     ATOI                    ;address is now in hex format in memory location
00001030                            78      
00001030                            79      
00001030                            80      ;at this point our address is in D4 in hex
00001030                            81      ;check if > 0
00001030  B8BC 00000000             82      CMP.L   #0,D4                       ;compare to D4
00001036  6F00 0878                 83      BLE     STARTA_ERROR_LESS_THAN_ZERO ;branch to ERROR_LESS_THAN_ZERO if less than 0
0000103A                            84      
0000103A                            85      ;?? MOVE.L  (A1),D3
0000103A                            86      
0000103A                            87      ;address is > 0 so check if even / odd
0000103A  E29C                      88      ROR.L   #1,D4
0000103C  6500 0882                 89      BCS     STARTA_ERROR_NOT_EVEN
00001040  E39C                      90      ROL.L   #1,D4    
00001042                            91      
00001042                            92      ;address is > 0 and verified even
00001042  2A39 00002306             93      MOVE.l    (ascii_start),D5      ;load into A5
00001048  2A45                      94      MOVE.l    D5,A5                ;load into A5
0000104A                            95  
0000104A                            96  
0000104A                            97  ;******************************** Get Ending Address ******************************************** 
0000104A                            98  GET_ENDING_ADDRESS:
0000104A                            99      ;prompt for address 
0000104A  103C 000E                100      MOVE.B  #14,D0
0000104E  43F9 000021C1            101      LEA     get_end_address,A1      ;load the get_end_address message into A1  
00001054  4E4F                     102      TRAP    #15                     ;print get_end_address
00001056                           103      
00001056                           104      ;get user input address, store, and convert
00001056  43F9 0000231A            105      LEA     ascii_end,A1            ;store 
0000105C  103C 0002                106      MOVE.B  #2,D0                   ;get user input
00001060  4E4F                     107      TRAP    #15                     ;another trap to get intput
00001062  4EB9 000017E4            108      JSR ATOI
00001068                           109  
00001068                           110      ;perform checks:
00001068                           111      ;1.) even
00001068  E29C                     112      ROR.L   #1,D4
0000106A  6500 0864                113      BCS     ENDA_ERROR_NOT_EVEN
0000106E  E39C                     114      ROL.L   #1,D4    
00001070                           115      
00001070                           116      ;2.) less than 00FFFFFF
00001070  B8BC 00FFFFFF            117      CMP.L   #$00FFFFFF,D4
00001076  6C00 0868                118      BGE     ENDA_ERROR_LARGE    
0000107A                           119      
0000107A                           120      ;3.) greater than starting address
0000107A  BBC4                     121      CMP.L   D4,A5
0000107C  6C00 0872                122      BGE     ENDA_ERROR_LESS_THAN_STARTA
00001080                           123      
00001080                           124      ;good --> store in A6
00001080  2C39 0000231A            125      MOVE.l    (ascii_end),D6      ;load into D6
00001086  2C46                     126      MOVE.l    D6,A6               ;load into A6
00001088                           127  
00001088                           128  
00001088                           129  ;************************************ Main Loop???? ***********************************************
00001088                           130  ;get pointer to first given address
00001088                           131  ;pull hex code from that address and store in A1?
00001088                           132  ;take hex code and go to OP_TABLE
00001088                           133  
00001088                           134  
00001088                           135  ;A5 = starting address
00001088                           136  ;A6 = ending address
00001088                           137  START_DECODING:
00001088  4282                     138      CLR.L   D2                             ;clear screen line counter
0000108A                           139  
0000108A                           140  DECODING_LOOP:
0000108A  4EB9 000010CC            141      JSR     OP_START                       ;get complete line of instruction to decode   
00001090                           142  
00001090                           143      ;RETURN FROM OP FINISH HERE
00001090                           144      
00001090                           145      ;print buffer to screen
00001090  103C 000D                146      MOVE.B  #$0D, D0
00001094  43F9 0000232E            147      LEA     buffer,A1
0000109A  4E4F                     148      TRAP    #15
0000109C                           149      
0000109C                           150      ;check if we have hit ending address (current memory past ending address)
0000109C  BDCD                     151      CMP.L   A5,A6       ;THE SOURCE OPERAND IS SUBTRACTED FROM THE DESTINATION OPERAND (A6-A5)--> (600 - 400)
0000109E  6F00 000E                152      BLE     REPEAT_OR_FINISH
000010A2  5202                     153      ADDI.B  #1,D2
000010A4  B43C 000F                154      CMP.B   #lines_per_screen,D2
000010A8  6C00 000A                155      BGE     FILLED_SCREEN
000010AC  60DC                     156      BRA     DECODING_LOOP
000010AE                           157      
000010AE                           158  REPEAT_OR_FINISH:    
000010AE  4EF9 000010C8            159      JMP     DONE
000010B4                           160  
000010B4                           161  FILLED_SCREEN:
000010B4  103C 000E                162      MOVE.B  #14,D0
000010B8  43F9 000022EE            163      LEA     prompt_enter,A1
000010BE  4E4F                     164      TRAP    #15
000010C0  103C 0005                165      MOVE.B  #$05,D0
000010C4  4E4F                     166      TRAP    #15
000010C6  60C0                     167      BRA     START_DECODING  
000010C8                           168         
000010C8                           169  DONE:
000010C8  FFFF FFFF                170      SIMHALT                                 ; halt simulator
000010CC                           171  
000010CC                           172  
000010CC                           173  
000010CC                           174  ;************************************ OP Stuff *************************************************************************************************************************** 
000010CC                           175  
000010CC                           176  ;A0 = POINTER TO OP_TABLE???
000010CC                           177  ;A1 = 
000010CC                           178  ;A2 = buffer (this is our decoded string that will print to screen)
000010CC                           179  ;A3 = 
000010CC                           180  ;A4 = current memory address for buffer (used for clearing????)
000010CC                           181  ;A5 = starting address / current address in memory
000010CC                           182  ;A6 = ending address
000010CC                           183  ;A7 = SP
000010CC                           184  
000010CC                           185  ;D0
000010CC                           186  ;D1
000010CC                           187  ;D2 = ?
000010CC                           188  ;D3 = buffer size (used for loop = 64)
000010CC                           189  ;D4 = 
000010CC                           190  ;D5
000010CC                           191  ;D6
000010CC                           192  ;D7
000010CC                           193  
000010CC                           194  OP_START
000010CC                           195      ;get complete line? 
000010CC                           196      ;everything happens in here
000010CC                           197      
000010CC  48E7 2000                198      MOVEM.L         D2, -(SP)
000010D0                           199  
000010D0  4EB9 00001108            200      JSR         OP_DATA_CLR         ;clear buffer
000010D6  45F9 0000232E            201      LEA         buffer, A2          ;A2 now points to buffer, which is cleared
000010DC                           202      
000010DC                           203  
000010DC                           204      ;print out current mem address by putting into buffer and then adding a ' ' (tab)
000010DC  7403                     205      MOVE.L      #$0003,D2           ;? BINARY --> 0011 ?
000010DE  4EB9 00001864            206      JSR         ITOA_ADDRESS        ;convert A5 (current address) to ASCII and put in buffer
000010E4  14FC 0009                207      MOVE.B      #$09, (A2)+         ;adds a ' ' to buffer
000010E8                           208      
000010E8                           209      ;at this point buffer has the memory address and a space, ready for op code                     !!TESTED UP UNTIL THIS POINT AND GOOD!!
000010E8                           210      
000010E8  41F9 0000111E            211      LEA         OP_TABLE, A0
000010EE  4280                     212      CLR.L       D0
000010F0  301D                     213      MOVE.W      (A5)+,D0            ;moves opcode from current address into D0
000010F2  2200                     214      MOVE.L      D0,D1               ;should move into D1
000010F4  143C 000C                215      MOVE.B      #right12,D2         ;move immediate value 12 into D2
000010F8  E469                     216      LSR.W       D2,D1               ;shift D1 by 12 bits, leaving just 4 bits (this is our opcode???)
000010FA  C2FC 0006                217      MULU        #6,D1               ;computes opcode table jump displacement
000010FE  4EF0 1000                218      JMP         0(A0,D1)            ;jumps to opcode table entry (A0 = OP_TABLE)
00001102                           219  
00001102                           220  OP_FINISH:
00001102  4CDF 0004                221      MOVEM.L     (SP)+,D2
00001106  4E75                     222      RTS                             ;returns to DECODING_LOOP !?!?!?!?!?
00001108                           223  
00001108                           224  
00001108                           225  OP_DATA_CLR:
00001108  4283                     226      CLR.L       D3                  ; ? What is D3????
0000110A                           227      ;MOVE.B      #buffer_size,D3     ; put 64 into D3
0000110A  163C 0040                228      MOVE.B      #64,D3          ; put 10 into D3                                                                 ;delete after testing and use 64
0000110E  49F9 0000232E            229      LEA         buffer, A4          ; what address register?
00001114                           230  
00001114                           231  OP_DATA_CLR_LOOP:
00001114  18FC 0000                232      MOVE.B      #0, (A4)+
00001118  5343                     233      SUBI        #1, D3
0000111A  6EF8                     234      BGT         OP_DATA_CLR_LOOP
0000111C  4E75                     235      RTS                                 ;need RTS to return
0000111E                           236  
0000111E                           237  
0000111E                           238  ;********************************* jump table ****************************************
0000111E                           239  OP_TABLE:
0000111E  4EF9 0000117E            240      JMP         opcode0000              ;ORI (ANDI, SUBI, ADDI, EORI, CMPI)                                 $0
00001124  4EF9 00001198            241      JMP         opcode0001              ;MOVE.B                                                             $1    
0000112A  4EF9 0000119E            242      JMP         opcode0010              ;MOVEA.L, MOVE.L                                                    $2
00001130  4EF9 000011B8            243      JMP         opcode0011              ;MOVEA.W MOVE.W                                                     $3
00001136  4EF9 000011D2            244      JMP         opcode0100              ;NOP, MOVEM, LEA (CLR, NOT, EXT, TRAP, STOP, RTE, RTS, JSR, JMP     $4
0000113C  4EF9 000011EC            245      JMP         opcode0101              ;ADDQ (SUBQ)                                                        $5
00001142  4EF9 00001208            246      JMP         opcode0110              ;BRA.bw, BSR.bw (BEQ)                                               $6
00001148  4EF9 00001222            247      JMP         opcode0111              ;MOVEQ.l                                                            $7
0000114E  4EF9 00001228            248      JMP         opcode1000              ;DIVU (DIVS, OR)                                                    $8
00001154  4EF9 00001244            249      JMP         opcode1001              ;SUB                                                                $9
0000115A  4EF9 0000124A            250      JMP         opcode1010              ;not assigned                                                       $A
00001160  4EF9 00001250            251      JMP         opcode1011              ;CMP (EOR)                                                          $B
00001166  4EF9 00001256            252      JMP         opcode1100              ;MULU (MULS, AND)                                                   $C
0000116C  4EF9 00001272            253      JMP         opcode1101              ;ADD, ADDA                                                          $D
00001172  4EF9 0000128E            254      JMP         opcode1110              ;ASL, ASR (LSL, LSR, ROL, ROR)                                      $E
00001178  4EF9 000012AE            255      JMP         opcode1111              ;not assigned                                                       $F
0000117E                           256  
0000117E                           257  
0000117E                           258  
0000117E                           259  
0000117E                           260  ;A0 = POINTER TO OP_TABLE???
0000117E                           261  ;A1 = 
0000117E                           262  ;A2 = buffer (this is our decoded string that will print to screen)
0000117E                           263  ;A3 = pointer to op_xxx_table
0000117E                           264  ;A4 = current memory address for buffer (used for clearing????)
0000117E                           265  ;A5 = starting address / current address in memory
0000117E                           266  ;A6 = ending address
0000117E                           267  ;A7 = SP
0000117E                           268  
0000117E                           269  ;D0 = full instruction
0000117E                           270  ;D1 = full instruction for manipulating (temporary)
0000117E                           271  ;D2 = will store immediate value for comparing
0000117E                           272  ;D3 = buffer size (used for loop = 64)
0000117E                           273  ;D4 = 
0000117E                           274  ;D5 = 
0000117E                           275  ;D6 = 
0000117E                           276  ;D7 = 
0000117E                           277  
0000117E                           278  
0000117E                           279  
0000117E                           280  ;ORI (ANDI, SUBI, ADDI, EORI, CMPI)                                 $0
0000117E                           281  opcode0000:                                 
0000117E  2200                     282      MOVE.L      D0,D1                   ;D1 has full instruction
00001180  0241 0F00                283      ANDI.W      #nibble2,D1             ;check bits 11,10,9,8
00001184  143C 0008                284      MOVE.B      #right8, D2             ;store immediate value 8 in D2
00001188  E469                     285      LSR.W       D2, D1                  ;shift to isolate next nibble (bits 11-8)
0000118A  C2FC 0006                286      MULU        #6, D1                  ;multiply by 6 to get displacement
0000118E  47F9 000012B4            287      LEA         OP_0000_TABLE, A3       ;load op_0000_table into address register
00001194  4EF3 1000                288      JMP         0(A3,D1)                ;jumps to opcode table entry (A0 = OP_TABLE)
00001198                           289  
00001198                           290  ;MOVE.B                                                             $1
00001198                           291  opcode0001:
00001198  4EF9 0000149C            292      JMP         OP_MOVEB                ;no need to break down, only MOVE.B
0000119E                           293  
0000119E                           294  
0000119E                           295  ;MOVEA.L, MOVE.L                                                    $2
0000119E                           296  opcode0010:
0000119E  2200                     297      MOVE.L      D0,D1                   ;D1 has full instruction
000011A0  0241 01C0                298      ANDI        #dest_mode, D1          ;0000 0001 1100 0000
000011A4  143C 0006                299      MOVE.B      #right6, D2             ;D2 now 00000111
000011A8  E469                     300      LSR.W       D2, D1                  ;shifting destination mode in D1 to far right by 3
000011AA  B23C 0001                301      CMP.B       #1,D1                   ;does d1 = 001?
000011AE  6700 0310                302      BEQ         OP_MOVEAL               ;if d1 = 001, go to MOVEA
000011B2  4EF9 000014E8            303      JMP         OP_MOVEL                ;else jump to MOVEL
000011B8                           304      
000011B8                           305  
000011B8                           306  
000011B8                           307  
000011B8                           308  ;MOVEA.W MOVE.W                                                     $3
000011B8                           309  opcode0011:
000011B8  2200                     310      MOVE.L      D0,D1                   ;D1 has full instruction
000011BA  0241 01C0                311      ANDI        #dest_mode, D1          ;0000 0001 1100 0000
000011BE  143C 0006                312      MOVE.B      #right6, D2             ;D2 now 00000111
000011C2  E469                     313      LSR.W       D2, D1                  ;shifting destination mode in D1 to far right by 3
000011C4  B23C 0001                314      CMP.B       #1,D1                   ;does d1 = 001?
000011C8  6700 0342                315      BEQ         OP_MOVEAW               ;if d1 = 001, go to MOVEAW
000011CC  4EF9 00001534            316      JMP         OP_MOVEW                ;else jump to MOVEW
000011D2                           317  
000011D2                           318  
000011D2                           319  
000011D2                           320  
000011D2                           321  ;NOP, MOVEM, LEA (CLR, NOT, EXT, TRAP, STOP, RTE, RTS, JSR, JMP)     $4
000011D2                           322  opcode0100:
000011D2  2200                     323      MOVE.L      D0,D1                   ;D1 has full instruction
000011D4  0241 0F00                324      ANDI.W      #nibble2,D1             ;check bits 11,10,9,8
000011D8  143C 0008                325      MOVE.B      #right8, D2             ;store immediate value 8 in D2
000011DC  E469                     326      LSR.W       D2, D1                  ;shift to isolate next nibble (bits 11-8)
000011DE  C2FC 0006                327      MULU        #6, D1                  ;multiply by 6 to get displacement
000011E2  47F9 00001314            328      LEA         OP_0100_TABLE, A3       ;load op_0000_table into address register
000011E8  4EF3 1000                329      JMP         0(A3,D1)                ;jumps to opcode table entry (A0 = OP_TABLE)
000011EC                           330  
000011EC                           331  
000011EC                           332  ;ADDQ (SUBQ)                                                        $5
000011EC                           333  opcode0101:
000011EC                           334      ;JMP         OP_ADDQ
000011EC                           335      
000011EC                           336      
000011EC                           337      ;3/8/21
000011EC  2200                     338      MOVE.L      D0,D1
000011EE  0241 0F00                339      ANDI.W      #nibble2,D1
000011F2  E049                     340      LSR.W       #right8,D1
000011F4  0241 0001                341      ANDI.W      #1,D1
000011F8  B23C 0000                342      CMP.B       #0,D1
000011FC  6700 03A8                343      BEQ         OP_ADDQ
00001200  B23C 0001                344      CMP.B       #1,D1   
00001204  6700 03C2                345      BEQ         OP_SUBQ
00001208                           346      ;HANDLE ERROR
00001208                           347  
00001208                           348  
00001208                           349  ;EA_ADDQ_SUBQ:
00001208                           350  ;    ;CHECK BIT 8 FOR ADDQ OR SUBQ
00001208                           351  ;    CMP.W       #nibble2,D1
00001208                           352  ;    LSR.W       #right7,D1     
00001208                           353  ;    ANDI.W      #1,D1
00001208                           354  ;    CMP.B       #0,D1
00001208                           355  ;    BEQ         EA_ADDQ
00001208                           356  ;    CMP.B       #1,D1  
00001208                           357  ;    BEQ         EA_SUBQ
00001208                           358  ;    ;HANDLE ERROR      
00001208                           359  
00001208                           360  
00001208                           361  ;BRA.bw, BSR.bw (BEQ)                                               $6
00001208                           362  opcode0110:
00001208  2200                     363      MOVE.L      D0,D1                   ;D1 has full instruction
0000120A  0241 0F00                364      ANDI.W      #nibble2,D1             ;check bits 11,10,9,8
0000120E  143C 0008                365      MOVE.B      #right8, D2             ;store immediate value 8 in D2
00001212  E469                     366      LSR.W       D2, D1                  ;shift to isolate next nibble (bits 11-8)
00001214  C2FC 0006                367      MULU        #6, D1                  ;multiply by 6 to get displacement
00001218  47F9 00001374            368      LEA         OP_0110_TABLE, A3       ;load op_0110_table into address register
0000121E  4EF3 1000                369      JMP         0(A3,D1)                ;jumps to opcode table entry (A0 = OP_TABLE)
00001222                           370      
00001222                           371      ;come back and check when debugging. if this does not work then skip jump table
00001222                           372  
00001222                           373  
00001222                           374  ;MOVEQ                                                            $7
00001222                           375  opcode0111:
00001222  4EF9 0000161A            376      JMP         OP_MOVEQ
00001228                           377  
00001228                           378  
00001228                           379  
00001228                           380  ;DIVU (DIVS, OR)                                                    $8
00001228                           381  opcode1000:
00001228  2200                     382      MOVE.L      D0,D1
0000122A  0241 0F00                383      ANDI.W      #nibble2,D1
0000122E  E049                     384      LSR.W       #8,D1
00001230  0201 0001                385      ANDI.B      #1,D1
00001234  B23C 0000                386      CMP.B       #0,D1
00001238  6700 0400                387      BEQ         OP_DIVU
0000123C  B23C 0001                388      CMP.B       #1,D1
00001240  6700 0414                389      BEQ         OP_DIVS
00001244                           390      ;HANDLE ERROR
00001244                           391  
00001244                           392  ;SUB                                                                $9
00001244                           393  opcode1001:
00001244  4EF9 00001672            394      JMP         OP_SUB
0000124A                           395  
0000124A                           396  
0000124A                           397  ;not assigned                                                       $A
0000124A                           398  opcode1010:
0000124A  4EF9 00001762            399      JMP         OP_UNSUPPORTED_OPCODE
00001250                           400  
00001250                           401  
00001250                           402  ;CMP (EOR)                                                          $B
00001250                           403  opcode1011:
00001250  4EF9 00001690            404      JMP         OP_CMP
00001256                           405  
00001256                           406  
00001256                           407  ;MULU (MULS, AND)                                                   $C
00001256                           408  opcode1100:
00001256  2200                     409      MOVE.L      D0,D1
00001258  0241 0F00                410      ANDI.W      #nibble2,D1
0000125C  E049                     411      LSR.W       #8,D1
0000125E  0201 0001                412      ANDI.B      #1,D1
00001262  B23C 0000                413      CMP.B       #0,D1
00001266  6700 0446                414      BEQ         OP_MULU
0000126A  B23C 0001                415      CMP.B       #1,D1
0000126E  6700 045A                416      BEQ         OP_MULS
00001272                           417      ;HANDLE ERROR
00001272                           418  
00001272                           419  ;ADD, ADDA                                                          $D
00001272                           420  opcode1101:
00001272                           421      ;ADD and ADDA differ on bits 6,7... ADD will never be 11 for bits 6,7... use as check
00001272  4241                     422      CLR         D1
00001274  4242                     423      CLR         D2
00001276  2200                     424      MOVE.L      D0,D1
00001278  0241 00F0                425      ANDI.W      #nibble3, D1
0000127C  143C 0006                426      MOVE.B      #right6, D2
00001280  E469                     427      LSR.W       D2,D1
00001282                           428      
00001282                           429      ;at this point we have our bits of interest in bits 1,0
00001282                           430      
00001282  B27C 0003                431      CMP         #3,D1                              ;check if bits == 11
00001286  6700 047C                432      BEQ         OP_ADDA                             ;if yes, branch ADDA
0000128A  6000 045A                433      BRA         OP_ADD                              ;else branch ADD
0000128E                           434  
0000128E                           435  
0000128E                           436  
0000128E                           437  ;ASL, ASR (LSL, LSR, ROL, ROR)                                      $E
0000128E                           438  opcode1110:
0000128E  4241                     439      CLR D1
00001290  4242                     440      CLR D2
00001292  2200                     441      MOVE.L      D0, D1
00001294  0241 0F00                442      ANDI.W      #nibble2, D1
00001298  143C 0008                443      MOVE.B      #right8, D2
0000129C  E469                     444      LSR.W       D2, D1                              ;D1 has 0003 or 0004
0000129E  0241 0001                445      ANDI.W      #0001,D1                           ;isolate single bit
000012A2                           446      
000012A2                           447      ;at this point we have our single bit of interest in bit 0
000012A2                           448      
000012A2  B27C 0000                449      CMP         #0,D1                           ;check if bit == 0
000012A6  6700 049C                450      BEQ         OP_ASR                          ;if yes, branch to ASR
000012AA  6000 047A                451      BRA         OP_ASL                          ;else, branch to ASL
000012AE                           452  
000012AE                           453  
000012AE                           454  ;not assigned                                                       $F
000012AE                           455  opcode1111:
000012AE  4EF9 00001762            456      JMP         OP_UNSUPPORTED_OPCODE
000012B4                           457  
000012B4                           458  
000012B4                           459  ;******************************** OP_XXX_TABLES ************************************
000012B4                           460  ;once in OP_XXX_TABLE , we will use these entries to jump to specific op code to put into buffer
000012B4                           461  
000012B4                           462  OP_0000_TABLE:
000012B4  4EF9 000013D4            463      jmp OP_ORI                                      ;0  
000012BA  4EF9 00001762            464      jmp OP_UNSUPPORTED_OPCODE                       ;1
000012C0  4EF9 000013F2            465      jmp OP_ANDI                                     ;2
000012C6  4EF9 00001762            466      jmp OP_UNSUPPORTED_OPCODE                       ;3
000012CC  4EF9 00001414            467      jmp OP_SUBI                                     ;4
000012D2  4EF9 00001762            468      jmp OP_UNSUPPORTED_OPCODE                       ;5
000012D8  4EF9 00001436            469      jmp OP_ADDI                                     ;6
000012DE  4EF9 00001762            470      jmp OP_UNSUPPORTED_OPCODE                       ;7
000012E4  4EF9 00001762            471      jmp OP_UNSUPPORTED_OPCODE                       ;8
000012EA  4EF9 00001762            472      jmp OP_UNSUPPORTED_OPCODE                       ;9
000012F0  4EF9 00001458            473      jmp OP_EORI                                     ;10
000012F6  4EF9 00001762            474      jmp OP_UNSUPPORTED_OPCODE                       ;11
000012FC  4EF9 0000147A            475      jmp OP_CMPI                                     ;12
00001302  4EF9 00001762            476      jmp OP_UNSUPPORTED_OPCODE                       ;13
00001308  4EF9 00001762            477      jmp OP_UNSUPPORTED_OPCODE                       ;14
0000130E  4EF9 00001762            478      jmp OP_UNSUPPORTED_OPCODE                       ;15
00001314                           479  
00001314                           480  ;OP_0001_TABLE:
00001314                           481  ;    jmp OP_MOVEB
00001314                           482  
00001314                           483  
00001314                           484  ;OP_0010_TABLE:
00001314                           485  ;   jmp OP_MOVEAL
00001314                           486  ;   jmp OP_MOVEL
00001314                           487  
00001314                           488  
00001314                           489  ;OP_0011_TABLE:
00001314                           490  
00001314                           491  
00001314                           492  
00001314                           493  ;NOP, MOVEM, LEA (CLR, NOT, EXT, TRAP, STOP, RTE, RTS, JSR, JMP     $4
00001314                           494  ;NOP    1110
00001314                           495  ;MOVEM  1D00
00001314                           496  ;LEA    AN1
00001314                           497  OP_0100_TABLE:
00001314  4EF9 00001762            498      jmp OP_UNSUPPORTED_OPCODE                           ;0  
0000131A  4EF9 0000158E            499      jmp OP_LEA                                          ;1      (address 0001)
00001320  4EF9 00001762            500      jmp OP_UNSUPPORTED_OPCODE                           ;2
00001326  4EF9 0000158E            501      jmp OP_LEA                                          ;3      (address 0011)
0000132C  4EF9 00001762            502      jmp OP_UNSUPPORTED_OPCODE                           ;4 
00001332  4EF9 0000158E            503      jmp OP_LEA                                          ;5      (address 0101)
00001338  4EF9 00001762            504      jmp OP_UNSUPPORTED_OPCODE                           ;6 
0000133E  4EF9 0000158E            505      jmp OP_LEA                                          ;7      (address 0111) 
00001344  4EF9 00001568            506      jmp OP_MOVEM                                        ;8                          ;jmp OP_MOVEM_R2M
0000134A  4EF9 0000158E            507      jmp OP_LEA                                          ;9      (address 1001) 
00001350  4EF9 00001762            508      jmp OP_UNSUPPORTED_OPCODE                           ;10 
00001356  4EF9 0000158E            509      jmp OP_LEA                                          ;11     (address 1011) 
0000135C  4EF9 00001568            510      jmp OP_MOVEM                                        ;12                         ;jmp OP_MOVEM_M2R    
00001362  4EF9 0000158E            511      jmp OP_LEA                                          ;13     (address 1101)
00001368  4EF9 00001558            512      jmp OP_NOP                                          ;14
0000136E  4EF9 0000158E            513      jmp OP_LEA                                          ;15     (address 1111)
00001374                           514  
00001374                           515  
00001374                           516  ;OP_0101_TABLE:
00001374                           517  
00001374                           518  
00001374                           519  
00001374                           520  ;BRA nibble 2 = 0000 (0) , BSR nibble 2 = 0001 (1)
00001374                           521  OP_0110_TABLE:
00001374  4EF9 000015EA            522      jmp OP_BRA                                          ;0
0000137A  4EF9 00001602            523      jmp OP_BSR                                          ;1
00001380  4EF9 00001762            524      jmp OP_UNSUPPORTED_OPCODE                           ;2
00001386  4EF9 00001762            525      jmp OP_UNSUPPORTED_OPCODE                           ;3
0000138C  4EF9 00001762            526      jmp OP_UNSUPPORTED_OPCODE                           ;4
00001392  4EF9 00001762            527      jmp OP_UNSUPPORTED_OPCODE                           ;5
00001398  4EF9 00001762            528      jmp OP_UNSUPPORTED_OPCODE                           ;6
0000139E  4EF9 00001762            529      jmp OP_UNSUPPORTED_OPCODE                           ;7
000013A4  4EF9 00001762            530      jmp OP_UNSUPPORTED_OPCODE                           ;8
000013AA  4EF9 00001762            531      jmp OP_UNSUPPORTED_OPCODE                           ;9
000013B0  4EF9 00001762            532      jmp OP_UNSUPPORTED_OPCODE                           ;10
000013B6  4EF9 00001762            533      jmp OP_UNSUPPORTED_OPCODE                           ;11
000013BC  4EF9 00001762            534      jmp OP_UNSUPPORTED_OPCODE                           ;12
000013C2  4EF9 00001762            535      jmp OP_UNSUPPORTED_OPCODE                           ;13
000013C8  4EF9 00001762            536      jmp OP_UNSUPPORTED_OPCODE                           ;14
000013CE  4EF9 00001762            537      jmp OP_UNSUPPORTED_OPCODE                           ;15
000013D4                           538  
000013D4                           539  
000013D4                           540  ;OP_0111_TABLE:
000013D4                           541  ;implement later if needed
000013D4                           542  
000013D4                           543  
000013D4                           544  ;OP_1000_TABLE:
000013D4                           545  ;implement later if needed
000013D4                           546  
000013D4                           547  
000013D4                           548  ;OP_1001_TABLE:
000013D4                           549  ;implement later if needed
000013D4                           550  
000013D4                           551  
000013D4                           552  ;OP_1010_TABLE:
000013D4                           553  ;implement later if needed
000013D4                           554  
000013D4                           555  
000013D4                           556  ;OP_1011_TABLE:
000013D4                           557  ;implement later if needed
000013D4                           558  
000013D4                           559  
000013D4                           560  ;OP_1100_TABLE:
000013D4                           561  ;implement later if needed
000013D4                           562  
000013D4                           563  
000013D4                           564  ;OP_1101_TABLE:
000013D4                           565  ;implement later if needed
000013D4                           566  
000013D4                           567  
000013D4                           568  ;OP_1110_TABLE:
000013D4                           569  ;implement later if needed
000013D4                           570  
000013D4                           571  
000013D4                           572  ;OP_1111_TABLE:
000013D4                           573  ;implement later if needed
000013D4                           574  
000013D4                           575  
000013D4                           576  
000013D4                           577  
000013D4                           578  ;******************************** OP_INSTRUCTION_XXXX******************************************
000013D4                           579  ;this is where we are putting ascii text into buffer
000013D4                           580  
000013D4                           581  
000013D4                           582  OP_ORI:
000013D4  14FC 004F                583      MOVE.B  #'O', (A2)+
000013D8  14FC 0052                584      MOVE.B  #'R', (A2)+
000013DC  14FC 0049                585      MOVE.B  #'I', (A2)+
000013E0                           586      
000013E0                           587      ;call OP_CHECK_SIZE to append a .b/.w/.l
000013E0  4EB9 00001762            588      JSR     OP_CHECK_SIZE
000013E6                           589      
000013E6  7200                     590      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
000013E8                           591  
000013E8  4EB9 00001900            592      JSR     EA_START
000013EE  4EF8 1102                593      JMP     OP_FINISH
000013F2                           594  
000013F2                           595  OP_ANDI:  ;(optional)
000013F2  14FC 0041                596      MOVE.B  #'A', (A2)+
000013F6  14FC 004E                597      MOVE.B  #'N', (A2)+
000013FA  14FC 0044                598      MOVE.B  #'D', (A2)+
000013FE  14FC 0049                599      MOVE.B  #'I', (A2)+
00001402                           600      
00001402                           601      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001402  4EB9 00001762            602      JSR     OP_CHECK_SIZE
00001408                           603      
00001408  7200                     604      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
0000140A                           605  
0000140A  4EB9 00001900            606      JSR     EA_START
00001410  4EF8 1102                607      JMP     OP_FINISH
00001414                           608  
00001414                           609  
00001414                           610  OP_SUBI:  ;(optional)
00001414  14FC 0053                611      MOVE.B  #'S', (A2)+
00001418  14FC 0055                612      MOVE.B  #'U', (A2)+
0000141C  14FC 0042                613      MOVE.B  #'B', (A2)+
00001420  14FC 0049                614      MOVE.B  #'I', (A2)+
00001424                           615      
00001424                           616      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001424  4EB9 00001762            617      JSR     OP_CHECK_SIZE
0000142A                           618      
0000142A  7200                     619      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
0000142C                           620  
0000142C  4EB9 00001900            621      JSR     EA_START
00001432  4EF8 1102                622      JMP     OP_FINISH
00001436                           623  
00001436                           624  
00001436                           625  OP_ADDI:  ;(optional)
00001436  14FC 0041                626      MOVE.B  #'A', (A2)+
0000143A  14FC 0044                627      MOVE.B  #'D', (A2)+
0000143E  14FC 0044                628      MOVE.B  #'D', (A2)+
00001442  14FC 0049                629      MOVE.B  #'I', (A2)+
00001446                           630      
00001446                           631      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001446  4EB9 00001762            632      JSR     OP_CHECK_SIZE
0000144C                           633     
0000144C  7200                     634      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
0000144E                           635  
0000144E  4EB9 00001900            636      JSR     EA_START
00001454  4EF8 1102                637      JMP     OP_FINISH
00001458                           638  
00001458                           639  
00001458                           640  OP_EORI:  ;(optional)
00001458  14FC 0045                641      MOVE.B  #'E', (A2)+
0000145C  14FC 004F                642      MOVE.B  #'O', (A2)+
00001460  14FC 0052                643      MOVE.B  #'R', (A2)+
00001464  14FC 0049                644      MOVE.B  #'I', (A2)+
00001468                           645      
00001468                           646      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001468  4EB9 00001762            647      JSR     OP_CHECK_SIZE
0000146E                           648      
0000146E  7200                     649      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
00001470                           650      
00001470  4EB9 00001900            651      JSR     EA_START
00001476  4EF8 1102                652      JMP     OP_FINISH
0000147A                           653  
0000147A                           654  
0000147A                           655  OP_CMPI:  ;(optional)
0000147A  14FC 0043                656      MOVE.B  #'C', (A2)+
0000147E  14FC 004D                657      MOVE.B  #'M', (A2)+
00001482  14FC 0050                658      MOVE.B  #'P', (A2)+
00001486  14FC 0049                659      MOVE.B  #'I', (A2)+
0000148A                           660      
0000148A                           661      
0000148A                           662      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000148A  4EB9 00001762            663      JSR     OP_CHECK_SIZE
00001490                           664  
00001490  7200                     665      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
00001492                           666  
00001492  4EB9 00001900            667      JSR     EA_START
00001498  4EF8 1102                668      JMP     OP_FINISH
0000149C                           669  
0000149C                           670  
0000149C                           671  OP_MOVEB:
0000149C  14FC 004D                672      MOVE.B  #'M', (A2)+
000014A0  14FC 004F                673      MOVE.B  #'O', (A2)+
000014A4  14FC 0056                674      MOVE.B  #'V', (A2)+
000014A8  14FC 0045                675      MOVE.B  #'E', (A2)+
000014AC  14FC 002E                676      MOVE.B  #'.', (A2)+
000014B0  14FC 0042                677      MOVE.B  #'B', (A2)+
000014B4                           678      
000014B4  7201                     679      MOVE.L  #ea_type_move, D1                   ;preps for EA_START and puts 1 into D1
000014B6                           680      
000014B6  4EB9 00001900            681      JSR     EA_START
000014BC  4EF8 1102                682      JMP     OP_FINISH
000014C0                           683  
000014C0                           684  OP_MOVEAL:
000014C0  14FC 004D                685      MOVE.B  #'M', (A2)+
000014C4  14FC 004F                686      MOVE.B  #'O', (A2)+
000014C8  14FC 0056                687      MOVE.B  #'V', (A2)+
000014CC  14FC 0045                688      MOVE.B  #'E', (A2)+
000014D0  14FC 0041                689      MOVE.B  #'A', (A2)+
000014D4  14FC 002E                690      MOVE.B  #'.', (A2)+
000014D8  14FC 004C                691      MOVE.B  #'L', (A2)+
000014DC                           692      
000014DC  7202                     693      MOVE.L  #ea_type_movea, D1                   ;preps for EA_START and puts 2 into D1
000014DE                           694      
000014DE  4EB9 00001900            695      JSR     EA_START
000014E4  4EF8 1102                696      JMP     OP_FINISH
000014E8                           697  
000014E8                           698  OP_MOVEL:
000014E8  14FC 004D                699      MOVE.B  #'M', (A2)+
000014EC  14FC 004F                700      MOVE.B  #'O', (A2)+
000014F0  14FC 0056                701      MOVE.B  #'V', (A2)+
000014F4  14FC 0045                702      MOVE.B  #'E', (A2)+
000014F8  14FC 002E                703      MOVE.B  #'.', (A2)+
000014FC  14FC 004C                704      MOVE.B  #'L', (A2)+
00001500                           705      
00001500  7201                     706      MOVE.L  #ea_type_move, D1                   ;preps for EA_START and puts 1 into D1
00001502                           707      
00001502  4EB9 00001900            708      JSR     EA_START
00001508  4EF8 1102                709      JMP     OP_FINISH
0000150C                           710  
0000150C                           711  
0000150C                           712  OP_MOVEAW:
0000150C  14FC 004D                713      MOVE.B  #'M', (A2)+
00001510  14FC 004F                714      MOVE.B  #'O', (A2)+
00001514  14FC 0056                715      MOVE.B  #'V', (A2)+
00001518  14FC 0045                716      MOVE.B  #'E', (A2)+
0000151C  14FC 0041                717      MOVE.B  #'A', (A2)+
00001520  14FC 002E                718      MOVE.B  #'.', (A2)+
00001524  14FC 0057                719      MOVE.B  #'W', (A2)+
00001528                           720      
00001528  7202                     721      MOVE.L  #ea_type_movea, D1                   ;preps for EA_START and puts 2 into D1
0000152A                           722      
0000152A  4EB9 00001900            723      JSR     EA_START
00001530  4EF8 1102                724      JMP     OP_FINISH
00001534                           725  
00001534                           726  
00001534                           727  OP_MOVEW:
00001534  14FC 004D                728      MOVE.B  #'M', (A2)+
00001538  14FC 004F                729      MOVE.B  #'O', (A2)+
0000153C  14FC 0056                730      MOVE.B  #'V', (A2)+
00001540  14FC 0045                731      MOVE.B  #'E', (A2)+
00001544  14FC 002E                732      MOVE.B  #'.', (A2)+
00001548  14FC 0057                733      MOVE.B  #'W', (A2)+
0000154C                           734      
0000154C  7201                     735      MOVE.L  #ea_type_move, D1                   ;preps for EA_START and puts 1 into D1
0000154E                           736      
0000154E  4EB9 00001900            737      JSR     EA_START
00001554  4EF8 1102                738      JMP     OP_FINISH
00001558                           739  
00001558                           740  
00001558                           741  OP_NOP:
00001558  14FC 004E                742      MOVE.B  #'N', (A2)+
0000155C  14FC 004F                743      MOVE.B  #'O', (A2)+
00001560  14FC 0050                744      MOVE.B  #'P', (A2)+
00001564                           745      
00001564                           746      ;NO EA
00001564  4EF8 1102                747      JMP     OP_FINISH
00001568                           748  
00001568                           749  
00001568                           750  OP_MOVEM:
00001568                           751      ;see movemd2r or movemr2d... see below at bottom ?????
00001568                           752      
00001568  14FC 004D                753      MOVE.B  #'M', (A2)+
0000156C  14FC 004F                754      MOVE.B  #'O', (A2)+
00001570  14FC 0056                755      MOVE.B  #'V', (A2)+
00001574  14FC 0045                756      MOVE.B  #'E', (A2)+
00001578  14FC 004D                757      MOVE.B  #'M', (A2)+
0000157C                           758      
0000157C                           759      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000157C  4EB9 00001786            760      JSR     OP_CHECK_SIZE_MOVEM
00001582                           761      
00001582  7206                     762      MOVE.L  #ea_type_movem, D1                   ;preps for EA_START and puts 6 into D1
00001584                           763      
00001584  4EB9 00001900            764      JSR     EA_START
0000158A  4EF8 1102                765      JMP     OP_FINISH
0000158E                           766  
0000158E                           767  OP_LEA:
0000158E  14FC 004C                768      MOVE.B  #'L', (A2)+
00001592  14FC 0045                769      MOVE.B  #'E', (A2)+
00001596  14FC 0041                770      MOVE.B  #'A', (A2)+
0000159A                           771      
0000159A  7203                     772      MOVE.L  #ea_type_lea, D1                   ;preps for EA_START and puts 3 into D1
0000159C                           773      
0000159C  4EB9 00001900            774      JSR     EA_START
000015A2  4EF8 1102                775      JMP     OP_FINISH
000015A6                           776  
000015A6                           777  OP_CLR:  ;(optional)
000015A6                           778  ;implement later if needed
000015A6                           779  
000015A6                           780  
000015A6                           781  OP_NOT:  ;(optional)
000015A6                           782  ;implement later if needed
000015A6                           783  
000015A6                           784  
000015A6                           785  OP_EXT:  ;(optional)
000015A6                           786  ;implement later if needed
000015A6                           787  
000015A6                           788  
000015A6                           789  OP_TRAP:  ;(optional)
000015A6                           790  ;implement later if needed
000015A6                           791  
000015A6                           792   
000015A6                           793  OP_STOP:  ;(optional)
000015A6                           794  ;implement later if needed
000015A6                           795  
000015A6                           796  
000015A6                           797  OP_RTE:  ;(optional)
000015A6                           798  ;implement later if needed
000015A6                           799  
000015A6                           800  
000015A6                           801  OP_RTS:  ;(optional)
000015A6                           802  ;implement later if needed
000015A6                           803  
000015A6                           804  
000015A6                           805  OP_JSR:  ;(optional)
000015A6                           806  ;implement later if needed
000015A6                           807  
000015A6                           808  
000015A6                           809  OP_JMP:  ;(optional)
000015A6                           810  ;implement later if needed
000015A6                           811  
000015A6                           812  
000015A6                           813  OP_ADDQ:
000015A6  14FC 0041                814      MOVE.B  #'A', (A2)+
000015AA  14FC 0044                815      MOVE.B  #'D', (A2)+
000015AE  14FC 0044                816      MOVE.B  #'D', (A2)+
000015B2  14FC 0051                817      MOVE.B  #'Q', (A2)+
000015B6                           818      
000015B6                           819      ;call OP_CHECK_SIZE to append a .b/.w/.l
000015B6  4EB9 00001762            820      JSR     OP_CHECK_SIZE
000015BC                           821  
000015BC  7208                     822      MOVE.L  #ea_type_quick, D1                   ;preps for EA_START and puts 8 into D1
000015BE                           823  
000015BE  4EB9 00001900            824      JSR     EA_START
000015C4  4EF8 1102                825      JMP     OP_FINISH
000015C8                           826  
000015C8                           827  OP_SUBQ:  ;(optional)
000015C8  14FC 0053                828      MOVE.B  #'S', (A2)+
000015CC  14FC 0055                829      MOVE.B  #'U', (A2)+
000015D0  14FC 0042                830      MOVE.B  #'B', (A2)+
000015D4  14FC 0051                831      MOVE.B  #'Q', (A2)+
000015D8                           832      
000015D8                           833      ;call OP_CHECK_SIZE to append a .b/.w/.l
000015D8  4EB9 00001762            834      JSR     OP_CHECK_SIZE
000015DE                           835      
000015DE  7208                     836      MOVE.L  #ea_type_quick, D1                   ;preps for EA_START and puts 8 into D1
000015E0                           837  
000015E0  4EB9 00001900            838      JSR     EA_START
000015E6  4EF8 1102                839      JMP     OP_FINISH
000015EA                           840  
000015EA                           841  OP_BRA:                                     ;???? DO WE DEFINE SIZE HERE OR AFTER????
000015EA  14FC 0042                842      MOVE.B  #'B', (A2)+
000015EE  14FC 0052                843      MOVE.B  #'R', (A2)+
000015F2  14FC 0041                844      MOVE.B  #'A', (A2)+
000015F6                           845  
000015F6  7209                     846      MOVE.L  #ea_type_branch,D1
000015F8                           847      
000015F8  4EB9 00001900            848      JSR     EA_START
000015FE  4EF8 1102                849      JMP     OP_FINISH
00001602                           850  
00001602                           851  
00001602                           852  OP_BSR:
00001602  14FC 0042                853      MOVE.B  #'B', (A2)+
00001606  14FC 0053                854      MOVE.B  #'S', (A2)+
0000160A  14FC 0052                855      MOVE.B  #'R', (A2)+
0000160E                           856      
0000160E  7209                     857      MOVE.L  #ea_type_branch,D1
00001610                           858      
00001610  4EB9 00001900            859      JSR     EA_START                        ;DO WE HAVE EA?
00001616  4EF8 1102                860      JMP     OP_FINISH
0000161A                           861  
0000161A                           862  
0000161A                           863  OP_BEQ:
0000161A                           864  ;implement later if needed
0000161A                           865  
0000161A                           866  
0000161A                           867  OP_MOVEQ:
0000161A  14FC 004D                868      MOVE.B  #'M', (A2)+
0000161E  14FC 004F                869      MOVE.B  #'O', (A2)+
00001622  14FC 0056                870      MOVE.B  #'V', (A2)+
00001626  14FC 0045                871      MOVE.B  #'E', (A2)+
0000162A  14FC 0051                872      MOVE.B  #'Q', (A2)+
0000162E                           873      
0000162E                           874      ;DO WE NEED A .L ?
0000162E                           875      
0000162E  7208                     876      MOVE.L  #ea_type_quick, D1                   ;preps for EA_START and puts 8 into D1
00001630                           877      
00001630  4EB9 00001900            878      JSR     EA_START
00001636  4EF8 1102                879      JMP     OP_FINISH
0000163A                           880  
0000163A                           881  
0000163A                           882  OP_DIVU:
0000163A  14FC 0044                883      MOVE.B  #'D', (A2)+
0000163E  14FC 0049                884      MOVE.B  #'I', (A2)+
00001642  14FC 0056                885      MOVE.B  #'V', (A2)+
00001646  14FC 0055                886      MOVE.B  #'U', (A2)+
0000164A                           887    
0000164A  720A                     888      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
0000164C                           889    
0000164C  4EB9 00001900            890      JSR     EA_START
00001652  4EF8 1102                891      JMP     OP_FINISH    
00001656                           892  
00001656                           893  
00001656                           894  OP_DIVS  ;(optional)
00001656  14FC 0044                895      MOVE.B  #'D', (A2)+
0000165A  14FC 0049                896      MOVE.B  #'I', (A2)+
0000165E  14FC 0056                897      MOVE.B  #'V', (A2)+
00001662  14FC 0053                898      MOVE.B  #'S', (A2)+
00001666                           899    
00001666  720A                     900      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
00001668                           901    
00001668  4EB9 00001900            902      JSR     EA_START
0000166E  4EF8 1102                903      JMP     OP_FINISH   
00001672                           904  
00001672                           905  
00001672                           906  OP_OR  ;(optional)
00001672                           907  ;implement later if needed
00001672                           908  
00001672                           909  
00001672                           910  OP_SUB:
00001672  14FC 0053                911      MOVE.B  #'S', (A2)+
00001676  14FC 0055                912      MOVE.B  #'U', (A2)+
0000167A  14FC 0042                913      MOVE.B  #'B', (A2)+
0000167E                           914  
0000167E  4EB9 00001762            915      JSR     OP_CHECK_SIZE                       ;call OP_CHECK_SIZE to append a .b/.w/.l
00001684                           916      
00001684  720A                     917      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
00001686                           918      
00001686                           919      ;at this point it will return with SUB.X and go to EA_START
00001686  4EB9 00001900            920      JSR     EA_START
0000168C  4EF8 1102                921      JMP     OP_FINISH    
00001690                           922  
00001690                           923  
00001690                           924  OP_CMP:
00001690  14FC 0043                925      MOVE.B  #'C', (A2)+
00001694  14FC 004D                926      MOVE.B  #'M', (A2)+
00001698  14FC 0050                927      MOVE.B  #'P', (A2)+
0000169C                           928    
0000169C  4EB9 00001762            929      JSR     OP_CHECK_SIZE                       ;call OP_CHECK_SIZE to append a .b/.w/.l  
000016A2                           930      
000016A2  720A                     931      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
000016A4                           932      
000016A4                           933      ;at this point it will return with SUB.X and go to EA_START
000016A4  4EB9 00001900            934      JSR     EA_START
000016AA  4EF8 1102                935      JMP     OP_FINISH    
000016AE                           936      
000016AE                           937  
000016AE                           938  
000016AE                           939  OP_EOR:  ;(optional)
000016AE                           940  ;implement later if needed
000016AE                           941  
000016AE                           942  
000016AE                           943  OP_MULU:
000016AE  14FC 004D                944      MOVE.B  #'M', (A2)+
000016B2  14FC 0055                945      MOVE.B  #'U', (A2)+
000016B6  14FC 004C                946      MOVE.B  #'L', (A2)+
000016BA  14FC 0055                947      MOVE.B  #'U', (A2)+
000016BE                           948  
000016BE  720A                     949      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
000016C0                           950      
000016C0  4EB9 00001900            951      JSR     EA_START
000016C6  4EF8 1102                952      JMP     OP_FINISH    
000016CA                           953  
000016CA                           954  OP_MULS:  ;(optional)
000016CA  14FC 004D                955      MOVE.B  #'M', (A2)+
000016CE  14FC 0055                956      MOVE.B  #'U', (A2)+
000016D2  14FC 004C                957      MOVE.B  #'L', (A2)+
000016D6  14FC 0053                958      MOVE.B  #'S', (A2)+
000016DA                           959  
000016DA  720A                     960      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
000016DC                           961  
000016DC  4EB9 00001900            962      JSR     EA_START
000016E2  4EF8 1102                963      JMP     OP_FINISH
000016E6                           964  
000016E6                           965  
000016E6                           966  OP_AND:  ;(optional)
000016E6                           967  ;implement later if needed
000016E6                           968  
000016E6                           969  
000016E6                           970  OP_ADD:
000016E6  14FC 0041                971      MOVE.B  #'A', (A2)+
000016EA  14FC 0044                972      MOVE.B  #'D', (A2)+
000016EE  14FC 0044                973      MOVE.B  #'D', (A2)+
000016F2                           974  
000016F2                           975      ;call OP_CHECK_SIZE to append a .b/.w/.l
000016F2  4EB9 00001762            976      JSR     OP_CHECK_SIZE
000016F8                           977      
000016F8  720A                     978      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
000016FA                           979  
000016FA  4EB9 00001900            980      JSR     EA_START
00001700  4EF8 1102                981      JMP     OP_FINISH
00001704                           982  
00001704                           983  OP_ADDA:
00001704  14FC 0041                984      MOVE.B  #'A', (A2)+
00001708  14FC 0044                985      MOVE.B  #'D', (A2)+
0000170C  14FC 0044                986      MOVE.B  #'D', (A2)+
00001710  14FC 0041                987      MOVE.B  #'A', (A2)+
00001714                           988  
00001714                           989      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001714  4EB9 000017C8            990      JSR     OP_CHECK_SIZE_ADDA
0000171A                           991      
0000171A  720A                     992      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
0000171C                           993  
0000171C  4EB9 00001900            994      JSR     EA_START
00001722  4EF8 1102                995      JMP     OP_FINISH
00001726                           996  
00001726                           997  
00001726                           998  OP_ASL:
00001726  14FC 0041                999      MOVE.B  #'A', (A2)+
0000172A  14FC 0053               1000      MOVE.B  #'S', (A2)+
0000172E  14FC 004C               1001      MOVE.B  #'L', (A2)+
00001732                          1002  
00001732                          1003      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001732  4EB9 00001762           1004      JSR     OP_CHECK_SIZE
00001738                          1005      
00001738  720B                    1006      MOVE.L  #ea_type_rotation, D1                   ;preps for EA_START and puts 10 into D1
0000173A                          1007      
0000173A  4EB9 00001900           1008      JSR     EA_START
00001740  4EF8 1102               1009      JMP     OP_FINISH
00001744                          1010  
00001744                          1011  
00001744                          1012  OP_ASR:
00001744  14FC 0041               1013      MOVE.B  #'A', (A2)+
00001748  14FC 0053               1014      MOVE.B  #'S', (A2)+
0000174C  14FC 0052               1015      MOVE.B  #'R', (A2)+
00001750                          1016  
00001750                          1017      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001750  4EB9 00001762           1018      JSR     OP_CHECK_SIZE
00001756                          1019      
00001756  720B                    1020      MOVE.L  #ea_type_rotation, D1                   ;preps for EA_START and puts 10 into D1
00001758                          1021  
00001758  4EB9 00001900           1022      JSR     EA_START
0000175E  4EF8 1102               1023      JMP     OP_FINISH
00001762                          1024  
00001762                          1025  OP_LSL:  ;(optional)
00001762                          1026  ;implement later if needed
00001762                          1027  
00001762                          1028  
00001762                          1029  
00001762                          1030  OP_LSR:  ;(optional)
00001762                          1031  ;implement later if needed
00001762                          1032  
00001762                          1033  
00001762                          1034  
00001762                          1035  OP_ROL:  ;(optional)
00001762                          1036  ;implement later if needed
00001762                          1037  
00001762                          1038  
00001762                          1039  
00001762                          1040  OP_ROR:  ;(optional)
00001762                          1041  ;implement later if needed
00001762                          1042  
00001762                          1043  
00001762                          1044  
00001762                          1045  ;OP_MOVEM_R2M:
00001762                          1046  ;    MOVE.B  #'M', (A2)+
00001762                          1047  ;    MOVE.B  #'O', (A2)+
00001762                          1048  ;    MOVE.B  #'V', (A2)+
00001762                          1049  ;    MOVE.B  #'E', (A2)+
00001762                          1050  ;    MOVE.B  #'M', (A2)+
00001762                          1051      
00001762                          1052  ;    ;call OP_CHECK_SIZE to append a .b/.w/.l
00001762                          1053  ;    JSR     OP_CHECK_SIZE
00001762                          1054      
00001762                          1055  ;    MOVE.L  #ea_type_movem, D1                   ;preps for EA_START and puts 6 into D1
00001762                          1056      
00001762                          1057  ;    JSR     EA_START
00001762                          1058  ;    JMP     OP_FINISH
00001762                          1059  
00001762                          1060  
00001762                          1061  ;OP_MOVEM_M2R:
00001762                          1062  ;    MOVE.B  #'M', (A2)+
00001762                          1063  ;    MOVE.B  #'O', (A2)+
00001762                          1064  ;    MOVE.B  #'V', (A2)+
00001762                          1065  ;    MOVE.B  #'E', (A2)+
00001762                          1066  ;    MOVE.B  #'M', (A2)+
00001762                          1067      
00001762                          1068  ;    ;call OP_CHECK_SIZE to append a .b/.w/.l
00001762                          1069  ;    JSR     OP_CHECK_SIZE
00001762                          1070      
00001762                          1071  ;    MOVE.L  #ea_type_movem, D1                   ;preps for EA_START and puts 6 into D1
00001762                          1072      
00001762                          1073  ;    JSR     EA_START
00001762                          1074  ;    JMP     OP_FINISH
00001762                          1075  
00001762                          1076  
00001762                          1077  OP_UNSUPPORTED_OPCODE:
00001762                          1078  ;fill out
00001762                          1079  
00001762                          1080  ;D0 HAS COMPLETE INSTRUCTION
00001762                          1081  OP_CHECK_SIZE:
00001762  4241                    1082      CLR     D1                                  ;CLEAR D1
00001764  4242                    1083      CLR     D2                                  ;clear D2
00001766  2200                    1084      MOVE.L  D0,D1                               ;D0 and D1 both have complete opcode
00001768  0241 00F0               1085      ANDI.W  #nibble3,D1                         ;isolate nibble 3
0000176C  143C 0006               1086      MOVE.B  #right6, D2                         ;putting immediate value 6 in D2
00001770  E469                    1087      LSR.W   D2, D1                              ;bits 7,6 --> bits 1,0
00001772                          1088      
00001772                          1089       
00001772  B27C 0000               1090      CMP     #00,D1                              ;compare bits 1,0 to 00
00001776  6700 0032               1091      BEQ     OP_SIZE_BYTE                        ;if bits == 00, size byte
0000177A  B27C 0001               1092      CMP     #01,D1                              ;compare bits to 01
0000177E  6700 0034               1093      BEQ     OP_SIZE_WORD                        ;if bits == 01, size word
00001782  6000 003A               1094      BRA     OP_SIZE_LONG                        ;else size long
00001786                          1095  
00001786                          1096  
00001786                          1097  OP_CHECK_SIZE_MOVEM:
00001786  4241                    1098      CLR     D1                                  ;CLEAR D1
00001788  4242                    1099      CLR     D2                                  ;clear D2
0000178A  2200                    1100      MOVE.L  D0,D1                               ;D0 and D1 both have complete opcode
0000178C  0241 00F0               1101      ANDI.W  #nibble3,D1                         ;isolate nibble 3
00001790  143C 0006               1102      MOVE.B  #right6, D2                         ;putting immediate value 6 in D2
00001794  E469                    1103      LSR.W   D2, D1                              ;bits 7,6 --> bits 1,0
00001796                          1104      
00001796  0241 0001               1105      ANDI.W  #1,D1    
0000179A  B27C 0000               1106      CMP     #0,D1                              ;compare bits 1,0 to 00
0000179E  6700 0014               1107      BEQ     OP_SIZE_WORD                        ;if bits == 00, size WORD
000017A2  B27C 0001               1108      CMP     #1,D1                              ;compare bits to 01
000017A6  6700 0016               1109      BEQ     OP_SIZE_LONG                       ;if bits == 01, size LONG
000017AA                          1110  
000017AA                          1111  OP_SIZE_BYTE
000017AA  14FC 002E               1112      MOVE.B  #'.', (A2)+
000017AE  14FC 0042               1113      MOVE.B  #'B', (A2)+
000017B2  4E75                    1114      RTS
000017B4                          1115  
000017B4                          1116  OP_SIZE_WORD
000017B4  14FC 002E               1117      MOVE.B  #'.', (A2)+
000017B8  14FC 0057               1118      MOVE.B  #'W', (A2)+
000017BC  4E75                    1119      RTS
000017BE                          1120  
000017BE                          1121  
000017BE                          1122  OP_SIZE_LONG
000017BE  14FC 002E               1123      MOVE.B  #'.', (A2)+
000017C2  14FC 004C               1124      MOVE.B  #'L', (A2)+
000017C6  4E75                    1125      RTS
000017C8                          1126  
000017C8                          1127  
000017C8                          1128  OP_CHECK_SIZE_ADDA:
000017C8  4241                    1129      CLR     D1                                  ;CLEAR D1
000017CA  4242                    1130      CLR     D2                                  ;clear D2
000017CC  2200                    1131      MOVE.L  D0,D1                               ;D0 and D1 both have complete opcode
000017CE  0241 0F00               1132      ANDI.W  #nibble2,D1                         ;isolate nibble 2
000017D2  143C 0008               1133      MOVE.B  #right8, D2                         ;putting immediate value 8 in D2
000017D6  E469                    1134      LSR.W   D2, D1                              ;
000017D8                          1135      
000017D8                          1136      ;at this point we have our single bit in bit 0
000017D8                          1137      
000017D8  0241 0001               1138      ANDI.W  #0001,D1                            ;isolate bit 0
000017DC  B27C 0000               1139      CMP     #0,D1                               ;check if bit == 0
000017E0  67D2                    1140      BEQ     OP_SIZE_WORD                        ;if yes, size = word
000017E2  60DA                    1141      BRA     OP_SIZE_LONG                        ;else, size = long
000017E4                          1142   
000017E4                          1143  
000017E4                          1144  ;******************************** ATOI ******************************************************************************************************************************
000017E4                          1145  ATOI:
000017E4  2401                    1146          MOVE.L      D1,D2                   ;loop variable (size) is in D2
000017E6  2449                    1147          MOVEA.L     A1,A2                   ;pointer to next char
000017E8  4284                    1148          CLR.L       D4
000017EA                          1149  
000017EA                          1150  ATOI_LOOP  
000017EA  4243                    1151          CLR         D3                      ;clear d3
000017EC                          1152          ;CMP.B       #0,D2
000017EC                          1153          ;BEQ         ATOI_DONE               ;DONE
000017EC  5382                    1154          SUBI.L      #1,D2                   ;subtract 1 from loop counter
000017EE  161A                    1155          MOVE.B      (A2)+,D3                 ;move current byte to D3, then increment to next
000017F0  B63C 002F               1156          CMP.B       #$2F,D3
000017F4  6F00 0060               1157          BLE         ATOI_ERROR              ;if less than 30, not a number, branch to error
000017F8  B63C 0039               1158          CMP.B       #$39,D3                 ;check byte to see if number or letter
000017FC  6F00 002A               1159          BLE         ATOI_NUMBER             ;30<x<39 --> number
00001800  B63C 0040               1160          CMP.B       #$40,D3
00001804  6F00 0050               1161          BLE         ATOI_ERROR
00001808  B63C 0046               1162          CMP.B       #$46,D3
0000180C  6F00 0024               1163          BLE         ATOI_UPPERCASE_LETTER   ;less than 47, it is uppercase letter
00001810  B63C 0060               1164          CMP.B       #$60,D3
00001814  6F00 0040               1165          BLE         ATOI_ERROR
00001818  B63C 0066               1166          CMP.B       #$66,D3
0000181C  6F00 001E               1167          BLE         ATOI_LOWERCASE_LETTER
00001820  B63C 0067               1168          CMP.B       #$67,D3
00001824  6C00 0030               1169          BGE         ATOI_ERROR
00001828                          1170          
00001828                          1171          ;BNE         ATOI_LOOP                    ;run loop
00001828                          1172      
00001828                          1173  
00001828                          1174  ATOI_NUMBER
00001828                          1175  ;number --> d1 = d1 - $30
00001828  0403 0030               1176      SUBI.B          #$30, D3                    ;subtract 30 if number
0000182C                          1177      ;MOVE.B          D3,(A2)+                    ;move into A2 and post increment pointer
0000182C  4EF9 00001846           1178      JMP             ATOI_FORMAT                 ;testing
00001832                          1179      ;JMP            ATOI_LOOP                   ;loop
00001832                          1180  
00001832                          1181  ATOI_UPPERCASE_LETTER
00001832                          1182  ;letter --> d1 = d1 - $37
00001832  0403 0037               1183      SUBI.B          #$37,D3                     ;subtract 37 if UPPER case letter
00001836                          1184      ;MOVE.B          D3,(A2)+                    ;move into A2 and post increment pointer
00001836  4EF9 00001846           1185      JMP             ATOI_FORMAT                 ;testing
0000183C                          1186      ;JMP            ATOI_LOOP                   ;loop
0000183C                          1187  
0000183C                          1188  ATOI_LOWERCASE_LETTER
0000183C  0403 0057               1189      SUBI.B          #$57,D3                     ;subtract 57(20 + 37)
00001840                          1190      ;MOVE.B          D3,(A2)+                    ;move into A2 and post increment pointer
00001840  4EF9 00001846           1191      JMP             ATOI_FORMAT                 ;testing
00001846                          1192      ;JMP            ATOI_LOOP                  ;loop
00001846                          1193  
00001846                          1194  
00001846                          1195  ATOI_FORMAT
00001846  D803                    1196      ADD.B           D3,D4                       ;add the byte to D4 so can add later   
00001848  B43C 0000               1197      CMP.B           #0,D2                       
0000184C  6700 0008               1198      BEQ             ATOI_DONE                   ;check if done (loop counter D2 is at 0)
00001850  E984                    1199      ASL.L           #4,D4                       ;logical shift left to make room
00001852  4EF8 17EA               1200      JMP             ATOI_LOOP                   ;go back to loop
00001856                          1201  
00001856                          1202  ATOI_ERROR
00001856                          1203      ;come back to handle error when out of range
00001856                          1204      
00001856                          1205  
00001856                          1206  ATOI_DONE 
00001856  2284                    1207      MOVE.L         D4,(A1)                      ;at this point, move the new address in D4 to mem location                                
00001858  4E75                    1208      RTS                                         ;used to RTS after a branch statement
0000185A                          1209  
0000185A                          1210  ;************************************* ITOA *******************************************************************************************************************
0000185A                          1211  ;A0
0000185A                          1212  ;A1
0000185A                          1213  ;A2 = buffer (this is our decoded string that will print to screen)
0000185A                          1214  ;A3
0000185A                          1215  ;A4 = current memory address for buffer
0000185A                          1216  ;A5 = starting address / current address in memory
0000185A                          1217  ;A6 = ending address
0000185A                          1218  ;A7 = SP
0000185A                          1219  
0000185A                          1220  ;D0 = counter
0000185A                          1221  ;D1 = 
0000185A                          1222  ;D2 = ?
0000185A                          1223  ;D3 = buffer size (used for loop = 64)
0000185A                          1224  ;D4 = value being converted
0000185A                          1225  ;D5 =
0000185A                          1226  ;D6 = 
0000185A                          1227  ;D7 = 
0000185A                          1228  ITOA:
0000185A  280D                    1229      MOVE.L         A5,D4                    ;D4 has data to convert to ascii
0000185C                          1230  
0000185C                          1231  ITOA_LOOP:
0000185C  BA3C 0000               1232      CMP.B           #0,D5
00001860  6700 004C               1233      BEQ             ITOA_FINISH             ;when 0, branch to finish to complete
00001864                          1234  
00001864                          1235  
00001864                          1236  
00001864                          1237  
00001864                          1238  ITOA_BYTE:
00001864                          1239  
00001864                          1240  
00001864                          1241  
00001864                          1242  ITOA_WORD:
00001864                          1243  
00001864                          1244  
00001864                          1245  
00001864                          1246  ITOA_LONG:
00001864                          1247  
00001864                          1248  
00001864                          1249  
00001864                          1250  ITOA_ADDRESS:
00001864  4284                    1251      CLR.L       D4                          ;D4 = 0000 0000
00001866  280D                    1252      MOVE.L      A5,D4                       ;our address is now in D4 and ready to deconstruct
00001868  103C 0008               1253      MOVE.B      #8,D0                       ;counter
0000186C  4EF9 00001872           1254      JMP         ITOA_ADDRESS_LOOP
00001872                          1255  ITOA_ADDRESS_LOOP:
00001872  B03C 0000               1256      CMP.B       #0,D0                       ;check if done
00001876  6700 0036               1257      BEQ         ITOA_FINISH                 ;if at 0, branch to ITOA_FINISH
0000187A  E99C                    1258      ROL.L       #4,D4                       ;rotate left 4 bits, to get MSB to beginning 
0000187C  1204                    1259      MOVE.B      D4,D1                       ;store in D1 (this will be whole byte, we want half)
0000187E  0241 000F               1260      ANDI.W      #$000F,D1                   ;character is now isolated
00001882                          1261      
00001882  4EB9 0000188E           1262      JSR         ITOA_HEX2ASCII              ;JSR to convert
00001888  5340                    1263      SUBI        #1,D0                       ;subtract 1 from counter
0000188A  4EF8 1872               1264      JMP         ITOA_ADDRESS_LOOP           ;loop again!
0000188E                          1265  
0000188E                          1266  ITOA_HEX2ASCII:
0000188E  B23C 000A               1267      CMP.B       #$A,D1                      ;compare byte in D1 to hex value A
00001892  6C00 0012               1268      BGE         ITOA_LETTER                 ;if greater than/equal A, it is letter
00001896  B23C 000A               1269      CMP.B       #$A,D1                      ;compare byte in D1 to hex value A
0000189A  6D00 0002               1270      BLT         ITOA_NUMBER                 ;if less than, it is number
0000189E                          1271  
0000189E                          1272  ITOA_NUMBER:
0000189E  0601 0030               1273      ADDI.B      #$30,D1                     ;add $30 to D1 to convert
000018A2  14C1                    1274      MOVE.B      D1,(A2)+                    ;add to buffer and increment to next position
000018A4  4E75                    1275      RTS
000018A6                          1276  
000018A6                          1277  ITOA_LETTER:
000018A6  0601 0037               1278      ADDI.B      #$37,D1                     ;add 37 to D1 to convert
000018AA  14C1                    1279      MOVE.B      D1,(A2)+                    ;add to buffer and increment to next position
000018AC  4E75                    1280      RTS
000018AE                          1281  
000018AE                          1282  ITOA_FINISH:
000018AE  4E75                    1283      RTS
000018B0                          1284  
000018B0                          1285  
000018B0                          1286  ;************************************ Validate Addresses ******************************************
000018B0                          1287  
000018B0                          1288  VALIDATE_BEGINNING:
000018B0                          1289      
000018B0                          1290  
000018B0                          1291  
000018B0                          1292  
000018B0                          1293  ;******************************** Message Error Handling ***************************************************************************************************************** 
000018B0                          1294  STARTA_ERROR_LESS_THAN_ZERO:
000018B0  103C 000E               1295      MOVE.B  #14,D0
000018B4  43F9 0000221C           1296      LEA     error_message_1,A1      ;load the get_end_address message into A1
000018BA  4E4F                    1297      TRAP    #15    
000018BC  4EF8 1012               1298      JMP     GET_STARTING_ADDRESS
000018C0                          1299  
000018C0                          1300  STARTA_ERROR_NOT_EVEN:
000018C0  103C 000E               1301      MOVE.B  #14,D0
000018C4  43F9 00002246           1302      LEA     error_message_2,A1      ;load error_message_2
000018CA  4E4F                    1303      TRAP    #15    
000018CC  4EF8 1012               1304      JMP     GET_STARTING_ADDRESS
000018D0                          1305  
000018D0                          1306  ENDA_ERROR_NOT_EVEN:
000018D0  103C 000E               1307      MOVE.B  #14,D0
000018D4  43F9 00002266           1308      LEA     error_message_3,A1      ;load error_message_3
000018DA  4E4F                    1309      TRAP    #15
000018DC  4EF8 104A               1310      JMP     GET_ENDING_ADDRESS
000018E0                          1311  
000018E0                          1312  ENDA_ERROR_LARGE:
000018E0  103C 000E               1313      MOVE.B  #14,D0
000018E4  43F9 00002286           1314      LEA     error_message_4,A1      ;load error_message_4
000018EA  4E4F                    1315      TRAP    #15
000018EC  4EF8 104A               1316      JMP     GET_ENDING_ADDRESS
000018F0                          1317      
000018F0                          1318  ENDA_ERROR_LESS_THAN_STARTA:
000018F0  103C 000E               1319      MOVE.B  #14,D0
000018F4  43F9 000022B5           1320      LEA     error_message_5,A1      ;load error_message_5
000018FA  4E4F                    1321      TRAP    #15
000018FC  4EF8 104A               1322      JMP     GET_ENDING_ADDRESS
00001900                          1323  
00001900                          1324  ;****************************************** EA Stuff ********************************************************************************************************************* 
00001900                          1325  
00001900                          1326  EA_START:
00001900  41F9 0000190E           1327      LEA         EA_TYPE_TABLE, A0
00001906                          1328      
00001906  C2FC 0006               1329      MULU        #6,D1               ;computes opcode table jump displacement
0000190A  4EF0 1000               1330      JMP         0(A0,D1)            ;jump to correct table input
0000190E                          1331  
0000190E                          1332  
0000190E                          1333  EA_TYPE_TABLE:
0000190E  4EF9 0000195E           1334      JMP         EA_IMMEDIATE        ;0  DONE
00001914  4EF9 000019A0           1335      JMP         EA_MOVE             ;1  DONE
0000191A  4EF9 000019E6           1336      JMP         EA_MOVEA            ;2  DONE
00001920  4EF9 00001A2C           1337      JMP         EA_LEA              ;3  DONE
00001926  4EF9 00001A6C           1338      JMP         EA_DESTONLY         ;4  JMP, CLR
0000192C  4EF9 00001A6C           1339      JMP         EA_EXT              ;5
00001932  4EF9 00001A6C           1340      JMP         EA_MOVEM            ;6
00001938  4EF9 00001D90           1341      JMP         EA_TRAP             ;7
0000193E  4EF9 00001D90           1342      JMP         EA_QUICK            ;8  DONE
00001944  4EF9 00001E0C           1343      JMP         EA_BRANCH           ;9  DONE
0000194A  4EF9 00001ED4           1344      JMP         EA_MATH             ;10 DONE    DIVU, DIVS, SUB, CMP, MULU, ADD, ADDA
00001950  4EF9 00001F4C           1345      JMP         EA_ROTATION         ;11         ASL, ASR, ???  
00001956  4EF9 0000195C           1346      JMP         EA_FINISH           ;
0000195C                          1347  
0000195C                          1348  EA_FINISH:
0000195C  4E75                    1349      RTS ; TAKE OUT LATER
0000195E                          1350      
0000195E                          1351  
0000195E                          1352  
0000195E                          1353  ;********************************************  EA_TYPE  ****************************************************   
0000195E                          1354  
0000195E                          1355  EA_IMMEDIATE:                               ;value 0
0000195E  14FC 0009               1356      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001962  14FC 0023               1357      MOVE.B  #'#',(A2)+                      ;add a # to buffer
00001966  14FC 0024               1358      MOVE.B  #'$',(A2)+                      ;add a $ to buffer
0000196A                          1359      
0000196A                          1360      ;check size which is bits 6,7 and store in D6
0000196A                          1361      ;get immediate value from memory based off size and store in D7
0000196A  4EB9 000020AC           1362      JSR     EA_CHECK_SIZE
00001970                          1363      
00001970                          1364      ;at this point our size is in D6 and data is in D7 and memory has been advanced
00001970                          1365      ;convert immediate data to ascii and put on buffer
00001970  4EB9 000020D6           1366      JSR     EA_ITOA_IMMEDIATE
00001976                          1367      
00001976  41F9 00001FCE           1368      LEA     EA_MODE_TABLE,A0                ;load table
0000197C  14FC 002C               1369      MOVE.B  #',',(A2)+                      ;add a # to buffer
00001980  14FC 0009               1370      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001984                          1371      
00001984                          1372      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
00001984                          1373      
00001984                          1374      ;isolate source mode - bits 3,4,5 and store in D4
00001984  2800                    1375      MOVE.L  D0,D4
00001986  E64C                    1376      LSR.W   #3,D4
00001988  0244 0007               1377      ANDI.W  #$7,D4
0000198C  C8FC 0006               1378      MULU    #6,D4
00001990                          1379      
00001990                          1380      ;isolate source register - bits 0,1,2 and store in D5
00001990  2A00                    1381      MOVE.L  D0,D5
00001992  0245 0007               1382      ANDI.W  #$7,D5
00001996                          1383  
00001996  4EB9 00001FCA           1384      JSR     EA_JMP_HELPER
0000199C  4EF8 195C               1385      JMP     EA_FINISH
000019A0                          1386  
000019A0                          1387  ;D4 = mode      --> source / destination
000019A0                          1388  ;D5 = register  --> source / destination   
000019A0                          1389  EA_MOVE:
000019A0  14FC 0009               1390      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
000019A4  41F9 00001FCE           1391      LEA     EA_MODE_TABLE,A0                ;load table
000019AA                          1392      
000019AA                          1393      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
000019AA                          1394      
000019AA                          1395      ;isolate source mode
000019AA  2800                    1396      MOVE.L  D0,D4
000019AC  E64C                    1397      LSR.W   #3,D4
000019AE  0244 0007               1398      ANDI.W  #$7,D4
000019B2  C8FC 0006               1399      MULU    #6,D4
000019B6                          1400          
000019B6                          1401      ;isolate source register
000019B6  2A00                    1402      MOVE.L  D0,D5
000019B8  0245 0007               1403      ANDI.W  #$7,D5
000019BC                          1404      
000019BC  4EB9 00001FCA           1405      JSR    EA_JMP_HELPER
000019C2  14FC 002C               1406      MOVE.B  #',',(A2)+                  ;add ',' to buffer  
000019C6                          1407      
000019C6                          1408      ;isolate destination mode
000019C6  2800                    1409      MOVE.L  D0,D4
000019C8  EC4C                    1410      LSR.W   #6,D4
000019CA  0244 0007               1411      ANDI.W  #$7,D4
000019CE  C8FC 0006               1412      MULU    #6,D4
000019D2                          1413      
000019D2                          1414      ;isolate destination register 
000019D2  2A00                    1415      MOVE.L  D0,D5
000019D4  E84D                    1416      LSR.W   #4,D5
000019D6  EA4D                    1417      LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
000019D8  0245 0007               1418      ANDI.W  #$7,D5   
000019DC  4EB9 00001FCA           1419      JSR     EA_JMP_HELPER
000019E2                          1420  
000019E2  4EF8 195C               1421      JMP     EA_FINISH
000019E6                          1422      
000019E6                          1423  
000019E6                          1424  EA_MOVEA:
000019E6  14FC 0009               1425      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
000019EA  41F9 00001FCE           1426      LEA     EA_MODE_TABLE,A0                ;load table
000019F0                          1427  
000019F0                          1428      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
000019F0                          1429      
000019F0                          1430      ;isolate source mode
000019F0  2800                    1431      MOVE.L  D0,D4
000019F2  E64C                    1432      LSR.W   #3,D4
000019F4  0244 0007               1433      ANDI.W  #$7,D4
000019F8  C8FC 0006               1434      MULU    #6,D4
000019FC                          1435          
000019FC                          1436      ;isolate source register
000019FC  2A00                    1437      MOVE.L  D0,D5
000019FE  0245 0007               1438      ANDI.W  #$7,D5
00001A02                          1439      
00001A02  4EB9 00001FCA           1440      JSR    EA_JMP_HELPER
00001A08  14FC 002C               1441      MOVE.B  #',',(A2)+                  ;add ',' to buffer
00001A0C                          1442      
00001A0C                          1443      ;isolate destination mode --> SHOULD ALWAYS BE 001 AND GO TO ADDRESS REGISTER
00001A0C  2800                    1444      MOVE.L  D0,D4
00001A0E  EC4C                    1445      LSR.W   #6,D4
00001A10  0244 0007               1446      ANDI.W  #$7,D4
00001A14  C8FC 0006               1447      MULU    #6,D4
00001A18                          1448      
00001A18                          1449      ;isolate destination register 
00001A18  2A00                    1450      MOVE.L  D0,D5
00001A1A  E84D                    1451      LSR.W   #4,D5
00001A1C  EA4D                    1452      LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
00001A1E  0245 0007               1453      ANDI.W  #$7,D5   
00001A22  4EB9 00001FCA           1454      JSR     EA_JMP_HELPER
00001A28                          1455  
00001A28  4EF8 195C               1456      JMP     EA_FINISH
00001A2C                          1457  
00001A2C                          1458  EA_LEA:
00001A2C  14FC 0009               1459      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001A30  41F9 00001FCE           1460      LEA     EA_MODE_TABLE,A0                ;load table
00001A36                          1461      
00001A36                          1462      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
00001A36                          1463      
00001A36                          1464      ;isolate source mode
00001A36  2800                    1465      MOVE.L  D0,D4
00001A38  E64C                    1466      LSR.W   #3,D4
00001A3A  0244 0007               1467      ANDI.W  #$7,D4
00001A3E  C8FC 0006               1468      MULU    #6,D4
00001A42                          1469          
00001A42                          1470      ;isolate source register
00001A42  2A00                    1471      MOVE.L  D0,D5
00001A44  0245 0007               1472      ANDI.W  #$7,D5
00001A48                          1473      
00001A48  4EB9 00001FCA           1474      JSR    EA_JMP_HELPER
00001A4E  14FC 002C               1475      MOVE.B  #',',(A2)+                  ;add ',' to buffer
00001A52                          1476      
00001A52                          1477      ;destination always An
00001A52                          1478      ;MOVE.B  #'A',(A2)+                  ;add 'A' to buffer
00001A52                          1479      
00001A52                          1480      ;isolate destination register 
00001A52                          1481      ;MOVE.L  D0,D5
00001A52                          1482      ;LSR.W   #4,D5
00001A52                          1483      ;LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
00001A52                          1484      ;ANDI.W  #$7,D5
00001A52                          1485  
00001A52                          1486      ;isolate destination mode --> SHOULD ALWAYS BE 001 AND GO TO ADDRESS REGISTER
00001A52  7801                    1487      MOVE.L  #1,D4
00001A54  C8FC 0006               1488      MULU    #6,D4
00001A58                          1489      
00001A58                          1490      ;isolate destination register 
00001A58  2A00                    1491      MOVE.L  D0,D5
00001A5A  E84D                    1492      LSR.W   #4,D5
00001A5C  EA4D                    1493      LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
00001A5E  0245 0007               1494      ANDI.W  #$7,D5   
00001A62  4EB9 00001FCA           1495      JSR     EA_JMP_HELPER
00001A68                          1496  
00001A68  4EF8 195C               1497      JMP     EA_FINISH
00001A6C                          1498  
00001A6C                          1499  EA_DESTONLY:        ;JMP, CLR
00001A6C                          1500  
00001A6C                          1501  
00001A6C                          1502  
00001A6C                          1503  
00001A6C                          1504  
00001A6C                          1505  EA_EXT:
00001A6C                          1506  
00001A6C                          1507  
00001A6C                          1508  
00001A6C                          1509  
00001A6C                          1510  
00001A6C                          1511  EA_MOVEM:
00001A6C  14FC 0009               1512      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001A70  41F9 00001FCE           1513      LEA     EA_MODE_TABLE,A0                ;load table
00001A76                          1514      
00001A76  2200                    1515      MOVE.L  D0,D1                           ;
00001A78  341D                    1516      MOVE.W  (A5)+,D2                        ;come back and verify D2 is free!!!!!
00001A7A                          1517      
00001A7A                          1518      ;D1 = 4890 | D2 = 0080 (source)
00001A7A                          1519      
00001A7A                          1520      ;if direction (bit 10) == 0, destination is in opcode, source is in the second operand
00001A7A                          1521      ;if direction (bit 10) == 1, the source is in the opcode, destination is in the operand
00001A7A                          1522      
00001A7A                          1523      ;check direction (bit 10)
00001A7A  0241 0F00               1524      ANDI.W  #nibble2,D1
00001A7E  EA49                    1525      LSR.W   #5,D1
00001A80  EA49                    1526      LSR.W   #5,D1                           ;total of 10 shifts
00001A82  0241 0001               1527      ANDI.W  #1,D1
00001A86  B23C 0000               1528      CMP.B   #0,D1
00001A8A  6700 000A               1529      BEQ     EA_MOVEM_REG_TO_MEM
00001A8E  B23C 0001               1530      CMP.B   #1,D1
00001A92  6700 018E               1531      BEQ     EA_MOVEM_MEM_TO_REG
00001A96                          1532      
00001A96                          1533      
00001A96                          1534  ;MOVEM.W    D/A2,(A7)    
00001A96                          1535  EA_MOVEM_REG_TO_MEM:                        ;bit 10 == 0
00001A96                          1536      ;check if data register or address register
00001A96  4246                    1537      CLR     D6
00001A98  3C02                    1538      MOVE.W  D2,D6
00001A9A  0246 FF00               1539      ANDI.W  #$FF00,D6                       ;isolate nibble 1 and 2
00001A9E  BC7C 0000               1540      CMP.W   #0,D6                           ;check if 0
00001AA2  6700 00A4               1541      BEQ     EA_MOVEM_DATAREG_TO_MEM        ;if 0, source is data register
00001AA6                          1542      
00001AA6  3C02                    1543      MOVE.W  D2,D6
00001AA8  0246 00FF               1544      ANDI.W  #$00FF,D6
00001AAC  BC7C 0000               1545      CMP.W   #0,D6
00001AB0  6700 011E               1546      BEQ     EA_MOVEM_ADDRREG_TO_MEM        ;else it is address register
00001AB4                          1547      
00001AB4                          1548      
00001AB4                          1549      ;else, both are populated and we need to handle mixture
00001AB4                          1550      
00001AB4  2C02                    1551      MOVE.L  D2,D6
00001AB6  4247                    1552      CLR     D7
00001AB8                          1553      
00001AB8  0246 00FF               1554      ANDI.W  #$00FF,D6
00001ABC  1E3C 0000               1555      MOVE.B  #0,D7
00001AC0  4245                    1556      CLR     D5
00001AC2  4243                    1557      CLR     D3
00001AC4  4241                    1558      CLR     D1
00001AC6  6100 0266               1559      BSR     MOVEM_LOOP
00001ACA                          1560      
00001ACA  14FC 0044               1561      MOVE.B  #'D',(A2)+
00001ACE  0603 0030               1562      ADDI.B  #$30,D3
00001AD2  14C3                    1563      MOVE.B  D3,(A2)+
00001AD4                          1564      
00001AD4                          1565      
00001AD4  0605 0030               1566      ADDI.B  #$30,D5
00001AD8  4241                    1567      CLR     D1
00001ADA  323C 0000               1568      MOVE.W  #0,D1
00001ADE                          1569      
00001ADE  4EB9 00001BA2           1570      JSR MOVEM_CHECK_MULTIPLE
00001AE4                          1571      
00001AE4  14FC 002F               1572      MOVE.B  #'/',(A2)+
00001AE8                          1573      
00001AE8  2C02                    1574      MOVE.L  D2,D6
00001AEA  4247                    1575      CLR D7
00001AEC                          1576      
00001AEC  0246 FF00               1577      ANDI.W  #$FF00,D6
00001AF0  E04E                    1578      LSR.W   #8,D6
00001AF2  1E3C 0000               1579      MOVE.B  #0,D7
00001AF6  4245                    1580      CLR     D5
00001AF8  4243                    1581      CLR     D3
00001AFA  4241                    1582      CLR     D1
00001AFC  14FC 0041               1583      MOVE.B  #'A',(A2)+
00001B00                          1584      
00001B00  6100 022C               1585      BSR     MOVEM_LOOP
00001B04                          1586      
00001B04  0603 0030               1587      ADDI.B  #$30,D3
00001B08  14C3                    1588      MOVE.B  D3,(A2)+
00001B0A                          1589      
00001B0A  0605 0030               1590      ADDI.B  #$30,D5
00001B0E  4241                    1591      CLR     D1
00001B10  323C 0001               1592      MOVE.W  #1,D1
00001B14                          1593      
00001B14  4EB9 00001BA2           1594      JSR MOVEM_CHECK_MULTIPLE
00001B1A                          1595      
00001B1A                          1596      
00001B1A                          1597      ;handle second part now
00001B1A                          1598      
00001B1A  14FC 002C               1599      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001B1E                          1600  
00001B1E  41F9 00001FCE           1601      LEA     EA_MODE_TABLE,A0                ;load table
00001B24                          1602      
00001B24                          1603      ;isolate source mode
00001B24  2800                    1604      MOVE.L  D0,D4
00001B26  E64C                    1605      LSR.W   #3,D4   
00001B28  0244 0007               1606      ANDI.W  #$7,D4
00001B2C                          1607      
00001B2C                          1608      ;check for mode 111 -> immediate data
00001B2C  B87C 0007               1609      CMP.W   #$7,D4
00001B30                          1610      ;if immediate data, leave and get immediate data rather than another register
00001B30  6700 022A               1611      BEQ     EA_MOVEM_IMMEDIATE_DESTINATION     
00001B34                          1612      
00001B34  C8FC 0006               1613      MULU    #6,D4
00001B38                          1614       
00001B38                          1615      ;isolate source register
00001B38  2A00                    1616      MOVE.L  D0,D5
00001B3A  0245 0007               1617      ANDI.W  #$7,D5
00001B3E                          1618      
00001B3E  4EB9 00001FCA           1619      JSR    EA_JMP_HELPER
00001B44  4EF8 195C               1620      JMP     EA_FINISH
00001B48                          1621  
00001B48                          1622  EA_MOVEM_DATAREG_TO_MEM:    
00001B48  2C02                    1623      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001B4A  4247                    1624      CLR     D7
00001B4C                          1625      
00001B4C  1E3C 0000               1626      MOVE.B  #0,D7
00001B50  4245                    1627      CLR D5
00001B52  4243                    1628      CLR D3
00001B54  4241                    1629      CLR D1
00001B56                          1630      
00001B56  14FC 0044               1631      MOVE.B  #'D',(A2)+                      ;add 'D' to buffer
00001B5A  6100 01D2               1632      BSR     MOVEM_LOOP                      ;enter loop to get number
00001B5E                          1633  
00001B5E                          1634      ;convert d3 to ascii and add to buffer
00001B5E  0603 0030               1635      ADDI.B  #$30,D3                         ;convert to ASCII
00001B62  14C3                    1636      MOVE.B  D3,(A2)+                        ;put on buffer
00001B64                          1637  
00001B64                          1638      ;check d5 and handle
00001B64  0605 0030               1639      ADDI.B  #$30,D5
00001B68                          1640      
00001B68  4241                    1641      CLR     D1
00001B6A  323C 0000               1642      MOVE.W  #0,D1                           ;FLAG TO INDICATE D
00001B6E                          1643      
00001B6E  4EB9 00001BA2           1644      JSR     MOVEM_CHECK_MULTIPLE
00001B74                          1645      
00001B74  14FC 002C               1646      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001B78                          1647  
00001B78  41F9 00001FCE           1648      LEA     EA_MODE_TABLE,A0                ;load table
00001B7E                          1649      
00001B7E                          1650      ;isolate source mode
00001B7E  2800                    1651      MOVE.L  D0,D4
00001B80  E64C                    1652      LSR.W   #3,D4   
00001B82  0244 0007               1653      ANDI.W  #$7,D4
00001B86                          1654      
00001B86                          1655      ;check for mode 111 -> immediate data
00001B86  B87C 0007               1656      CMP.W   #$7,D4
00001B8A                          1657      ;if immediate data, leave and get immediate data rather than another register
00001B8A  6700 01D0               1658      BEQ     EA_MOVEM_IMMEDIATE_DESTINATION     
00001B8E                          1659      
00001B8E  C8FC 0006               1660      MULU    #6,D4
00001B92                          1661       
00001B92                          1662      ;isolate source register
00001B92  2A00                    1663      MOVE.L  D0,D5
00001B94  0245 0007               1664      ANDI.W  #$7,D5
00001B98                          1665      
00001B98  4EB9 00001FCA           1666      JSR    EA_JMP_HELPER
00001B9E  4EF8 195C               1667      JMP     EA_FINISH
00001BA2                          1668  
00001BA2                          1669  
00001BA2                          1670      
00001BA2                          1671  MOVEM_CHECK_MULTIPLE:
00001BA2  BA43                    1672      CMP     D3,D5
00001BA4  6600 0004               1673      BNE     MOVEM_MULTIPLE
00001BA8  4E75                    1674      RTS
00001BAA                          1675      
00001BAA                          1676  MOVEM_MULTIPLE:
00001BAA  14FC 002D               1677      MOVE.B  #'-',(A2)+                      ;add '-' to buffer
00001BAE                          1678      ;CHECK D1 FOR A OR D
00001BAE  B27C 0000               1679      CMP.W   #0,D1                           ;check if 0 --> D
00001BB2  6700 000C               1680      BEQ     MOVEM_MULTIPLE_D
00001BB6  B27C 0001               1681      CMP.W   #1,D1
00001BBA  6700 000C               1682      BEQ     MOVEM_MULTIPLE_A
00001BBE                          1683  
00001BBE  4E75                    1684      RTS
00001BC0                          1685  
00001BC0                          1686  MOVEM_MULTIPLE_D:
00001BC0  14FC 0044               1687      MOVE.B  #'D',(A2)+                      ;add 'D' to buffer
00001BC4  14C5                    1688      MOVE.B  D5,(A2)+                        ;put on buffer
00001BC6  4E75                    1689      RTS
00001BC8                          1690  
00001BC8                          1691  MOVEM_MULTIPLE_A:
00001BC8  14FC 0041               1692      MOVE.B  #'A',(A2)+                      ;add 'D' to buffer
00001BCC  14C5                    1693      MOVE.B  D5,(A2)+                        ;put on buffer
00001BCE  4E75                    1694      RTS
00001BD0                          1695  
00001BD0                          1696  EA_MOVEM_ADDRREG_TO_MEM:
00001BD0  2C02                    1697      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001BD2  4247                    1698      CLR     D7
00001BD4                          1699      
00001BD4  1E3C 0000               1700      MOVE.B  #0,D7
00001BD8  4245                    1701      CLR D5
00001BDA  4243                    1702      CLR D3
00001BDC  4241                    1703      CLR D1
00001BDE                          1704      
00001BDE  14FC 0041               1705      MOVE.B  #'A',(A2)+                      ;add 'A' to buffer
00001BE2  E04E                    1706      LSR.W   #8,D6                           ;shift 8 times
00001BE4  6100 0148               1707      BSR     MOVEM_LOOP                      ;enter loop to get number
00001BE8                          1708      
00001BE8                          1709      ;convert d3 to ascii and add to buffer
00001BE8  0603 0030               1710      ADDI.B  #$30,D3                         ;convert to ASCII
00001BEC  14C3                    1711      MOVE.B  D3,(A2)+                        ;put on buffer
00001BEE                          1712      
00001BEE  0605 0030               1713      ADDI.B  #$30,D5
00001BF2                          1714      
00001BF2  4241                    1715      CLR     D1
00001BF4  323C 0001               1716      MOVE.W  #1,D1                           ;FLAG TO INDICATE A
00001BF8                          1717      
00001BF8  4EB8 1BA2               1718      JSR MOVEM_CHECK_MULTIPLE
00001BFC                          1719      
00001BFC  14FC 002C               1720      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001C00                          1721      ;MOVEM.s D7,
00001C00                          1722      
00001C00  41F9 00001FCE           1723      LEA     EA_MODE_TABLE,A0                ;load table
00001C06                          1724      
00001C06                          1725      ;isolate source mode
00001C06  2800                    1726      MOVE.L  D0,D4
00001C08  E64C                    1727      LSR.W   #3,D4
00001C0A  0244 0007               1728      ANDI.W  #$7,D4
00001C0E  C8FC 0006               1729      MULU    #6,D4
00001C12                          1730          
00001C12                          1731      ;isolate source register
00001C12  2A00                    1732      MOVE.L  D0,D5
00001C14  0245 0007               1733      ANDI.W  #$7,D5
00001C18                          1734      
00001C18  4EB9 00001FCA           1735      JSR    EA_JMP_HELPER
00001C1E  4EF8 195C               1736      JMP     EA_FINISH
00001C22                          1737  
00001C22                          1738  ;MOVEM.W (A7),D/A2
00001C22                          1739  EA_MOVEM_MEM_TO_REG:                        ;bit 10 == 1
00001C22  41F9 00001FCE           1740      LEA     EA_MODE_TABLE,A0                ;load table
00001C28                          1741      
00001C28                          1742      ;isolate source mode
00001C28  2800                    1743      MOVE.L  D0,D4
00001C2A  E64C                    1744      LSR.W   #3,D4
00001C2C  0244 0007               1745      ANDI.W  #$7,D4
00001C30                          1746  
00001C30                          1747      ;check for mode 111 -> immediate data
00001C30  B87C 0007               1748      CMP.W   #$7,D4
00001C34                          1749      ;if immediate data, leave and get immediate data rather than another register
00001C34  6700 0136               1750      BEQ     EA_MOVEM_IMMEDIATE_SOURCE
00001C38                          1751  
00001C38  C8FC 0006               1752      MULU    #6,D4
00001C3C                          1753          
00001C3C                          1754      ;isolate source register
00001C3C  2A00                    1755      MOVE.L  D0,D5
00001C3E  0245 0007               1756      ANDI.W  #$7,D5
00001C42                          1757  
00001C42  4EB9 00001FCA           1758      JSR    EA_JMP_HELPER
00001C48  14FC 002C               1759      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001C4C                          1760      
00001C4C                          1761      ;our operand is in D2
00001C4C  4246                    1762      CLR     D6
00001C4E  3C02                    1763      MOVE.W  D2,D6
00001C50  0246 FF00               1764      ANDI.W  #$FF00,D6                       ;isolate nibble 1 and 2
00001C54  BC7C 0000               1765      CMP.W   #0,D6                           ;check if 0
00001C58  6700 0076               1766      BEQ     EA_MOVEM_MEM_TO_DATAREG        ;if 0, source is data register
00001C5C                          1767      
00001C5C  3C02                    1768      MOVE.W  D2,D6
00001C5E  0246 00FF               1769      ANDI.W  #$00FF,D6 
00001C62  BC7C 0000               1770      CMP.W   #0,D6
00001C66  6700 0096               1771      BEQ     EA_MOVEM_MEM_TO_ADDRREG        ;else it is address register
00001C6A                          1772  
00001C6A                          1773      ;else, both are populated and we need to handle mixture (D7/A5)
00001C6A  2C02                    1774      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001C6C  4247                    1775      CLR     D7
00001C6E                          1776  
00001C6E  0246 00FF               1777      ANDI.W  #$00FF,D6                       ;work on first half
00001C72  1E3C 0000               1778      MOVE.B  #0,D7
00001C76  4245                    1779      CLR D5
00001C78  4243                    1780      CLR D3
00001C7A  4241                    1781      CLR D1
00001C7C  14FC 0044               1782      MOVE.B  #'D',(A2)+                      ;add 'D' to buffer
00001C80  6100 00AC               1783      BSR     MOVEM_LOOP                      ;enter loop to get number
00001C84                          1784      ;convert d7 to ascii and add to buffer
00001C84  0603 0030               1785      ADDI.B  #$30,D3                         ;convert to ASCII
00001C88  14C3                    1786      MOVE.B  D3,(A2)+                        ;put on buffer
00001C8A                          1787      ;check multiple
00001C8A  0605 0030               1788      ADDI.B  #$30,D5
00001C8E  4241                    1789      CLR     D1
00001C90  323C 0000               1790      MOVE.W  #0,D1                           ;FLAG TO INDICATE D
00001C94                          1791      
00001C94  4EB8 1BA2               1792      JSR MOVEM_CHECK_MULTIPLE
00001C98                          1793  
00001C98  14FC 002F               1794      MOVE.B  #'/',(A2)+                      ;add '/' to buffer
00001C9C                          1795  
00001C9C  2C02                    1796      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001C9E  4247                    1797      CLR     D7
00001CA0                          1798  
00001CA0  0246 FF00               1799      ANDI.W  #$FF00,D6                       ;work on FIRST half
00001CA4  E04E                    1800      LSR.W   #8,D6                           ;shift 8 times
00001CA6  1E3C 0000               1801      MOVE.B  #0,D7
00001CAA  4245                    1802      CLR D5
00001CAC  4243                    1803      CLR D3
00001CAE  4241                    1804      CLR D1
00001CB0  14FC 0041               1805      MOVE.B  #'A',(A2)+                      ;add 'A' to buffer
00001CB4  6100 0078               1806      BSR     MOVEM_LOOP                      ;enter loop to get number
00001CB8                          1807      ;convert d7 to ascii and add to buffer
00001CB8  0603 0030               1808      ADDI.B  #$30,D3                         ;convert to ASCII
00001CBC  14C3                    1809      MOVE.B  D3,(A2)+                        ;put on buffer
00001CBE                          1810      ;check multiple
00001CBE  0605 0030               1811      ADDI.B  #$30,D5
00001CC2  4241                    1812      CLR     D1
00001CC4  323C 0001               1813      MOVE.W  #1,D1                           ;FLAG TO INDICATE A
00001CC8                          1814      
00001CC8  4EB8 1BA2               1815      JSR MOVEM_CHECK_MULTIPLE
00001CCC                          1816  
00001CCC  4EF8 195C               1817      JMP     EA_FINISH    
00001CD0                          1818          
00001CD0                          1819  EA_MOVEM_MEM_TO_DATAREG: 
00001CD0  2C02                    1820      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001CD2  4247                    1821      CLR     D7
00001CD4                          1822      
00001CD4  1E3C 0000               1823      MOVE.B  #0,D7
00001CD8  4245                    1824      CLR D5
00001CDA  4243                    1825      CLR D3
00001CDC  4241                    1826      CLR D1
00001CDE                          1827      
00001CDE  14FC 0044               1828      MOVE.B  #'D',(A2)+                      ;add 'D' to buffer
00001CE2  6100 004A               1829      BSR     MOVEM_LOOP                      ;enter loop to get number
00001CE6                          1830      
00001CE6                          1831      ;convert d7 to ascii and add to buffer
00001CE6  0603 0030               1832      ADDI.B  #$30,D3                         ;convert to ASCII
00001CEA  14C3                    1833      MOVE.B  D3,(A2)+                        ;put on buffer
00001CEC                          1834  
00001CEC                          1835      ;check multiple
00001CEC  0605 0030               1836      ADDI.B  #$30,D5
00001CF0                          1837      
00001CF0  4241                    1838      CLR     D1
00001CF2  323C 0000               1839      MOVE.W  #0,D1                           ;FLAG TO INDICATE D
00001CF6                          1840      
00001CF6  4EB8 1BA2               1841      JSR MOVEM_CHECK_MULTIPLE
00001CFA                          1842  
00001CFA  4EF8 195C               1843      JMP     EA_FINISH
00001CFE                          1844     
00001CFE                          1845  EA_MOVEM_MEM_TO_ADDRREG:
00001CFE  2C02                    1846      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001D00  4247                    1847      CLR     D7  
00001D02                          1848      
00001D02  1E3C 0000               1849      MOVE.B  #0,D7
00001D06  4245                    1850      CLR D5
00001D08  4243                    1851      CLR D3
00001D0A  4241                    1852      CLR D1
00001D0C                          1853         
00001D0C  14FC 0041               1854      MOVE.B  #'A',(A2)+                      ;add 'A' to buffer
00001D10  E04E                    1855      LSR.W   #8,D6                           ;shift 8 times
00001D12  6100 001A               1856      BSR     MOVEM_LOOP                      ;enter loop to get number
00001D16                          1857      
00001D16                          1858      ;convert d7 to ascii and add to buffer
00001D16  0603 0030               1859      ADDI.B  #$30,D3                         ;convert to ASCII
00001D1A  14C3                    1860      MOVE.B  D3,(A2)+                        ;put on buffer
00001D1C                          1861  
00001D1C                          1862      ;check multiple   
00001D1C  0605 0030               1863      ADDI.B  #$30,D5 
00001D20  4241                    1864      CLR     D1
00001D22  323C 0001               1865      MOVE.W  #1,D1                           ;FLAG TO INDICATE A
00001D26                          1866      
00001D26  4EB8 1BA2               1867      JSR MOVEM_CHECK_MULTIPLE
00001D2A                          1868  
00001D2A  4EF8 195C               1869      JMP     EA_FINISH
00001D2E                          1870  
00001D2E                          1871  MOVEM_LOOP  
00001D2E                          1872      ;D1 = min_set_flag (0 = not set, 1 = set) | D3 = MIN | D5 = MAX | D7 = COUNTER (STARTS AT 0)
00001D2E                          1873      ;D6 = OUR SECOND OPERAND
00001D2E                          1874       
00001D2E  E24E                    1875      LSR.W   #1,D6               ;1000
00001D30  6500 000C               1876      BCS     MOVEM_CARRY
00001D34  5247                    1877      ADDI.W  #1,D7
00001D36  BE7C 0008               1878      CMP     #8,D7
00001D3A  6FF2                    1879      BLE     MOVEM_LOOP
00001D3C  4E75                    1880      RTS
00001D3E                          1881  
00001D3E                          1882  MOVEM_CARRY:
00001D3E  B27C 0000               1883      CMP         #0,D1
00001D42  6700 000A               1884      BEQ         MOVEM_SET_MIN
00001D46                          1885      
00001D46  3A07                    1886      MOVE.W      D7,D5
00001D48  5247                    1887      ADDI.W      #1,D7  
00001D4A  4EF8 1D2E               1888      JMP         MOVEM_LOOP
00001D4E                          1889  
00001D4E                          1890  MOVEM_SET_MIN:
00001D4E  3607                    1891      MOVE.W      D7,D3           ;set min
00001D50  3A07                    1892      MOVE.W      D7,D5           ;set max
00001D52  323C 0001               1893      MOVE.W      #1,D1           ;set flag
00001D56  5247                    1894      ADDI.W      #1,D7  
00001D58  4EF8 1D2E               1895      JMP         MOVEM_LOOP
00001D5C                          1896  
00001D5C                          1897  
00001D5C                          1898  
00001D5C                          1899  EA_MOVEM_IMMEDIATE_DESTINATION:
00001D5C                          1900      ;GET NEXT WORD VALUE AT A5 AND INCREMENT
00001D5C  3E15                    1901      MOVE.W  (A5),D7                        ;immediate value is in D7 now
00001D5E  14FC 0024               1902      MOVE.B  #'$',(A2)+                      ;add '$' to buffer
00001D62                          1903      
00001D62                          1904      ;convert to ascii and put on buffer
00001D62  4EB9 000020FA           1905      JSR     EA_ITOA_WORD
00001D68                          1906  
00001D68  4EF8 195C               1907      JMP     EA_FINISH
00001D6C                          1908  
00001D6C                          1909  EA_MOVEM_IMMEDIATE_SOURCE:
00001D6C                          1910      ;GET NEXT WORD VALUE AT A5 AND INCREMENT
00001D6C  3E15                    1911      MOVE.W  (A5),D7                        ;immediate value is in D7 now
00001D6E  14FC 0024               1912      MOVE.B  #'$',(A2)+                      ;add '$' to buffer
00001D72                          1913      
00001D72                          1914      ;convert to ascii and put on buffer
00001D72  4EB9 000020FA           1915      JSR     EA_ITOA_WORD
00001D78                          1916  
00001D78                          1917      ;TRY THIS
00001D78  14FC 002C               1918      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001D7C                          1919      
00001D7C                          1920      ;our operand is in D2
00001D7C  4246                    1921      CLR     D6
00001D7E  3C02                    1922      MOVE.W  D2,D6
00001D80  0246 FF00               1923      ANDI.W  #$FF00,D6                       ;isolate nibble 1 and 2
00001D84  BC7C 0000               1924      CMP.W   #0,D6                           ;check if 0
00001D88  6700 FF46               1925      BEQ     EA_MOVEM_MEM_TO_DATAREG        ;if 0, source is data register
00001D8C  6000 FF70               1926      BRA     EA_MOVEM_MEM_TO_ADDRREG        ;else it is address register
00001D90                          1927  
00001D90                          1928  
00001D90                          1929  
00001D90                          1930  
00001D90                          1931  
00001D90                          1932  
00001D90                          1933  
00001D90                          1934  EA_TRAP:
00001D90                          1935  
00001D90                          1936  
00001D90                          1937  
00001D90                          1938  
00001D90                          1939  
00001D90                          1940  EA_QUICK:
00001D90                          1941      ;FIGURE WHAT KIND? (ADDQ,SUBQ,MOVEQ)
00001D90                          1942      ;ADDQ/SUBQ  -->  opcode = 0101 (stored in D0)
00001D90                          1943      ;MOVEQ      -->  opcode = 0111 (stored in D0)
00001D90  14FC 0009               1944      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001D94  14FC 0023               1945      MOVE.B  #'#',(A2)+                  ;add a # to buffer
00001D98  14FC 0024               1946      MOVE.B  #'$',(A2)+                  ;add a $ to buffer
00001D9C                          1947      
00001D9C  2200                    1948      MOVE.L  D0,D1                       ;should move into D1
00001D9E                          1949      
00001D9E                          1950      ;check for MOVEQ
00001D9E  EC49                    1951      LSR.W   #right6,D1
00001DA0  EC49                    1952      LSR.W   #right6,D1  
00001DA2  B27C 0007               1953      CMP.W   #$7,D1
00001DA6  6700 003A               1954      BEQ     EA_QUICK_MOVEQ
00001DAA                          1955      
00001DAA  4241                    1956      CLR     D1                          ;else not MOVEQ, reset D1 and continue with ADDQ / SUBQ
00001DAC  2200                    1957      MOVE.L  D0,D1
00001DAE  0241 0E00               1958      ANDI.W  #dest_reg,D1                ;isolate destination register(11,10,9)
00001DB2  E049                    1959      LSR.W   #right8,D1                  ;shift 8 times
00001DB4  E249                    1960      LSR.W   #right1,D1                  ;shift 1 time for total of 9 times
00001DB6                          1961      
00001DB6                          1962      ;at this point we have our number, so convert to ASCII and put on buffer
00001DB6  0601 0030               1963      ADDI.B  #$30,D1                     ;convert to ASCII
00001DBA  14C1                    1964      MOVE.B  D1,(A2)+                    ;put on buffer
00001DBC                          1965      
00001DBC                          1966      
00001DBC                          1967      ;ready for destination address
00001DBC  14FC 002C               1968      MOVE.B  #',',(A2)+                  ;add ',' to buffer  
00001DC0  41F9 00001FCE           1969      LEA     EA_MODE_TABLE,A0            ;load table
00001DC6                          1970      
00001DC6                          1971      
00001DC6                          1972      ;isolate source mode
00001DC6  2800                    1973      MOVE.L  D0,D4
00001DC8  E64C                    1974      LSR.W   #3,D4
00001DCA  0244 0007               1975      ANDI.W  #$7,D4
00001DCE  C8FC 0006               1976      MULU    #6,D4
00001DD2                          1977          
00001DD2                          1978      ;isolate source register
00001DD2  2A00                    1979      MOVE.L  D0,D5
00001DD4  0245 0007               1980      ANDI.W  #$7,D5
00001DD8                          1981      
00001DD8  4EB9 00001FCA           1982      JSR    EA_JMP_HELPER
00001DDE                          1983      
00001DDE  4EF8 195C               1984      JMP     EA_FINISH
00001DE2                          1985      
00001DE2                          1986      ;LSR.W       #right12,D1         ;shift D1 by 12 bits, leaving just 4 bits      --> gives shift count error
00001DE2                          1987      ;CMP.W       #$5,D1
00001DE2                          1988      ;BEQ         EA_ADDQ_SUBQ
00001DE2                          1989      
00001DE2                          1990  EA_QUICK_MOVEQ:
00001DE2  2200                    1991      MOVE.L  D0,D1
00001DE4  0241 00FF               1992      ANDI.W  #$00FF,D1               ;isolate bits 7-0
00001DE8                          1993      
00001DE8                          1994      ;our bits are isolated in D1, move to D7 for ITOA function
00001DE8  2E01                    1995      MOVE.L  D1,D7
00001DEA  4EB9 00002138           1996      JSR     EA_ITOA_BYTE_CONVERT
00001DF0                          1997      
00001DF0  14FC 002C               1998      MOVE.B  #',',(A2)+                  ;add ',' to buffer
00001DF4  14FC 0044               1999      MOVE.B  #'D',(A2)+                  ;add ',' to buffer
00001DF8  2200                    2000      MOVE.L  D0,D1
00001DFA  0241 0F00               2001      ANDI.W  #nibble2,D1
00001DFE  E049                    2002      LSR.W   #8,D1
00001E00  E249                    2003      LSR.W   #1,D1
00001E02                          2004      
00001E02                          2005      ;at this point we have our number, so convert to ASCII and put on buffer
00001E02  0601 0030               2006      ADDI.B  #$30,D1                     ;convert to ASCII
00001E06  14C1                    2007      MOVE.B  D1,(A2)+                    ;put on buffer
00001E08                          2008  
00001E08  4EF8 195C               2009      JMP     EA_FINISH
00001E0C                          2010  
00001E0C                          2011  EA_BRANCH:
00001E0C                          2012      ;PROGRAM COUNTER @ A5
00001E0C                          2013      ;BRA or BSR
00001E0C                          2014      ;displacement bits are 7-0 
00001E0C  2200                    2015      MOVE.L  D0,D1
00001E0E  0241 00FF               2016      ANDI.W  #$00FF,D1               ;isolate bits 7-0
00001E12                          2017      ;PERFORM CHECKS 0000 0000 = WORD VALUE, 1111 1111 = LONG VALUE
00001E12                          2018      
00001E12  B23C 0000               2019      CMP.B   #$00,D1
00001E16  6700 0086               2020      BEQ     EA_BRANCH_16
00001E1A                          2021      
00001E1A                          2022      ;if not 0
00001E1A  B23C 00FF               2023      CMP.B   #$FF,D1
00001E1E  6700 0096               2024      BEQ     EA_BRANCH_32
00001E22                          2025      
00001E22                          2026      ;OTHERWISE... HANDLE 8-BITDISPLACEMENT IN OPCODE!    
00001E22  2200                    2027      MOVE.L  D0,D1
00001E24  0241 00FF               2028      ANDI.W  #$00FF,D1    
00001E28  6000 0002               2029      BRA     EA_BRANCH_8_BIT_DISPLACEMENT
00001E2C                          2030      
00001E2C                          2031      
00001E2C                          2032  
00001E2C                          2033  EA_BRANCH_8_BIT_DISPLACEMENT:
00001E2C                          2034      ;D0,D1 HAVE OPCODE
00001E2C  EE49                    2035      LSR     #7,D1
00001E2E                          2036      
00001E2E  B23C 0000               2037      CMP.B   #0,D1
00001E32  6700 0006               2038      BEQ     EA_BRANCH_POSITIVE              ;bit = 0
00001E36  6000 001A               2039      BRA     EA_BRANCH_NEGATIVE              ;bit = 1
00001E3A                          2040  
00001E3A                          2041  EA_BRANCH_POSITIVE:
00001E3A  2200                    2042      MOVE.L  D0,D1
00001E3C                          2043      ;D1 = 6004
00001E3C                          2044      
00001E3C  0241 00FF               2045      ANDI.W  #$00FF,D1                   ;isolate displacement
00001E40  3E0D                    2046      MOVE.W  A5,D7                       ;current address    
00001E42  DE41                    2047      ADD     D1,D7                       ;add    
00001E44  14FC 0009               2048      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001E48                          2049      
00001E48  4EB9 00001E6C           2050      JSR     EA_BRANCH_ITOA_HELPER
00001E4E  4EF8 195C               2051      JMP     EA_FINISH
00001E52                          2052  
00001E52                          2053  EA_BRANCH_NEGATIVE:
00001E52  2200                    2054      MOVE.L  D0,D1
00001E54  0241 00FF               2055      ANDI.W  #$00FF,D1
00001E58  4401                    2056      NEG.B   D1  
00001E5A                          2057      
00001E5A  3E0D                    2058      MOVE.W  A5,D7
00001E5C  9E41                    2059      SUB     D1,D7
00001E5E                          2060  
00001E5E  14FC 0009               2061      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001E62                          2062  
00001E62  4EB9 00001E6C           2063      JSR     EA_BRANCH_ITOA_HELPER
00001E68  4EF8 195C               2064      JMP     EA_FINISH
00001E6C                          2065  
00001E6C                          2066  EA_BRANCH_ITOA_HELPER:
00001E6C                          2067      ;VALUE IN D2 --> 00000400
00001E6C  2407                    2068      MOVE.L  D7,D2                   ;PRESERVE COPY
00001E6E  E04F                    2069      LSR.W   #right8,D7
00001E70  E04F                    2070      LSR.W   #right8,D7
00001E72  E04F                    2071      LSR.W   #right8,D7
00001E74  4EB9 00002138           2072      JSR     EA_ITOA_BYTE_CONVERT
00001E7A                          2073  
00001E7A  2E02                    2074      MOVE.L  D2,D7
00001E7C  E04F                    2075      LSR.W   #right8,D7
00001E7E  E04F                    2076      LSR.W   #right8,D7    
00001E80  4EB9 00002138           2077      JSR     EA_ITOA_BYTE_CONVERT
00001E86                          2078  
00001E86  2E02                    2079      MOVE.L  D2,D7
00001E88  E04F                    2080      LSR.W   #right8,D7
00001E8A  4EB9 00002138           2081      JSR     EA_ITOA_BYTE_CONVERT
00001E90                          2082  
00001E90  2E02                    2083      MOVE.L  D2,D7
00001E92  4EB9 00002138           2084      JSR     EA_ITOA_BYTE_CONVERT
00001E98                          2085  
00001E98  4EF9 00002170           2086      JMP     EA_ITOA_DONE
00001E9E                          2087  
00001E9E                          2088  EA_BRANCH_16:
00001E9E  3215                    2089      MOVE.W  (A5),D1                    ;CHECK WHERE POINTER IS WHEN HITS HERE
00001EA0                          2090      ;D1 WILL HAVE OUR DISPLACEMENT (0E32)
00001EA0                          2091      ;ADD 0E32 TO PC + 2
00001EA0  3E01                    2092      MOVE.W  D1,D7
00001EA2  DE4D                    2093      ADD.W   A5,D7
00001EA4                          2094      ;SUBI.B  #2,D7
00001EA4                          2095      
00001EA4  14FC 0009               2096      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001EA8  14FC 0024               2097      MOVE.B  #'$',(A2)+                  ;add '$' to buffer
00001EAC                          2098      
00001EAC                          2099      ;convert to ASCII and put on buffer
00001EAC                          2100      ;D7 HAS DISPLACEMENT   
00001EAC  4EB9 00001EB6           2101      JSR     BRANCH_16_ITOA
00001EB2                          2102      
00001EB2  4EF8 195C               2103      JMP     EA_FINISH
00001EB6                          2104  
00001EB6                          2105  EA_BRANCH_32:
00001EB6                          2106      ;come back and implement branch 32
00001EB6                          2107  
00001EB6                          2108  
00001EB6                          2109  
00001EB6                          2110  BRANCH_16_ITOA:
00001EB6                          2111      ;D7 HAS OUR DISPLACEMENT... CONVERT TO ASCII!   ;D7 = 1234
00001EB6  E04F                    2112      LSR.W   #right8,D7                              ;D7 = 0012
00001EB8  4EB9 00002138           2113      JSR     EA_ITOA_BYTE_CONVERT                    ;BUFFER WILL HAVE 12
00001EBE  3E1D                    2114      MOVE.W  (A5)+,D7                                ;D7 = 0E32
00001EC0  DE4D                    2115      ADD.W   A5,D7                                   ;D7 = 123
00001EC2  5507                    2116      SUBI.B  #2,D7                                   ;SUBI 2 to account for post increment of A5
00001EC4  0247 00FF               2117      ANDI.W  #$00FF,D7                               ;D7 = 0034
00001EC8  4EB9 00002138           2118      JSR     EA_ITOA_BYTE_CONVERT                    ;BUFFER WILL HAVE 1234
00001ECE                          2119      
00001ECE  4EF9 00002170           2120      JMP     EA_ITOA_DONE
00001ED4                          2121  
00001ED4                          2122  
00001ED4                          2123  EA_MATH:
00001ED4                          2124      ;source mode 3, 4, 5 | source register 0, 1, 2 | destination register 11, 10, 9
00001ED4  14FC 0009               2125      MOVE.B  #$09, (A2)+             ;add a ' ' to buffer
00001ED8  41F9 00001FCE           2126      LEA     EA_MODE_TABLE,A0        ;load mode table
00001EDE                          2127      
00001EDE                          2128      ;isolate source mode
00001EDE  2800                    2129      MOVE.L  D0,D4
00001EE0  E64C                    2130      LSR.W   #3,D4
00001EE2  0244 0007               2131      ANDI.W  #$7,D4
00001EE6  C8FC 0006               2132      MULU    #6,D4
00001EEA                          2133      
00001EEA                          2134      ;isolate source register
00001EEA  2A00                    2135      MOVE.L  D0,D5
00001EEC  0245 0007               2136      ANDI.W  #$7,D5
00001EF0                          2137      
00001EF0  4EB9 00001FCA           2138      JSR     EA_JMP_HELPER
00001EF6                          2139      
00001EF6  14FC 002C               2140      MOVE.B  #',',(A2)+              ;add a ',' to buffer
00001EFA                          2141      
00001EFA                          2142      ;condition for ADDA - opcode == 1101 && bits 7,6 == 11
00001EFA                          2143      ;check for ADDA and leave if yes, otherwise continue
00001EFA  2200                    2144      MOVE.L  D0,D1                   ;complete opcode in D1
00001EFC  EC49                    2145      LSR.W   #6,D1                   ;shift right 6
00001EFE  EC49                    2146      LSR.W   #6,D1                   ;shift another 6 to = 12 total
00001F00                          2147      
00001F00  B27C 000D               2148      CMP     #$D,D1                  ;check if opcode = 1101
00001F04  6600 002C               2149      BNE     EA_MATH_CONTINUE        ;if not 1101, skip and go to math
00001F08                          2150      
00001F08                          2151      ;if we are here, we know opcode is 1101 and further check
00001F08  2200                    2152      MOVE.L  D0,D1
00001F0A  EC49                    2153      LSR.W   #6,D1
00001F0C  0241 0003               2154      ANDI.W  #3,D1
00001F10  B23C 0003               2155      CMP.B   #3,D1
00001F14  6600 001C               2156      BNE     EA_MATH_CONTINUE
00001F18                          2157      
00001F18                          2158      ;if d1 == 3, both conditions met so process as ADDA
00001F18                          2159      ;destination mode is 1 (address register)
00001F18  7801                    2160      MOVE.L  #1,D4
00001F1A  C8FC 0006               2161      MULU    #6,D4
00001F1E                          2162      
00001F1E                          2163      ;isolate destination register 
00001F1E  2A00                    2164      MOVE.L  D0,D5
00001F20  E84D                    2165      LSR.W   #4,D5
00001F22  EA4D                    2166      LSR.W   #5,D5                      
00001F24  0245 0007               2167      ANDI.W  #$7,D5   
00001F28                          2168   
00001F28  4EB9 00001FCA           2169      JSR     EA_JMP_HELPER 
00001F2E  4EF8 195C               2170      JMP     EA_FINISH
00001F32                          2171          
00001F32                          2172  EA_MATH_CONTINUE:       
00001F32                          2173      ;destination mode is 0 (data register)
00001F32  7800                    2174      MOVE.L  #0,D4
00001F34  C8FC 0006               2175      MULU    #6,D4
00001F38                          2176      
00001F38                          2177      ;isolate destination register 
00001F38  2A00                    2178      MOVE.L  D0,D5
00001F3A  E84D                    2179      LSR.W   #4,D5
00001F3C  EA4D                    2180      LSR.W   #5,D5                      
00001F3E  0245 0007               2181      ANDI.W  #$7,D5  
00001F42                          2182      
00001F42  4EB9 00001FCA           2183      JSR     EA_JMP_HELPER 
00001F48  4EF8 195C               2184      JMP     EA_FINISH
00001F4C                          2185      
00001F4C                          2186  
00001F4C                          2187  EA_ROTATION:
00001F4C  14FC 0009               2188      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001F50  2200                    2189      MOVE.L  D0,D1                       ;complete opcode
00001F52                          2190      
00001F52  0241 00FF               2191      ANDI.W  #$00FF,D1
00001F56  EC49                    2192      LSR.W   #6,D1
00001F58  B27C 0003               2193      CMP     #3,D1
00001F5C  6700 0016               2194      BEQ     EA_ROTATION_MODE_7
00001F60                          2195      
00001F60  2200                    2196      MOVE.L  D0,D1
00001F62  EA49                    2197      LSR.W   #5,D1                       ;shift right 5
00001F64  0241 0001               2198      ANDI.W  #1,D1
00001F68                          2199      
00001F68  B27C 0000               2200      CMP     #0,D1
00001F6C  6700 0050               2201      BEQ     EA_ROTATION_IMMEDIATE       ;it is immediate value
00001F70  6000 0052               2202      BRA     EA_ROTATION_REGISTER        ;else register 
00001F74                          2203      
00001F74                          2204  EA_ROTATION_MODE_7:
00001F74                          2205      ;WE KNOW IT IS MODE 7 - CHECK FOR IMMEDIATE SHORT OR IMMEDIATE LONG
00001F74  2200                    2206      MOVE.L  D0,D1
00001F76  0241 0007               2207      ANDI.W  #7,D1
00001F7A  B27C 0000               2208      CMP.W   #0,D1   
00001F7E  6700 000C               2209      BEQ     EA_111_ABSOLUTE_SHORT_HELPER
00001F82  4EB9 00002090           2210      JSR     EA_111_ABSOLUTE_LONG   
00001F88  4EF8 195C               2211      JMP     EA_FINISH
00001F8C                          2212  
00001F8C                          2213  EA_111_ABSOLUTE_SHORT_HELPER:
00001F8C  4EB9 0000207C           2214      JSR     EA_111_ABSOLUTE_SHORT
00001F92  4EF8 195C               2215      JMP     EA_FINISH
00001F96                          2216  
00001F96                          2217  EA_ROTATION_CONTINUE:
00001F96  2200                    2218      MOVE.L  D0,D1                       ;get rotation value
00001F98  0241 0F00               2219      ANDI.W  #nibble2,D1                 ;isolate nibble 2
00001F9C  E049                    2220      LSR.W   #8,D1
00001F9E  E249                    2221      LSR.W   #1,D1                       :total of 9 shifts right
00001FA0                          2222      
00001FA0                          2223      ;at this point we have our number, so convert to ASCII and put on buffer
00001FA0  0601 0030               2224      ADDI.B  #$30,D1                     ;convert to ASCII
00001FA4  14C1                    2225      MOVE.B  D1,(A2)+                    ;put on buffer
00001FA6                          2226      
00001FA6  14FC 002C               2227      MOVE.B  #',',(A2)+                  ;add ',' to buffer 
00001FAA  14FC 0044               2228      MOVE.B  #'D',(A2)+                  ;add 'D' to buffer
00001FAE                          2229      
00001FAE  2200                    2230      MOVE.L  D0,D1                       ;complete opcode
00001FB0  0241 0007               2231      ANDI.W  #7,D1                       
00001FB4                          2232      
00001FB4  0601 0030               2233      ADDI.B  #$30,D1                     ;convert to ASCII
00001FB8  14C1                    2234      MOVE.B  D1,(A2)+                    ;put on buffer
00001FBA                          2235      
00001FBA  4EF8 195C               2236      JMP     EA_FINISH                   ;done
00001FBE                          2237  
00001FBE                          2238  EA_ROTATION_IMMEDIATE:
00001FBE  14FC 0023               2239      MOVE.B  #'#',(A2)+                  ;add '#' to buffer
00001FC2  60D2                    2240      BRA     EA_ROTATION_CONTINUE
00001FC4                          2241      
00001FC4                          2242  EA_ROTATION_REGISTER:
00001FC4  14FC 0044               2243      MOVE.B  #'D',(A2)+                  ;add 'D' to buffer
00001FC8  60CC                    2244      BRA     EA_ROTATION_CONTINUE
00001FCA                          2245      
00001FCA                          2246  EA_JMP_HELPER
00001FCA  4EF0 4000               2247      JMP     0(A0,D4)
00001FCE                          2248  
00001FCE                          2249  
00001FCE                          2250  ;********************************************  EA_MODE_TABLE  ****************************************************  
00001FCE                          2251  EA_MODE_TABLE:
00001FCE  4EF9 00001FFE           2252      JMP     EA_MODE_000
00001FD4  4EF9 0000200C           2253      JMP     EA_MODE_001
00001FDA  4EF9 0000201A           2254      JMP     EA_MODE_010
00001FE0  4EF9 00002030           2255      JMP     EA_MODE_011
00001FE6  4EF9 0000204A           2256      JMP     EA_MODE_100
00001FEC  4EF9 00002064           2257      JMP     EA_MODE_101
00001FF2  4EF9 00002064           2258      JMP     EA_MODE_110
00001FF8  4EF9 00002064           2259      JMP     EA_MODE_111
00001FFE                          2260      ;JMP     EA_MODE_FINISH
00001FFE                          2261  
00001FFE                          2262  ;********************************************  EA_MODE_XXX  ****************************************************    
00001FFE                          2263  EA_MODE_000:                                        ;Data register 'Dn'
00001FFE  14FC 0044               2264      MOVE.B  #'D',(A2)+                              ;put D on buffer
00002002  1605                    2265      MOVE.B D5,D3                                    ;move to d3 for conversion
00002004  4EB9 000020A4           2266      JSR     EA_HEX_TO_ASCII                         ;puts register on buffer  
0000200A  4E75                    2267      RTS
0000200C                          2268      
0000200C                          2269  EA_MODE_001:                                        ;Address Register 'An'
0000200C  14FC 0041               2270      MOVE.B  #'A',(A2)+                              ;put A on buffer
00002010  1605                    2271      MOVE.B  D5,D3                                   ;move to d3 for conversion
00002012  4EB9 000020A4           2272      JSR     EA_HEX_TO_ASCII                         ;puts register on buffer  
00002018  4E75                    2273      RTS
0000201A                          2274  
0000201A                          2275  EA_MODE_010:                                        ;Address direct --> '(An)'
0000201A  14FC 0028               2276      MOVE.B  #'(',(A2)+                              ;put ( on buffer
0000201E  14FC 0041               2277      MOVE.B  #'A',(A2)+                              ;put A on buffer
00002022  1605                    2278      MOVE.B  D5,D3                                   ;move to D3 for conversion
00002024  4EB9 000020A4           2279      JSR     EA_HEX_TO_ASCII                         ;convert and put on buffer   
0000202A  14FC 0029               2280      MOVE.B  #')',(A2)+                              ;put ) on buffer
0000202E  4E75                    2281      RTS
00002030                          2282  
00002030                          2283  EA_MODE_011:                                        ;Address with Postincrement --> '(An)+' 
00002030  14FC 0028               2284      MOVE.B  #'(',(A2)+                              ;put ( on buffer
00002034  14FC 0041               2285      MOVE.B  #'A',(A2)+                              ;put A on buffer
00002038  1605                    2286      MOVE.B  D5,D3                                   ;move to D3 for conversion
0000203A  4EB9 000020A4           2287      JSR     EA_HEX_TO_ASCII                         ;convert and put on buffer   
00002040  14FC 0029               2288      MOVE.B  #')',(A2)+                              ;put ) on buffer
00002044  14FC 002B               2289      MOVE.B  #'+',(A2)+                              ;put + on buffer
00002048  4E75                    2290      RTS
0000204A                          2291  
0000204A                          2292  EA_MODE_100:                                        ;Address with Predecrement --> '-(An)'
0000204A  14FC 002D               2293      MOVE.B  #'-',(A2)+                              ;put - on buffer
0000204E  14FC 0028               2294      MOVE.B  #'(',(A2)+                              ;put ( on buffer
00002052  14FC 0041               2295      MOVE.B  #'A',(A2)+                              ;put A on buffer
00002056  1605                    2296      MOVE.B  D5,D3                                   ;move to D3 for conversion
00002058  4EB9 000020A4           2297      JSR     EA_HEX_TO_ASCII                         ;convert and put on buffer   
0000205E  14FC 0029               2298      MOVE.B  #')',(A2)+                              ;put ) on buffer
00002062  4E75                    2299      RTS
00002064                          2300  
00002064                          2301  
00002064                          2302  ;unsupported
00002064                          2303  EA_MODE_101:                                        
00002064                          2304  ;Address with Displacement --> '(d16, An)
00002064                          2305      
00002064                          2306  ;unsupported
00002064                          2307  EA_MODE_110:
00002064                          2308  
00002064                          2309  
00002064                          2310  
00002064                          2311  ;some form of immediate data: short, long, immediate
00002064                          2312  EA_MODE_111:
00002064                          2313      ;D4 = MODE | D5 = register (000, 001, 100)
00002064                          2314      ;000 = Absolute Short (xxx).w
00002064                          2315      ;001 = Absolute Long (xxx).l
00002064                          2316      ;100 = Immediate data
00002064                          2317      
00002064  BA3C 0000               2318      CMP.B   #000,D5
00002068  6700 0012               2319      BEQ     EA_111_ABSOLUTE_SHORT
0000206C  BA3C 0001               2320      CMP.B   #001,D5
00002070  6700 001E               2321      BEQ     EA_111_ABSOLUTE_LONG
00002074  BA3C 0064               2322      CMP.B   #100,D5
00002078  6700 002A               2323      BEQ     EA_111_IMMEDIATE
0000207C                          2324      
0000207C                          2325      ;HANDLE ERROR
0000207C                          2326              
0000207C                          2327      
0000207C                          2328  EA_111_ABSOLUTE_SHORT:
0000207C                          2329      ;A5 is looking at correct spot
0000207C                          2330      ;ADD WORD VALUE AT A5 ON TO BUFFER AT A2 AND INCREMENT BY WORD
0000207C  14FC 0024               2331      MOVE.B  #'$',(A2)+                              ;put $ on buffer
00002080  3E15                    2332      MOVE.W  (A5),D7
00002082  4246                    2333      CLR     D6
00002084  1C3C 0001               2334      MOVE.B  #01,D6                                  ;word size in EA_ITOA_IMMEDIATE
00002088  4EB9 000020D6           2335      JSR     EA_ITOA_IMMEDIATE
0000208E  4E75                    2336      RTS
00002090                          2337  
00002090                          2338  EA_111_ABSOLUTE_LONG:
00002090  14FC 0024               2339      MOVE.B  #'$',(A2)+                              ;put $ on buffer
00002094  3E15                    2340      MOVE.W  (A5),D7
00002096  4246                    2341      CLR     D6
00002098  1C3C 0002               2342      MOVE.B  #02,D6                                  ;long size in EA_ITOA_IMMEDIATE        
0000209C  4EB9 000020D6           2343      JSR     EA_ITOA_IMMEDIATE
000020A2  4E75                    2344      RTS
000020A4                          2345  
000020A4                          2346  EA_111_IMMEDIATE:
000020A4                          2347      
000020A4                          2348  
000020A4                          2349     
000020A4                          2350      
000020A4                          2351  
000020A4                          2352  EA_HEX_TO_ASCII:
000020A4  0603 0030               2353      ADDI.B      #$30,D3                     ;add $30 to D1 to convert
000020A8  14C3                    2354      MOVE.B      D3,(A2)+                    ;add to buffer and increment to next position
000020AA  4E75                    2355      RTS     
000020AC                          2356  
000020AC                          2357  
000020AC                          2358  EA_CHECK_SIZE:
000020AC  4246                    2359      CLR     D6
000020AE  2C00                    2360      MOVE.L  D0,D6                           ;complete opcode --> D6
000020B0  0246 00F0               2361      ANDI.W  #nibble3,D6                     ;isolating nibble 3
000020B4  EC4E                    2362      LSR.W   #right6,D6                      ;shifting bits 7,6 --> 1,0
000020B6                          2363      
000020B6  BC7C 0000               2364      CMP     #00,D6
000020BA  6700 000E               2365      BEQ     EA_SIZE_BYTE
000020BE  BC7C 0001               2366      CMP     #01,D6
000020C2  6700 000A               2367      BEQ     EA_SIZE_WORD
000020C6  6000 000A               2368      BRA     EA_SIZE_LONG
000020CA                          2369  
000020CA                          2370  EA_SIZE_BYTE:
000020CA  3E1D                    2371      MOVE.W  (A5)+,D7
000020CC                          2372      ;MOVE.B  #4,D3;                          SET UP COUNTER
000020CC  4E75                    2373      RTS
000020CE                          2374  
000020CE                          2375  EA_SIZE_WORD:
000020CE  3E15                    2376      MOVE.W  (A5),D7
000020D0                          2377      ;MOVE.B  #4,D3;                          SET UP COUNTER
000020D0  4E75                    2378      RTS
000020D2                          2379  
000020D2                          2380  EA_SIZE_LONG:
000020D2  3E15                    2381      MOVE.W  (A5),D7
000020D4                          2382      ;MOVE.B  #8,D3;                          SET UP COUNTER
000020D4  4E75                    2383      RTS
000020D6                          2384  
000020D6                          2385  
000020D6                          2386  
000020D6                          2387  EA_ITOA_IMMEDIATE:
000020D6                          2388      ;D3 = counter, D7 = value to be converted, D6 = size
000020D6  BC3C 0000               2389      CMP.B   #%00,D6
000020DA  6700 0012               2390      BEQ     EA_ITOA_BYTE
000020DE  BC3C 0001               2391      CMP.B   #%01,D6
000020E2  6700 0016               2392      BEQ     EA_ITOA_WORD
000020E6  BC3C 0002               2393      CMP.B   #%10,D6     
000020EA  6700 0024               2394      BEQ     EA_ITOA_LONG
000020EE                          2395      
000020EE                          2396  
000020EE                          2397  ;EA_IT0A_IMMEDIATE_LOOP
000020EE                          2398  ;    CMP.B   #0,D3                       ;check if loop done
000020EE                          2399  ;    BEQ     EA_ITOA_FINISH              ;if = 0, loop done
000020EE                          2400      
000020EE                          2401  EA_ITOA_BYTE:
000020EE  4EB9 00002138           2402      JSR     EA_ITOA_BYTE_CONVERT
000020F4                          2403      
000020F4  4EF9 00002170           2404      JMP     EA_ITOA_DONE
000020FA                          2405  
000020FA                          2406  
000020FA                          2407  EA_ITOA_WORD:
000020FA  E04F                    2408      LSR.W   #right8,D7
000020FC  4EB9 00002138           2409      JSR     EA_ITOA_BYTE_CONVERT
00002102  3E1D                    2410      MOVE.W  (A5)+,D7
00002104  4EB9 00002138           2411      JSR     EA_ITOA_BYTE_CONVERT
0000210A                          2412      
0000210A  4EF9 00002170           2413      JMP     EA_ITOA_DONE
00002110                          2414      
00002110                          2415  EA_ITOA_LONG:
00002110  E04F                    2416      LSR.W   #right8,D7
00002112  4EB9 00002138           2417      JSR     EA_ITOA_BYTE_CONVERT
00002118  3E1D                    2418      MOVE.W  (A5)+,D7
0000211A  4EB9 00002138           2419      JSR     EA_ITOA_BYTE_CONVERT
00002120                          2420  
00002120  3E15                    2421      MOVE.W  (A5),D7
00002122  E04F                    2422      LSR.W   #right8,D7
00002124  4EB9 00002138           2423      JSR     EA_ITOA_BYTE_CONVERT
0000212A  3E1D                    2424      MOVE.W  (A5)+,D7
0000212C  4EB9 00002138           2425      JSR     EA_ITOA_BYTE_CONVERT
00002132                          2426  
00002132  4EF9 00002170           2427      JMP     EA_ITOA_DONE
00002138                          2428  
00002138                          2429  EA_ITOA_BYTE_CONVERT:
00002138  3607                    2430      MOVE.W  D7,D3
0000213A  0243 00F0               2431      ANDI.W  #$F0,D3
0000213E  E84B                    2432      LSR.W   #right4,D3
00002140  4EB9 00002154           2433      JSR     EA_ITOA_NIBBLE_CONVERT
00002146                          2434      
00002146  3607                    2435      MOVE.W  D7,D3
00002148  0243 000F               2436      ANDI.W  #$0F,D3
0000214C  4EB9 00002154           2437      JSR     EA_ITOA_NIBBLE_CONVERT
00002152  4E75                    2438      RTS
00002154                          2439  
00002154                          2440  EA_ITOA_NIBBLE_CONVERT:
00002154  B63C 0009               2441      CMP.B   #9,D3
00002158  6E00 000E               2442      BGT     EA_ITOA_LETTER
0000215C  6000 0002               2443      BRA     EA_ITOA_NUMBER
00002160                          2444  
00002160                          2445  EA_ITOA_HEX2ASCII:
00002160                          2446  
00002160                          2447  
00002160                          2448  
00002160                          2449  EA_ITOA_NUMBER:
00002160  0603 0030               2450      ADDI.B  #$30,D3
00002164  14C3                    2451      MOVE.B  D3,(A2)+
00002166  4E75                    2452      RTS
00002168                          2453  
00002168                          2454  EA_ITOA_LETTER:
00002168  0603 0037               2455      ADDI.B  #$37,D3
0000216C  14C3                    2456      MOVE.B  D3,(A2)+
0000216E  4E75                    2457      RTS
00002170                          2458  
00002170                          2459  EA_ITOA_DONE
00002170  4E75                    2460      RTS
00002172                          2461  
00002172                          2462      
00002172                          2463  ;****************************************** MESSAGES ***************************************************
00002172= 57 65 6C 63 6F 6D ...   2464  welcome_message         DC.B    'Welcome to 68k disassembler',CR,LF,0
00002190                          2465  
00002190= 50 6C 65 61 73 65 ...   2466  get_start_address       DC.B    'Please enter a starting address in hexadecimal',CR,LF,0
000021C1                          2467  
000021C1= 50 6C 65 61 73 65 ...   2468  get_end_address         DC.B    'Please enter an ending address in hexadecimal',CR,LF,0
000021F1                          2469  
000021F1= 49 6E 76 61 6C 69 ...   2470  atoi_error_invalid      DC.B    'Invalid address, characters must be $0-F',CR,LF,0
0000221C                          2471  
0000221C                          2472  
0000221C= 49 6E 76 61 6C 69 ...   2473  error_message_1         DC.B    'Invalid Address: Must be greater than 0',CR,LF,0
00002246                          2474  
00002246= 49 6E 76 61 6C 69 ...   2475  error_message_2         DC.B    'Invalid Address: Must be even',CR,LF,0
00002266                          2476  
00002266= 49 6E 76 61 6C 69 ...   2477  error_message_3         DC.B    'Invalid Address: Must be even',CR,LF,0
00002286                          2478  
00002286= 49 6E 76 61 6C 69 ...   2479  error_message_4         DC.B    'Invalid Address: Must be less than $00FFFFFF',CR,LF,0
000022B5                          2480  
000022B5= 49 6E 76 61 6C 69 ...   2481  error_message_5         DC.B    'Invalid Address: Must be greater than starting address',CR,LF,0
000022EE                          2482  
000022EE= 48 69 74 20 45 6E ...   2483  prompt_enter            DC.B    'Hit Enter to Continue',CR,LF,0
00002306                          2484  
00002306                          2485  
00002306                          2486  ascii_start:
00002306                          2487      DS.w    10          ;specify size later?
0000231A                          2488      
0000231A                          2489  ascii_end:
0000231A                          2490      DS.w    10          ;specify size later?
0000232E                          2491  
0000232E                          2492  buffer                  ;storing op code
0000232E                          2493      DS.W    64          ;do we leave as .w or change to .l ?
000023AE                          2494      
000023AE                          2495  
000023AE                          2496      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_END           231A
ASCII_START         2306
ATOI                17E4
ATOI_DONE           1856
ATOI_ERROR          1856
ATOI_ERROR_INVALID  21F1
ATOI_FORMAT         1846
ATOI_LOOP           17EA
ATOI_LOWERCASE_LETTER  183C
ATOI_NUMBER         1828
ATOI_UPPERCASE_LETTER  1832
BRANCH_16_ITOA      1EB6
BUFFER              232E
BUFFER_SIZE         40
CR                  D
DECODING_LOOP       108A
DEST_MODE           1C0
DEST_REG            E00
DONE                10C8
EA_111_ABSOLUTE_LONG  2090
EA_111_ABSOLUTE_SHORT  207C
EA_111_ABSOLUTE_SHORT_HELPER  1F8C
EA_111_IMMEDIATE    20A4
EA_BRANCH           1E0C
EA_BRANCH_16        1E9E
EA_BRANCH_32        1EB6
EA_BRANCH_8_BIT_DISPLACEMENT  1E2C
EA_BRANCH_ITOA_HELPER  1E6C
EA_BRANCH_NEGATIVE  1E52
EA_BRANCH_POSITIVE  1E3A
EA_CHECK_SIZE       20AC
EA_DESTONLY         1A6C
EA_EXT              1A6C
EA_FINISH           195C
EA_HEX_TO_ASCII     20A4
EA_IMMEDIATE        195E
EA_ITOA_BYTE        20EE
EA_ITOA_BYTE_CONVERT  2138
EA_ITOA_DONE        2170
EA_ITOA_HEX2ASCII   2160
EA_ITOA_IMMEDIATE   20D6
EA_ITOA_LETTER      2168
EA_ITOA_LONG        2110
EA_ITOA_NIBBLE_CONVERT  2154
EA_ITOA_NUMBER      2160
EA_ITOA_WORD        20FA
EA_JMP_HELPER       1FCA
EA_LEA              1A2C
EA_MATH             1ED4
EA_MATH_CONTINUE    1F32
EA_MODE_000         1FFE
EA_MODE_001         200C
EA_MODE_010         201A
EA_MODE_011         2030
EA_MODE_100         204A
EA_MODE_101         2064
EA_MODE_110         2064
EA_MODE_111         2064
EA_MODE_TABLE       1FCE
EA_MOVE             19A0
EA_MOVEA            19E6
EA_MOVEM            1A6C
EA_MOVEM_ADDRREG_TO_MEM  1BD0
EA_MOVEM_DATAREG_TO_MEM  1B48
EA_MOVEM_IMMEDIATE_DESTINATION  1D5C
EA_MOVEM_IMMEDIATE_SOURCE  1D6C
EA_MOVEM_MEM_TO_ADDRREG  1CFE
EA_MOVEM_MEM_TO_DATAREG  1CD0
EA_MOVEM_MEM_TO_REG  1C22
EA_MOVEM_REG_TO_MEM  1A96
EA_QUICK            1D90
EA_QUICK_MOVEQ      1DE2
EA_ROTATION         1F4C
EA_ROTATION_CONTINUE  1F96
EA_ROTATION_IMMEDIATE  1FBE
EA_ROTATION_MODE_7  1F74
EA_ROTATION_REGISTER  1FC4
EA_SIZE_BYTE        20CA
EA_SIZE_LONG        20D2
EA_SIZE_WORD        20CE
EA_START            1900
EA_TRAP             1D90
EA_TYPE_BRANCH      9
EA_TYPE_DESTONLY    4
EA_TYPE_EXT         5
EA_TYPE_IMMEDIATE   0
EA_TYPE_LEA         3
EA_TYPE_MATH        A
EA_TYPE_MOVE        1
EA_TYPE_MOVEA       2
EA_TYPE_MOVEA6      C
EA_TYPE_MOVEM       6
EA_TYPE_QUICK       8
EA_TYPE_ROTATION    B
EA_TYPE_TABLE       190E
EA_TYPE_TRAP        7
ENDA_ERROR_LARGE    18E0
ENDA_ERROR_LESS_THAN_STARTA  18F0
ENDA_ERROR_NOT_EVEN  18D0
ERROR_MESSAGE_1     221C
ERROR_MESSAGE_2     2246
ERROR_MESSAGE_3     2266
ERROR_MESSAGE_4     2286
ERROR_MESSAGE_5     22B5
FILLED_SCREEN       10B4
GET_ENDING_ADDRESS  104A
GET_END_ADDRESS     21C1
GET_STARTING_ADDRESS  1012
GET_START_ADDRESS   2190
ITOA                185A
ITOA_ADDRESS        1864
ITOA_ADDRESS_LOOP   1872
ITOA_BYTE           1864
ITOA_FINISH         18AE
ITOA_HEX2ASCII      188E
ITOA_LETTER         18A6
ITOA_LONG           1864
ITOA_LOOP           185C
ITOA_NUMBER         189E
ITOA_WORD           1864
LF                  A
LINES_PER_SCREEN    F
MOVEM_CARRY         1D3E
MOVEM_CHECK_MULTIPLE  1BA2
MOVEM_LOOP          1D2E
MOVEM_MULTIPLE      1BAA
MOVEM_MULTIPLE_A    1BC8
MOVEM_MULTIPLE_D    1BC0
MOVEM_SET_MIN       1D4E
NIBBLE1             F000
NIBBLE2             F00
NIBBLE3             F0
NIBBLE4             F
OPCODE0000          117E
OPCODE0001          1198
OPCODE0010          119E
OPCODE0011          11B8
OPCODE0100          11D2
OPCODE0101          11EC
OPCODE0110          1208
OPCODE0111          1222
OPCODE1000          1228
OPCODE1001          1244
OPCODE1010          124A
OPCODE1011          1250
OPCODE1100          1256
OPCODE1101          1272
OPCODE1110          128E
OPCODE1111          12AE
OP_0000_TABLE       12B4
OP_0100_TABLE       1314
OP_0110_TABLE       1374
OP_ADD              16E6
OP_ADDA             1704
OP_ADDI             1436
OP_ADDQ             15A6
OP_AND              16E6
OP_ANDI             13F2
OP_ASL              1726
OP_ASR              1744
OP_BEQ              161A
OP_BRA              15EA
OP_BSR              1602
OP_CHECK_SIZE       1762
OP_CHECK_SIZE_ADDA  17C8
OP_CHECK_SIZE_MOVEM  1786
OP_CLR              15A6
OP_CMP              1690
OP_CMPI             147A
OP_DATA_CLR         1108
OP_DATA_CLR_LOOP    1114
OP_DIVS             1656
OP_DIVU             163A
OP_EOR              16AE
OP_EORI             1458
OP_EXT              15A6
OP_FINISH           1102
OP_JMP              15A6
OP_JSR              15A6
OP_LEA              158E
OP_LSL              1762
OP_LSR              1762
OP_MOVEAL           14C0
OP_MOVEAW           150C
OP_MOVEB            149C
OP_MOVEL            14E8
OP_MOVEM            1568
OP_MOVEQ            161A
OP_MOVEW            1534
OP_MULS             16CA
OP_MULU             16AE
OP_NOP              1558
OP_NOT              15A6
OP_OR               1672
OP_ORI              13D4
OP_ROL              1762
OP_ROR              1762
OP_RTE              15A6
OP_RTS              15A6
OP_SIZE_BYTE        17AA
OP_SIZE_LONG        17BE
OP_SIZE_WORD        17B4
OP_START            10CC
OP_STOP             15A6
OP_SUB              1672
OP_SUBI             1414
OP_SUBQ             15C8
OP_TABLE            111E
OP_TRAP             15A6
OP_UNSUPPORTED_OPCODE  1762
PROMPT_ENTER        22EE
REPEAT_OR_FINISH    10AE
RIGHT1              1
RIGHT10             A
RIGHT12             C
RIGHT16             10
RIGHT2              2
RIGHT24             18
RIGHT3              3
RIGHT4              4
RIGHT5              5
RIGHT6              6
RIGHT7              7
RIGHT8              8
RIGHT9              9
STACK               A0000
START               1000
STARTA_ERROR_LESS_THAN_ZERO  18B0
STARTA_ERROR_NOT_EVEN  18C0
START_DECODING      1088
VALIDATE_BEGINNING  18B0
WELCOME             1006
WELCOME_MESSAGE     2172
