00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/15/2021 9:32:25 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler V1.8(ish)
00000000                             3  * Written by : Brent and Parker
00000000                             4  * Date       : 3/10/21
00000000                             5  * Description: Final Project for CSS 422
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  ;************************ Define Constants ********************************* 
00000000  =0000000D                  9  CR                  EQU     $0D     ;carriage return
00000000  =0000000A                 10  LF                  EQU     $0a     ;line feed
00000000  =000A0000                 11  stack               EQU     $000A0000
00000000  =0000001E                 12  lines_per_screen    EQU     30
00000000  =00000040                 13  buffer_size         EQU     64      ;size of buffer
00000000  =0000F000                 14  nibble1             EQU     $F000   ;1st nibble in code (bits 15-12)
00000000  =00000F00                 15  nibble2             EQU     $0F00   ;2nd nibble in code (bits 11-8)
00000000  =000000F0                 16  nibble3             EQU     $00F0   ;3rd nibble in code (bits 7-4)
00000000  =0000000F                 17  nibble4             EQU     $000F   ;4th nibble in code (bits 3-0)
00000000  =00000001                 18  right1              EQU     1       ;shift 1 time
00000000  =00000002                 19  right2              EQU     2       ;shift 2 times
00000000  =00000003                 20  right3              EQU     3       ;shift 3 times to extract src mode
00000000  =00000004                 21  right4              EQU     4       ;shift 4 times to extract 3rd nibble
00000000  =00000005                 22  right5              EQU     5       ;shift 5 times (unused)
00000000  =00000006                 23  right6              EQU     6       ;shift 6 times to extract dst mode
00000000  =00000007                 24  right7              EQU     7       ;shift 7 times
00000000  =00000008                 25  right8              EQU     8       ;shift 8 to extract 2nd nibble
00000000  =00000009                 26  right9              EQU     9       ;shift 9 times to check 2nd nibble?
00000000  =0000000A                 27  right10             EQU     10      ;shift 10
00000000  =0000000C                 28  right12             EQU     12      ;shift 12 to extract 3rd byte
00000000  =00000010                 29  right16             EQU     16      ;shift 16 to extract 2nd byte
00000000  =00000018                 30  right24             EQU     24      ;shift 24 to extract 1st byte
00000000  =000001C0                 31  dest_mode           EQU     $01C0   ; --> 0000 0001 1100 0000 (used for destination in MOVE/MOVEA
00000000  =00000E00                 32  dest_reg            EQU     $0E00   ;destination register (0000 0111 0000 0000)
00000000                            33  
00000000  =00000000                 34  ea_type_immediate   EQU     0
00000000  =00000001                 35  ea_type_move        EQU     1
00000000  =00000002                 36  ea_type_movea       EQU     2
00000000  =0000000C                 37  ea_type_movea6      EQU     12
00000000  =00000003                 38  ea_type_lea         EQU     3
00000000  =00000004                 39  ea_type_destonly    EQU     4
00000000  =00000005                 40  ea_type_ext         EQU     5
00000000  =00000006                 41  ea_type_movem       EQU     6
00000000  =00000007                 42  ea_type_trap        EQU     7
00000000  =00000008                 43  ea_type_quick       EQU     8
00000000  =00000009                 44  ea_type_branch      EQU     9
00000000  =0000000A                 45  ea_type_math        EQU     10
00000000  =0000000B                 46  ea_type_rotation    EQU     11
00000000                            47  
00000000                            48  
00000000                            49  ;flags???
00000000                            50  
00000000                            51  
00000000                            52  
00001000                            53      ORG    $1000
00001000                            54  START:                              ;first instruction of program
00001000  4FF9 000A0000             55      LEA     stack, SP               ;SP @ $A0000
00001006                            56  
00001006                            57  
00001006                            58  
00001006                            59  ;********************************** Welcome Message ******************************************** 
00001006                            60  WELCOME:
00001006  43F9 00002016             61      LEA     welcome_message,A1      ;load the welcome message into A1
0000100C  103C 000E                 62      MOVE.B  #14,D0
00001010  4E4F                      63      TRAP    #15                     ;print contents of welcome_message
00001012                            64  
00001012                            65  
00001012                            66  ;*********************************** Get Starting Address *************************************** 
00001012                            67  GET_STARTING_ADDRESS:
00001012                            68      ;prompt for address
00001012  103C 000E                 69      MOVE.B  #14,D0    
00001016  43F9 00002034             70      LEA     get_start_address,A1    ;load the get_start_address message into A1
0000101C  4E4F                      71      TRAP    #15                     ;print get_start_address
0000101E                            72      
0000101E                            73      ;get user input address, store, and convert
0000101E  43F9 000021AA             74      LEA     ascii_start,A1          ;store
00001024  103C 0002                 75      MOVE.B  #2,D0                   ;get user input    
00001028  4E4F                      76      TRAP    #15                     ;another trap to get input
0000102A  4EB9 000017E4             77      JSR     ATOI                    ;address is now in hex format in memory location
00001030                            78      
00001030                            79      
00001030                            80      ;at this point our address is in D4 in hex
00001030                            81      ;check if > 0
00001030  B8BC 00000000             82      CMP.L   #0,D4                       ;compare to D4
00001036  6F00 0878                 83      BLE     STARTA_ERROR_LESS_THAN_ZERO ;branch to ERROR_LESS_THAN_ZERO if less than 0
0000103A                            84      
0000103A                            85      ;?? MOVE.L  (A1),D3
0000103A                            86      
0000103A                            87      ;address is > 0 so check if even / odd
0000103A  E29C                      88      ROR.L   #1,D4
0000103C  6500 0882                 89      BCS     STARTA_ERROR_NOT_EVEN
00001040  E39C                      90      ROL.L   #1,D4    
00001042                            91      
00001042                            92      ;address is > 0 and verified even
00001042  2A39 000021AA             93      MOVE.l    (ascii_start),D5      ;load into A5
00001048  2A45                      94      MOVE.l    D5,A5                ;load into A5
0000104A                            95  
0000104A                            96  
0000104A                            97  ;******************************** Get Ending Address ******************************************** 
0000104A                            98  GET_ENDING_ADDRESS:
0000104A                            99      ;prompt for address 
0000104A  103C 000E                100      MOVE.B  #14,D0
0000104E  43F9 00002065            101      LEA     get_end_address,A1      ;load the get_end_address message into A1  
00001054  4E4F                     102      TRAP    #15                     ;print get_end_address
00001056                           103      
00001056                           104      ;get user input address, store, and convert
00001056  43F9 000021BE            105      LEA     ascii_end,A1            ;store 
0000105C  103C 0002                106      MOVE.B  #2,D0                   ;get user input
00001060  4E4F                     107      TRAP    #15                     ;another trap to get intput
00001062  4EB9 000017E4            108      JSR ATOI
00001068                           109  
00001068                           110      ;perform checks:
00001068                           111      ;1.) even
00001068  E29C                     112      ROR.L   #1,D4
0000106A  6500 0864                113      BCS     ENDA_ERROR_NOT_EVEN
0000106E  E39C                     114      ROL.L   #1,D4    
00001070                           115      
00001070                           116      ;2.) less than 00FFFFFF
00001070  B8BC 00FFFFFF            117      CMP.L   #$00FFFFFF,D4
00001076  6C00 0868                118      BGE     ENDA_ERROR_LARGE    
0000107A                           119      
0000107A                           120      ;3.) greater than starting address
0000107A  BBC4                     121      CMP.L   D4,A5
0000107C  6C00 0872                122      BGE     ENDA_ERROR_LESS_THAN_STARTA
00001080                           123      
00001080                           124      ;good --> store in A6
00001080  2C39 000021BE            125      MOVE.l    (ascii_end),D6      ;load into D6
00001086  2C46                     126      MOVE.l    D6,A6               ;load into A6
00001088                           127  
00001088                           128  
00001088                           129  ;************************************ Main Loop???? ***********************************************
00001088                           130  ;get pointer to first given address
00001088                           131  ;pull hex code from that address and store in A1?
00001088                           132  ;take hex code and go to OP_TABLE
00001088                           133  
00001088                           134  
00001088                           135  ;A5 = starting address
00001088                           136  ;A6 = ending address
00001088                           137  START_DECODING:
00001088  4282                     138      CLR.L   D2                             ;clear screen line counter
0000108A                           139  
0000108A                           140  DECODING_LOOP:
0000108A  4EB9 000010CC            141      JSR     OP_START                       ;get complete line of instruction to decode   
00001090                           142  
00001090                           143      ;RETURN FROM OP FINISH HERE
00001090                           144      
00001090                           145      ;print buffer to screen
00001090  103C 000D                146      MOVE.B  #$0D, D0
00001094  43F9 000021D2            147      LEA     buffer,A1
0000109A  4E4F                     148      TRAP    #15
0000109C                           149      
0000109C                           150      ;check if we have hit ending address (current memory past ending address)
0000109C  BDCD                     151      CMP.L   A5,A6       ;THE SOURCE OPERAND IS SUBTRACTED FROM THE DESTINATION OPERAND (A6-A5)--> (600 - 400)
0000109E  6F00 000E                152      BLE     REPEAT_OR_FINISH
000010A2  5202                     153      ADDI.B  #1,D2
000010A4  B43C 001E                154      CMP.B   #lines_per_screen,D2
000010A8  6C00 000A                155      BGE     FILLED_SCREEN
000010AC  60DC                     156      BRA     DECODING_LOOP
000010AE                           157      
000010AE                           158  REPEAT_OR_FINISH:    
000010AE  4EF9 000010C8            159      JMP     DONE
000010B4                           160  
000010B4                           161  FILLED_SCREEN:
000010B4  103C 000E                162      MOVE.B  #14,D0
000010B8  43F9 00002192            163      LEA     prompt_enter,A1
000010BE  4E4F                     164      TRAP    #15
000010C0  103C 0005                165      MOVE.B  #$05,D0
000010C4  4E4F                     166      TRAP    #15
000010C6  60C0                     167      BRA     START_DECODING  
000010C8                           168         
000010C8                           169  DONE:
000010C8  FFFF FFFF                170      SIMHALT                                 ; halt simulator
000010CC                           171  
000010CC                           172  
000010CC                           173  
000010CC                           174  ;************************************ OP Stuff *************************************************************************************************************************** 
000010CC                           175  
000010CC                           176  ;A0 = POINTER TO OP_TABLE???
000010CC                           177  ;A1 = 
000010CC                           178  ;A2 = buffer (this is our decoded string that will print to screen)
000010CC                           179  ;A3 = 
000010CC                           180  ;A4 = current memory address for buffer (used for clearing????)
000010CC                           181  ;A5 = starting address / current address in memory
000010CC                           182  ;A6 = ending address
000010CC                           183  ;A7 = SP
000010CC                           184  
000010CC                           185  ;D0
000010CC                           186  ;D1
000010CC                           187  ;D2 = ?
000010CC                           188  ;D3 = buffer size (used for loop = 64)
000010CC                           189  ;D4 = 
000010CC                           190  ;D5
000010CC                           191  ;D6
000010CC                           192  ;D7
000010CC                           193  
000010CC                           194  OP_START
000010CC                           195      ;get complete line? 
000010CC                           196      ;everything happens in here
000010CC                           197      
000010CC  48E7 2000                198      MOVEM.L         D2, -(SP)
000010D0                           199  
000010D0  4EB9 00001108            200      JSR         OP_DATA_CLR         ;clear buffer
000010D6  45F9 000021D2            201      LEA         buffer, A2          ;A2 now points to buffer, which is cleared
000010DC                           202      
000010DC                           203  
000010DC                           204      ;print out current mem address by putting into buffer and then adding a ' ' (tab)
000010DC  7403                     205      MOVE.L      #$0003,D2           ;? BINARY --> 0011 ?
000010DE  4EB9 00001864            206      JSR         ITOA_ADDRESS        ;convert A5 (current address) to ASCII and put in buffer
000010E4  14FC 0009                207      MOVE.B      #$09, (A2)+         ;adds a ' ' to buffer
000010E8                           208      
000010E8                           209      ;at this point buffer has the memory address and a space, ready for op code                     !!TESTED UP UNTIL THIS POINT AND GOOD!!
000010E8                           210      
000010E8  41F9 0000111E            211      LEA         OP_TABLE, A0
000010EE  4280                     212      CLR.L       D0
000010F0  301D                     213      MOVE.W      (A5)+,D0            ;moves opcode from current address into D0
000010F2  2200                     214      MOVE.L      D0,D1               ;should move into D1
000010F4  143C 000C                215      MOVE.B      #right12,D2         ;move immediate value 12 into D2
000010F8  E469                     216      LSR.W       D2,D1               ;shift D1 by 12 bits, leaving just 4 bits (this is our opcode???)
000010FA  C2FC 0006                217      MULU        #6,D1               ;computes opcode table jump displacement
000010FE  4EF0 1000                218      JMP         0(A0,D1)            ;jumps to opcode table entry (A0 = OP_TABLE)
00001102                           219  
00001102                           220  OP_FINISH:
00001102  4CDF 0004                221      MOVEM.L     (SP)+,D2
00001106  4E75                     222      RTS                             ;returns to DECODING_LOOP !?!?!?!?!?
00001108                           223  
00001108                           224  
00001108                           225  OP_DATA_CLR:
00001108  4283                     226      CLR.L       D3                  ; ? What is D3????
0000110A                           227      ;MOVE.B      #buffer_size,D3     ; put 64 into D3
0000110A  163C 0040                228      MOVE.B      #64,D3          ; put 10 into D3                                                                 ;delete after testing and use 64
0000110E  49F9 000021D2            229      LEA         buffer, A4          ; what address register?
00001114                           230  
00001114                           231  OP_DATA_CLR_LOOP:
00001114  18FC 0000                232      MOVE.B      #0, (A4)+
00001118  5343                     233      SUBI        #1, D3
0000111A  6EF8                     234      BGT         OP_DATA_CLR_LOOP
0000111C  4E75                     235      RTS                                 ;need RTS to return
0000111E                           236  
0000111E                           237  
0000111E                           238  ;********************************* jump table ****************************************
0000111E                           239  OP_TABLE:
0000111E  4EF9 0000117E            240      JMP         opcode0000              ;ORI (ANDI, SUBI, ADDI, EORI, CMPI)                                 $0
00001124  4EF9 00001198            241      JMP         opcode0001              ;MOVE.B                                                             $1    
0000112A  4EF9 0000119E            242      JMP         opcode0010              ;MOVEA.L, MOVE.L                                                    $2
00001130  4EF9 000011B8            243      JMP         opcode0011              ;MOVEA.W MOVE.W                                                     $3
00001136  4EF9 000011D2            244      JMP         opcode0100              ;NOP, MOVEM, LEA (CLR, NOT, EXT, TRAP, STOP, RTE, RTS, JSR, JMP     $4
0000113C  4EF9 000011EC            245      JMP         opcode0101              ;ADDQ (SUBQ)                                                        $5
00001142  4EF9 00001208            246      JMP         opcode0110              ;BRA.bw, BSR.bw (BEQ)                                               $6
00001148  4EF9 00001222            247      JMP         opcode0111              ;MOVEQ.l                                                            $7
0000114E  4EF9 00001228            248      JMP         opcode1000              ;DIVU (DIVS, OR)                                                    $8
00001154  4EF9 00001244            249      JMP         opcode1001              ;SUB                                                                $9
0000115A  4EF9 0000124A            250      JMP         opcode1010              ;not assigned                                                       $A
00001160  4EF9 00001250            251      JMP         opcode1011              ;CMP (EOR)                                                          $B
00001166  4EF9 00001256            252      JMP         opcode1100              ;MULU (MULS, AND)                                                   $C
0000116C  4EF9 00001272            253      JMP         opcode1101              ;ADD, ADDA                                                          $D
00001172  4EF9 0000128E            254      JMP         opcode1110              ;ASL, ASR (LSL, LSR, ROL, ROR)                                      $E
00001178  4EF9 000012AE            255      JMP         opcode1111              ;not assigned                                                       $F
0000117E                           256  
0000117E                           257  
0000117E                           258  
0000117E                           259  
0000117E                           260  ;A0 = POINTER TO OP_TABLE???
0000117E                           261  ;A1 = 
0000117E                           262  ;A2 = buffer (this is our decoded string that will print to screen)
0000117E                           263  ;A3 = pointer to op_xxx_table
0000117E                           264  ;A4 = current memory address for buffer (used for clearing????)
0000117E                           265  ;A5 = starting address / current address in memory
0000117E                           266  ;A6 = ending address
0000117E                           267  ;A7 = SP
0000117E                           268  
0000117E                           269  ;D0 = full instruction
0000117E                           270  ;D1 = full instruction for manipulating (temporary)
0000117E                           271  ;D2 = will store immediate value for comparing
0000117E                           272  ;D3 = buffer size (used for loop = 64)
0000117E                           273  ;D4 = 
0000117E                           274  ;D5 = 
0000117E                           275  ;D6 = 
0000117E                           276  ;D7 = 
0000117E                           277  
0000117E                           278  
0000117E                           279  
0000117E                           280  ;ORI (ANDI, SUBI, ADDI, EORI, CMPI)                                 $0
0000117E                           281  opcode0000:                                 
0000117E  2200                     282      MOVE.L      D0,D1                   ;D1 has full instruction
00001180  0241 0F00                283      ANDI.W      #nibble2,D1             ;check bits 11,10,9,8
00001184  143C 0008                284      MOVE.B      #right8, D2             ;store immediate value 8 in D2
00001188  E469                     285      LSR.W       D2, D1                  ;shift to isolate next nibble (bits 11-8)
0000118A  C2FC 0006                286      MULU        #6, D1                  ;multiply by 6 to get displacement
0000118E  47F9 000012B4            287      LEA         OP_0000_TABLE, A3       ;load op_0000_table into address register
00001194  4EF3 1000                288      JMP         0(A3,D1)                ;jumps to opcode table entry (A0 = OP_TABLE)
00001198                           289  
00001198                           290  ;MOVE.B                                                             $1
00001198                           291  opcode0001:
00001198  4EF9 0000149C            292      JMP         OP_MOVEB                ;no need to break down, only MOVE.B
0000119E                           293  
0000119E                           294  
0000119E                           295  ;MOVEA.L, MOVE.L                                                    $2
0000119E                           296  opcode0010:
0000119E  2200                     297      MOVE.L      D0,D1                   ;D1 has full instruction
000011A0  0241 01C0                298      ANDI        #dest_mode, D1          ;0000 0001 1100 0000
000011A4  143C 0006                299      MOVE.B      #right6, D2             ;D2 now 00000111
000011A8  E469                     300      LSR.W       D2, D1                  ;shifting destination mode in D1 to far right by 3
000011AA  B23C 0001                301      CMP.B       #1,D1                   ;does d1 = 001?
000011AE  6700 0310                302      BEQ         OP_MOVEAL               ;if d1 = 001, go to MOVEA
000011B2  4EF9 000014E8            303      JMP         OP_MOVEL                ;else jump to MOVEL
000011B8                           304      
000011B8                           305  
000011B8                           306  
000011B8                           307  
000011B8                           308  ;MOVEA.W MOVE.W                                                     $3
000011B8                           309  opcode0011:
000011B8  2200                     310      MOVE.L      D0,D1                   ;D1 has full instruction
000011BA  0241 01C0                311      ANDI        #dest_mode, D1          ;0000 0001 1100 0000
000011BE  143C 0006                312      MOVE.B      #right6, D2             ;D2 now 00000111
000011C2  E469                     313      LSR.W       D2, D1                  ;shifting destination mode in D1 to far right by 3
000011C4  B23C 0001                314      CMP.B       #1,D1                   ;does d1 = 001?
000011C8  6700 0342                315      BEQ         OP_MOVEAW               ;if d1 = 001, go to MOVEAW
000011CC  4EF9 00001534            316      JMP         OP_MOVEW                ;else jump to MOVEW
000011D2                           317  
000011D2                           318  
000011D2                           319  
000011D2                           320  
000011D2                           321  ;NOP, MOVEM, LEA (CLR, NOT, EXT, TRAP, STOP, RTE, RTS, JSR, JMP)     $4
000011D2                           322  opcode0100:
000011D2  2200                     323      MOVE.L      D0,D1                   ;D1 has full instruction
000011D4  0241 0F00                324      ANDI.W      #nibble2,D1             ;check bits 11,10,9,8
000011D8  143C 0008                325      MOVE.B      #right8, D2             ;store immediate value 8 in D2
000011DC  E469                     326      LSR.W       D2, D1                  ;shift to isolate next nibble (bits 11-8)
000011DE  C2FC 0006                327      MULU        #6, D1                  ;multiply by 6 to get displacement
000011E2  47F9 00001314            328      LEA         OP_0100_TABLE, A3       ;load op_0000_table into address register
000011E8  4EF3 1000                329      JMP         0(A3,D1)                ;jumps to opcode table entry (A0 = OP_TABLE)
000011EC                           330  
000011EC                           331  
000011EC                           332  ;ADDQ (SUBQ)                                                        $5
000011EC                           333  opcode0101:
000011EC                           334      ;JMP         OP_ADDQ
000011EC                           335      
000011EC                           336      
000011EC                           337      ;3/8/21
000011EC  2200                     338      MOVE.L      D0,D1
000011EE  0241 0F00                339      ANDI.W      #nibble2,D1
000011F2  E049                     340      LSR.W       #right8,D1
000011F4  0241 0001                341      ANDI.W      #1,D1
000011F8  B23C 0000                342      CMP.B       #0,D1
000011FC  6700 03A8                343      BEQ         OP_ADDQ
00001200  B23C 0001                344      CMP.B       #1,D1   
00001204  6700 03C2                345      BEQ         OP_SUBQ
00001208                           346      ;HANDLE ERROR
00001208                           347  
00001208                           348  
00001208                           349  ;EA_ADDQ_SUBQ:
00001208                           350  ;    ;CHECK BIT 8 FOR ADDQ OR SUBQ
00001208                           351  ;    CMP.W       #nibble2,D1
00001208                           352  ;    LSR.W       #right7,D1     
00001208                           353  ;    ANDI.W      #1,D1
00001208                           354  ;    CMP.B       #0,D1
00001208                           355  ;    BEQ         EA_ADDQ
00001208                           356  ;    CMP.B       #1,D1  
00001208                           357  ;    BEQ         EA_SUBQ
00001208                           358  ;    ;HANDLE ERROR      
00001208                           359  
00001208                           360  
00001208                           361  ;BRA.bw, BSR.bw (BEQ)                                               $6
00001208                           362  opcode0110:
00001208  2200                     363      MOVE.L      D0,D1                   ;D1 has full instruction
0000120A  0241 0F00                364      ANDI.W      #nibble2,D1             ;check bits 11,10,9,8
0000120E  143C 0008                365      MOVE.B      #right8, D2             ;store immediate value 8 in D2
00001212  E469                     366      LSR.W       D2, D1                  ;shift to isolate next nibble (bits 11-8)
00001214  C2FC 0006                367      MULU        #6, D1                  ;multiply by 6 to get displacement
00001218  47F9 00001374            368      LEA         OP_0110_TABLE, A3       ;load op_0110_table into address register
0000121E  4EF3 1000                369      JMP         0(A3,D1)                ;jumps to opcode table entry (A0 = OP_TABLE)
00001222                           370      
00001222                           371      ;come back and check when debugging. if this does not work then skip jump table
00001222                           372  
00001222                           373  
00001222                           374  ;MOVEQ                                                            $7
00001222                           375  opcode0111:
00001222  4EF9 0000161A            376      JMP         OP_MOVEQ
00001228                           377  
00001228                           378  
00001228                           379  
00001228                           380  ;DIVU (DIVS, OR)                                                    $8
00001228                           381  opcode1000:
00001228  2200                     382      MOVE.L      D0,D1
0000122A  0241 0F00                383      ANDI.W      #nibble2,D1
0000122E  E049                     384      LSR.W       #8,D1
00001230  0201 0001                385      ANDI.B      #1,D1
00001234  B23C 0000                386      CMP.B       #0,D1
00001238  6700 0400                387      BEQ         OP_DIVU
0000123C  B23C 0001                388      CMP.B       #1,D1
00001240  6700 0414                389      BEQ         OP_DIVS
00001244                           390      ;HANDLE ERROR
00001244                           391  
00001244                           392  ;SUB                                                                $9
00001244                           393  opcode1001:
00001244  4EF9 00001672            394      JMP         OP_SUB
0000124A                           395  
0000124A                           396  
0000124A                           397  ;not assigned                                                       $A
0000124A                           398  opcode1010:
0000124A  4EF9 00001762            399      JMP         OP_UNSUPPORTED_OPCODE
00001250                           400  
00001250                           401  
00001250                           402  ;CMP (EOR)                                                          $B
00001250                           403  opcode1011:
00001250  4EF9 00001690            404      JMP         OP_CMP
00001256                           405  
00001256                           406  
00001256                           407  ;MULU (MULS, AND)                                                   $C
00001256                           408  opcode1100:
00001256  2200                     409      MOVE.L      D0,D1
00001258  0241 0F00                410      ANDI.W      #nibble2,D1
0000125C  E049                     411      LSR.W       #8,D1
0000125E  0201 0001                412      ANDI.B      #1,D1
00001262  B23C 0000                413      CMP.B       #0,D1
00001266  6700 0446                414      BEQ         OP_MULU
0000126A  B23C 0001                415      CMP.B       #1,D1
0000126E  6700 045A                416      BEQ         OP_MULS
00001272                           417      ;HANDLE ERROR
00001272                           418  
00001272                           419  ;ADD, ADDA                                                          $D
00001272                           420  opcode1101:
00001272                           421      ;ADD and ADDA differ on bits 6,7... ADD will never be 11 for bits 6,7... use as check
00001272  4241                     422      CLR         D1
00001274  4242                     423      CLR         D2
00001276  2200                     424      MOVE.L      D0,D1
00001278  0241 00F0                425      ANDI.W      #nibble3, D1
0000127C  143C 0006                426      MOVE.B      #right6, D2
00001280  E469                     427      LSR.W       D2,D1
00001282                           428      
00001282                           429      ;at this point we have our bits of interest in bits 1,0
00001282                           430      
00001282  B27C 0003                431      CMP         #3,D1                              ;check if bits == 11
00001286  6700 047C                432      BEQ         OP_ADDA                             ;if yes, branch ADDA
0000128A  6000 045A                433      BRA         OP_ADD                              ;else branch ADD
0000128E                           434  
0000128E                           435  
0000128E                           436  
0000128E                           437  ;ASL, ASR (LSL, LSR, ROL, ROR)                                      $E
0000128E                           438  opcode1110:
0000128E  4241                     439      CLR D1
00001290  4242                     440      CLR D2
00001292  2200                     441      MOVE.L      D0, D1
00001294  0241 0F00                442      ANDI.W      #nibble2, D1
00001298  143C 0008                443      MOVE.B      #right8, D2
0000129C  E469                     444      LSR.W       D2, D1                              ;D1 has 0003 or 0004
0000129E  0241 0001                445      ANDI.W      #0001,D1                           ;isolate single bit
000012A2                           446      
000012A2                           447      ;at this point we have our single bit of interest in bit 0
000012A2                           448      
000012A2  B27C 0000                449      CMP         #0,D1                           ;check if bit == 0
000012A6  6700 049C                450      BEQ         OP_ASR                          ;if yes, branch to ASR
000012AA  6000 047A                451      BRA         OP_ASL                          ;else, branch to ASL
000012AE                           452  
000012AE                           453  
000012AE                           454  ;not assigned                                                       $F
000012AE                           455  opcode1111:
000012AE  4EF9 00001762            456      JMP         OP_UNSUPPORTED_OPCODE
000012B4                           457  
000012B4                           458  
000012B4                           459  ;******************************** OP_XXX_TABLES ************************************
000012B4                           460  ;once in OP_XXX_TABLE , we will use these entries to jump to specific op code to put into buffer
000012B4                           461  
000012B4                           462  OP_0000_TABLE:
000012B4  4EF9 000013D4            463      jmp OP_ORI                                      ;0  
000012BA  4EF9 00001762            464      jmp OP_UNSUPPORTED_OPCODE                       ;1
000012C0  4EF9 000013F2            465      jmp OP_ANDI                                     ;2
000012C6  4EF9 00001762            466      jmp OP_UNSUPPORTED_OPCODE                       ;3
000012CC  4EF9 00001414            467      jmp OP_SUBI                                     ;4
000012D2  4EF9 00001762            468      jmp OP_UNSUPPORTED_OPCODE                       ;5
000012D8  4EF9 00001436            469      jmp OP_ADDI                                     ;6
000012DE  4EF9 00001762            470      jmp OP_UNSUPPORTED_OPCODE                       ;7
000012E4  4EF9 00001762            471      jmp OP_UNSUPPORTED_OPCODE                       ;8
000012EA  4EF9 00001762            472      jmp OP_UNSUPPORTED_OPCODE                       ;9
000012F0  4EF9 00001458            473      jmp OP_EORI                                     ;10
000012F6  4EF9 00001762            474      jmp OP_UNSUPPORTED_OPCODE                       ;11
000012FC  4EF9 0000147A            475      jmp OP_CMPI                                     ;12
00001302  4EF9 00001762            476      jmp OP_UNSUPPORTED_OPCODE                       ;13
00001308  4EF9 00001762            477      jmp OP_UNSUPPORTED_OPCODE                       ;14
0000130E  4EF9 00001762            478      jmp OP_UNSUPPORTED_OPCODE                       ;15
00001314                           479  
00001314                           480  ;OP_0001_TABLE:
00001314                           481  ;    jmp OP_MOVEB
00001314                           482  
00001314                           483  
00001314                           484  ;OP_0010_TABLE:
00001314                           485  ;   jmp OP_MOVEAL
00001314                           486  ;   jmp OP_MOVEL
00001314                           487  
00001314                           488  
00001314                           489  ;OP_0011_TABLE:
00001314                           490  
00001314                           491  
00001314                           492  
00001314                           493  ;NOP, MOVEM, LEA (CLR, NOT, EXT, TRAP, STOP, RTE, RTS, JSR, JMP     $4
00001314                           494  ;NOP    1110
00001314                           495  ;MOVEM  1D00
00001314                           496  ;LEA    AN1
00001314                           497  OP_0100_TABLE:
00001314  4EF9 00001762            498      jmp OP_UNSUPPORTED_OPCODE                           ;0  
0000131A  4EF9 0000158E            499      jmp OP_LEA                                          ;1      (address 0001)
00001320  4EF9 00001762            500      jmp OP_UNSUPPORTED_OPCODE                           ;2
00001326  4EF9 0000158E            501      jmp OP_LEA                                          ;3      (address 0011)
0000132C  4EF9 00001762            502      jmp OP_UNSUPPORTED_OPCODE                           ;4 
00001332  4EF9 0000158E            503      jmp OP_LEA                                          ;5      (address 0101)
00001338  4EF9 00001762            504      jmp OP_UNSUPPORTED_OPCODE                           ;6 
0000133E  4EF9 0000158E            505      jmp OP_LEA                                          ;7      (address 0111) 
00001344  4EF9 00001568            506      jmp OP_MOVEM                                        ;8                          ;jmp OP_MOVEM_R2M
0000134A  4EF9 0000158E            507      jmp OP_LEA                                          ;9      (address 1001) 
00001350  4EF9 00001762            508      jmp OP_UNSUPPORTED_OPCODE                           ;10 
00001356  4EF9 0000158E            509      jmp OP_LEA                                          ;11     (address 1011) 
0000135C  4EF9 00001568            510      jmp OP_MOVEM                                        ;12                         ;jmp OP_MOVEM_M2R    
00001362  4EF9 0000158E            511      jmp OP_LEA                                          ;13     (address 1101)
00001368  4EF9 00001558            512      jmp OP_NOP                                          ;14
0000136E  4EF9 0000158E            513      jmp OP_LEA                                          ;15     (address 1111)
00001374                           514  
00001374                           515  
00001374                           516  ;OP_0101_TABLE:
00001374                           517  
00001374                           518  
00001374                           519  
00001374                           520  ;BRA nibble 2 = 0000 (0) , BSR nibble 2 = 0001 (1)
00001374                           521  OP_0110_TABLE:
00001374  4EF9 000015EA            522      jmp OP_BRA                                          ;0
0000137A  4EF9 00001602            523      jmp OP_BSR                                          ;1
00001380  4EF9 00001762            524      jmp OP_UNSUPPORTED_OPCODE                           ;2
00001386  4EF9 00001762            525      jmp OP_UNSUPPORTED_OPCODE                           ;3
0000138C  4EF9 00001762            526      jmp OP_UNSUPPORTED_OPCODE                           ;4
00001392  4EF9 00001762            527      jmp OP_UNSUPPORTED_OPCODE                           ;5
00001398  4EF9 00001762            528      jmp OP_UNSUPPORTED_OPCODE                           ;6
0000139E  4EF9 00001762            529      jmp OP_UNSUPPORTED_OPCODE                           ;7
000013A4  4EF9 00001762            530      jmp OP_UNSUPPORTED_OPCODE                           ;8
000013AA  4EF9 00001762            531      jmp OP_UNSUPPORTED_OPCODE                           ;9
000013B0  4EF9 00001762            532      jmp OP_UNSUPPORTED_OPCODE                           ;10
000013B6  4EF9 00001762            533      jmp OP_UNSUPPORTED_OPCODE                           ;11
000013BC  4EF9 00001762            534      jmp OP_UNSUPPORTED_OPCODE                           ;12
000013C2  4EF9 00001762            535      jmp OP_UNSUPPORTED_OPCODE                           ;13
000013C8  4EF9 00001762            536      jmp OP_UNSUPPORTED_OPCODE                           ;14
000013CE  4EF9 00001762            537      jmp OP_UNSUPPORTED_OPCODE                           ;15
000013D4                           538  
000013D4                           539  
000013D4                           540  ;OP_0111_TABLE:
000013D4                           541  ;implement later if needed
000013D4                           542  
000013D4                           543  
000013D4                           544  ;OP_1000_TABLE:
000013D4                           545  ;implement later if needed
000013D4                           546  
000013D4                           547  
000013D4                           548  ;OP_1001_TABLE:
000013D4                           549  ;implement later if needed
000013D4                           550  
000013D4                           551  
000013D4                           552  ;OP_1010_TABLE:
000013D4                           553  ;implement later if needed
000013D4                           554  
000013D4                           555  
000013D4                           556  ;OP_1011_TABLE:
000013D4                           557  ;implement later if needed
000013D4                           558  
000013D4                           559  
000013D4                           560  ;OP_1100_TABLE:
000013D4                           561  ;implement later if needed
000013D4                           562  
000013D4                           563  
000013D4                           564  ;OP_1101_TABLE:
000013D4                           565  ;implement later if needed
000013D4                           566  
000013D4                           567  
000013D4                           568  ;OP_1110_TABLE:
000013D4                           569  ;implement later if needed
000013D4                           570  
000013D4                           571  
000013D4                           572  ;OP_1111_TABLE:
000013D4                           573  ;implement later if needed
000013D4                           574  
000013D4                           575  
000013D4                           576  
000013D4                           577  
000013D4                           578  ;******************************** OP_INSTRUCTION_XXXX******************************************
000013D4                           579  ;this is where we are putting ascii text into buffer
000013D4                           580  
000013D4                           581  
000013D4                           582  OP_ORI:
000013D4  14FC 004F                583      MOVE.B  #'O', (A2)+
000013D8  14FC 0052                584      MOVE.B  #'R', (A2)+
000013DC  14FC 0049                585      MOVE.B  #'I', (A2)+
000013E0                           586      
000013E0                           587      ;call OP_CHECK_SIZE to append a .b/.w/.l
000013E0  4EB9 00001762            588      JSR     OP_CHECK_SIZE
000013E6                           589      
000013E6  7200                     590      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
000013E8                           591  
000013E8  4EB9 00001900            592      JSR     EA_START
000013EE  4EF8 1102                593      JMP     OP_FINISH
000013F2                           594  
000013F2                           595  OP_ANDI:  ;(optional)
000013F2  14FC 0041                596      MOVE.B  #'A', (A2)+
000013F6  14FC 004E                597      MOVE.B  #'N', (A2)+
000013FA  14FC 0044                598      MOVE.B  #'D', (A2)+
000013FE  14FC 0049                599      MOVE.B  #'I', (A2)+
00001402                           600      
00001402                           601      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001402  4EB9 00001762            602      JSR     OP_CHECK_SIZE
00001408                           603      
00001408  7200                     604      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
0000140A                           605  
0000140A  4EB9 00001900            606      JSR     EA_START
00001410  4EF8 1102                607      JMP     OP_FINISH
00001414                           608  
00001414                           609  
00001414                           610  OP_SUBI:  ;(optional)
00001414  14FC 0053                611      MOVE.B  #'S', (A2)+
00001418  14FC 0055                612      MOVE.B  #'U', (A2)+
0000141C  14FC 0042                613      MOVE.B  #'B', (A2)+
00001420  14FC 0049                614      MOVE.B  #'I', (A2)+
00001424                           615      
00001424                           616      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001424  4EB9 00001762            617      JSR     OP_CHECK_SIZE
0000142A                           618      
0000142A  7200                     619      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
0000142C                           620  
0000142C  4EB9 00001900            621      JSR     EA_START
00001432  4EF8 1102                622      JMP     OP_FINISH
00001436                           623  
00001436                           624  
00001436                           625  OP_ADDI:  ;(optional)
00001436  14FC 0041                626      MOVE.B  #'A', (A2)+
0000143A  14FC 0044                627      MOVE.B  #'D', (A2)+
0000143E  14FC 0044                628      MOVE.B  #'D', (A2)+
00001442  14FC 0049                629      MOVE.B  #'I', (A2)+
00001446                           630      
00001446                           631      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001446  4EB9 00001762            632      JSR     OP_CHECK_SIZE
0000144C                           633     
0000144C  7200                     634      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
0000144E                           635  
0000144E  4EB9 00001900            636      JSR     EA_START
00001454  4EF8 1102                637      JMP     OP_FINISH
00001458                           638  
00001458                           639  
00001458                           640  OP_EORI:  ;(optional)
00001458  14FC 0045                641      MOVE.B  #'E', (A2)+
0000145C  14FC 004F                642      MOVE.B  #'O', (A2)+
00001460  14FC 0052                643      MOVE.B  #'R', (A2)+
00001464  14FC 0049                644      MOVE.B  #'I', (A2)+
00001468                           645      
00001468                           646      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001468  4EB9 00001762            647      JSR     OP_CHECK_SIZE
0000146E                           648      
0000146E  7200                     649      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
00001470                           650      
00001470  4EB9 00001900            651      JSR     EA_START
00001476  4EF8 1102                652      JMP     OP_FINISH
0000147A                           653  
0000147A                           654  
0000147A                           655  OP_CMPI:  ;(optional)
0000147A  14FC 0043                656      MOVE.B  #'C', (A2)+
0000147E  14FC 004D                657      MOVE.B  #'M', (A2)+
00001482  14FC 0050                658      MOVE.B  #'P', (A2)+
00001486  14FC 0049                659      MOVE.B  #'I', (A2)+
0000148A                           660      
0000148A                           661      
0000148A                           662      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000148A  4EB9 00001762            663      JSR     OP_CHECK_SIZE
00001490                           664  
00001490  7200                     665      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
00001492                           666  
00001492  4EB9 00001900            667      JSR     EA_START
00001498  4EF8 1102                668      JMP     OP_FINISH
0000149C                           669  
0000149C                           670  
0000149C                           671  OP_MOVEB:
0000149C  14FC 004D                672      MOVE.B  #'M', (A2)+
000014A0  14FC 004F                673      MOVE.B  #'O', (A2)+
000014A4  14FC 0056                674      MOVE.B  #'V', (A2)+
000014A8  14FC 0045                675      MOVE.B  #'E', (A2)+
000014AC  14FC 002E                676      MOVE.B  #'.', (A2)+
000014B0  14FC 0042                677      MOVE.B  #'B', (A2)+
000014B4                           678      
000014B4  7201                     679      MOVE.L  #ea_type_move, D1                   ;preps for EA_START and puts 1 into D1
000014B6                           680      
000014B6  4EB9 00001900            681      JSR     EA_START
000014BC  4EF8 1102                682      JMP     OP_FINISH
000014C0                           683  
000014C0                           684  OP_MOVEAL:
000014C0  14FC 004D                685      MOVE.B  #'M', (A2)+
000014C4  14FC 004F                686      MOVE.B  #'O', (A2)+
000014C8  14FC 0056                687      MOVE.B  #'V', (A2)+
000014CC  14FC 0045                688      MOVE.B  #'E', (A2)+
000014D0  14FC 0041                689      MOVE.B  #'A', (A2)+
000014D4  14FC 002E                690      MOVE.B  #'.', (A2)+
000014D8  14FC 004C                691      MOVE.B  #'L', (A2)+
000014DC                           692      
000014DC  7202                     693      MOVE.L  #ea_type_movea, D1                   ;preps for EA_START and puts 2 into D1
000014DE                           694      
000014DE  4EB9 00001900            695      JSR     EA_START
000014E4  4EF8 1102                696      JMP     OP_FINISH
000014E8                           697  
000014E8                           698  OP_MOVEL:
000014E8  14FC 004D                699      MOVE.B  #'M', (A2)+
000014EC  14FC 004F                700      MOVE.B  #'O', (A2)+
000014F0  14FC 0056                701      MOVE.B  #'V', (A2)+
000014F4  14FC 0045                702      MOVE.B  #'E', (A2)+
000014F8  14FC 002E                703      MOVE.B  #'.', (A2)+
000014FC  14FC 004C                704      MOVE.B  #'L', (A2)+
00001500                           705      
00001500  7201                     706      MOVE.L  #ea_type_move, D1                   ;preps for EA_START and puts 1 into D1
00001502                           707      
00001502  4EB9 00001900            708      JSR     EA_START
00001508  4EF8 1102                709      JMP     OP_FINISH
0000150C                           710  
0000150C                           711  
0000150C                           712  OP_MOVEAW:
0000150C  14FC 004D                713      MOVE.B  #'M', (A2)+
00001510  14FC 004F                714      MOVE.B  #'O', (A2)+
00001514  14FC 0056                715      MOVE.B  #'V', (A2)+
00001518  14FC 0045                716      MOVE.B  #'E', (A2)+
0000151C  14FC 0041                717      MOVE.B  #'A', (A2)+
00001520  14FC 002E                718      MOVE.B  #'.', (A2)+
00001524  14FC 0057                719      MOVE.B  #'W', (A2)+
00001528                           720      
00001528  7202                     721      MOVE.L  #ea_type_movea, D1                   ;preps for EA_START and puts 2 into D1
0000152A                           722      
0000152A  4EB9 00001900            723      JSR     EA_START
00001530  4EF8 1102                724      JMP     OP_FINISH
00001534                           725  
00001534                           726  
00001534                           727  OP_MOVEW:
00001534  14FC 004D                728      MOVE.B  #'M', (A2)+
00001538  14FC 004F                729      MOVE.B  #'O', (A2)+
0000153C  14FC 0056                730      MOVE.B  #'V', (A2)+
00001540  14FC 0045                731      MOVE.B  #'E', (A2)+
00001544  14FC 002E                732      MOVE.B  #'.', (A2)+
00001548  14FC 0057                733      MOVE.B  #'W', (A2)+
0000154C                           734      
0000154C  7201                     735      MOVE.L  #ea_type_move, D1                   ;preps for EA_START and puts 1 into D1
0000154E                           736      
0000154E  4EB9 00001900            737      JSR     EA_START
00001554  4EF8 1102                738      JMP     OP_FINISH
00001558                           739  
00001558                           740  
00001558                           741  OP_NOP:
00001558  14FC 004E                742      MOVE.B  #'N', (A2)+
0000155C  14FC 004F                743      MOVE.B  #'O', (A2)+
00001560  14FC 0050                744      MOVE.B  #'P', (A2)+
00001564                           745      
00001564                           746      ;NO EA
00001564  4EF8 1102                747      JMP     OP_FINISH
00001568                           748  
00001568                           749  
00001568                           750  OP_MOVEM:
00001568                           751      ;see movemd2r or movemr2d... see below at bottom ?????
00001568                           752      
00001568  14FC 004D                753      MOVE.B  #'M', (A2)+
0000156C  14FC 004F                754      MOVE.B  #'O', (A2)+
00001570  14FC 0056                755      MOVE.B  #'V', (A2)+
00001574  14FC 0045                756      MOVE.B  #'E', (A2)+
00001578  14FC 004D                757      MOVE.B  #'M', (A2)+
0000157C                           758      
0000157C                           759      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000157C  4EB9 00001786            760      JSR     OP_CHECK_SIZE_MOVEM
00001582                           761      
00001582  7206                     762      MOVE.L  #ea_type_movem, D1                   ;preps for EA_START and puts 6 into D1
00001584                           763      
00001584  4EB9 00001900            764      JSR     EA_START
0000158A  4EF8 1102                765      JMP     OP_FINISH
0000158E                           766  
0000158E                           767  OP_LEA:
0000158E  14FC 004C                768      MOVE.B  #'L', (A2)+
00001592  14FC 0045                769      MOVE.B  #'E', (A2)+
00001596  14FC 0041                770      MOVE.B  #'A', (A2)+
0000159A                           771      
0000159A  7203                     772      MOVE.L  #ea_type_lea, D1                   ;preps for EA_START and puts 3 into D1
0000159C                           773      
0000159C  4EB9 00001900            774      JSR     EA_START
000015A2  4EF8 1102                775      JMP     OP_FINISH
000015A6                           776  
000015A6                           777  OP_CLR:  ;(optional)
000015A6                           778  ;implement later if needed
000015A6                           779  
000015A6                           780  
000015A6                           781  OP_NOT:  ;(optional)
000015A6                           782  ;implement later if needed
000015A6                           783  
000015A6                           784  
000015A6                           785  OP_EXT:  ;(optional)
000015A6                           786  ;implement later if needed
000015A6                           787  
000015A6                           788  
000015A6                           789  OP_TRAP:  ;(optional)
000015A6                           790  ;implement later if needed
000015A6                           791  
000015A6                           792   
000015A6                           793  OP_STOP:  ;(optional)
000015A6                           794  ;implement later if needed
000015A6                           795  
000015A6                           796  
000015A6                           797  OP_RTE:  ;(optional)
000015A6                           798  ;implement later if needed
000015A6                           799  
000015A6                           800  
000015A6                           801  OP_RTS:  ;(optional)
000015A6                           802  ;implement later if needed
000015A6                           803  
000015A6                           804  
000015A6                           805  OP_JSR:  ;(optional)
000015A6                           806  ;implement later if needed
000015A6                           807  
000015A6                           808  
000015A6                           809  OP_JMP:  ;(optional)
000015A6                           810  ;implement later if needed
000015A6                           811  
000015A6                           812  
000015A6                           813  OP_ADDQ:
000015A6  14FC 0041                814      MOVE.B  #'A', (A2)+
000015AA  14FC 0044                815      MOVE.B  #'D', (A2)+
000015AE  14FC 0044                816      MOVE.B  #'D', (A2)+
000015B2  14FC 0051                817      MOVE.B  #'Q', (A2)+
000015B6                           818      
000015B6                           819      ;call OP_CHECK_SIZE to append a .b/.w/.l
000015B6  4EB9 00001762            820      JSR     OP_CHECK_SIZE
000015BC                           821  
000015BC  7208                     822      MOVE.L  #ea_type_quick, D1                   ;preps for EA_START and puts 8 into D1
000015BE                           823  
000015BE  4EB9 00001900            824      JSR     EA_START
000015C4  4EF8 1102                825      JMP     OP_FINISH
000015C8                           826  
000015C8                           827  OP_SUBQ:  ;(optional)
000015C8  14FC 0053                828      MOVE.B  #'S', (A2)+
000015CC  14FC 0055                829      MOVE.B  #'U', (A2)+
000015D0  14FC 0042                830      MOVE.B  #'B', (A2)+
000015D4  14FC 0051                831      MOVE.B  #'Q', (A2)+
000015D8                           832      
000015D8                           833      ;call OP_CHECK_SIZE to append a .b/.w/.l
000015D8  4EB9 00001762            834      JSR     OP_CHECK_SIZE
000015DE                           835      
000015DE  7208                     836      MOVE.L  #ea_type_quick, D1                   ;preps for EA_START and puts 8 into D1
000015E0                           837  
000015E0  4EB9 00001900            838      JSR     EA_START
000015E6  4EF8 1102                839      JMP     OP_FINISH
000015EA                           840  
000015EA                           841  OP_BRA:                                     ;???? DO WE DEFINE SIZE HERE OR AFTER????
000015EA  14FC 0042                842      MOVE.B  #'B', (A2)+
000015EE  14FC 0052                843      MOVE.B  #'R', (A2)+
000015F2  14FC 0041                844      MOVE.B  #'A', (A2)+
000015F6                           845  
000015F6  7209                     846      MOVE.L  #ea_type_branch,D1
000015F8                           847      
000015F8  4EB9 00001900            848      JSR     EA_START
000015FE  4EF8 1102                849      JMP     OP_FINISH
00001602                           850  
00001602                           851  
00001602                           852  OP_BSR:
00001602  14FC 0042                853      MOVE.B  #'B', (A2)+
00001606  14FC 0053                854      MOVE.B  #'S', (A2)+
0000160A  14FC 0052                855      MOVE.B  #'R', (A2)+
0000160E                           856      
0000160E  7209                     857      MOVE.L  #ea_type_branch,D1
00001610                           858      
00001610  4EB9 00001900            859      JSR     EA_START                        ;DO WE HAVE EA?
00001616  4EF8 1102                860      JMP     OP_FINISH
0000161A                           861  
0000161A                           862  
0000161A                           863  OP_BEQ:
0000161A                           864  ;implement later if needed
0000161A                           865  
0000161A                           866  
0000161A                           867  OP_MOVEQ:
0000161A  14FC 004D                868      MOVE.B  #'M', (A2)+
0000161E  14FC 004F                869      MOVE.B  #'O', (A2)+
00001622  14FC 0056                870      MOVE.B  #'V', (A2)+
00001626  14FC 0045                871      MOVE.B  #'E', (A2)+
0000162A  14FC 0051                872      MOVE.B  #'Q', (A2)+
0000162E                           873      
0000162E                           874      ;DO WE NEED A .L ?
0000162E                           875      
0000162E  7208                     876      MOVE.L  #ea_type_quick, D1                   ;preps for EA_START and puts 8 into D1
00001630                           877      
00001630  4EB9 00001900            878      JSR     EA_START
00001636  4EF8 1102                879      JMP     OP_FINISH
0000163A                           880  
0000163A                           881  
0000163A                           882  OP_DIVU:
0000163A  14FC 0044                883      MOVE.B  #'D', (A2)+
0000163E  14FC 0049                884      MOVE.B  #'I', (A2)+
00001642  14FC 0056                885      MOVE.B  #'V', (A2)+
00001646  14FC 0055                886      MOVE.B  #'U', (A2)+
0000164A                           887    
0000164A  720A                     888      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
0000164C                           889    
0000164C  4EB9 00001900            890      JSR     EA_START
00001652  4EF8 1102                891      JMP     OP_FINISH    
00001656                           892  
00001656                           893  
00001656                           894  OP_DIVS  ;(optional)
00001656  14FC 0044                895      MOVE.B  #'D', (A2)+
0000165A  14FC 0049                896      MOVE.B  #'I', (A2)+
0000165E  14FC 0056                897      MOVE.B  #'V', (A2)+
00001662  14FC 0053                898      MOVE.B  #'S', (A2)+
00001666                           899    
00001666  720A                     900      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
00001668                           901    
00001668  4EB9 00001900            902      JSR     EA_START
0000166E  4EF8 1102                903      JMP     OP_FINISH   
00001672                           904  
00001672                           905  
00001672                           906  OP_OR  ;(optional)
00001672                           907  ;implement later if needed
00001672                           908  
00001672                           909  
00001672                           910  OP_SUB:
00001672  14FC 0053                911      MOVE.B  #'S', (A2)+
00001676  14FC 0055                912      MOVE.B  #'U', (A2)+
0000167A  14FC 0042                913      MOVE.B  #'B', (A2)+
0000167E                           914  
0000167E  4EB9 00001762            915      JSR     OP_CHECK_SIZE                       ;call OP_CHECK_SIZE to append a .b/.w/.l
00001684                           916      
00001684  720A                     917      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
00001686                           918      
00001686                           919      ;at this point it will return with SUB.X and go to EA_START
00001686  4EB9 00001900            920      JSR     EA_START
0000168C  4EF8 1102                921      JMP     OP_FINISH    
00001690                           922  
00001690                           923  
00001690                           924  OP_CMP:
00001690  14FC 0043                925      MOVE.B  #'C', (A2)+
00001694  14FC 004D                926      MOVE.B  #'M', (A2)+
00001698  14FC 0050                927      MOVE.B  #'P', (A2)+
0000169C                           928    
0000169C  4EB9 00001762            929      JSR     OP_CHECK_SIZE                       ;call OP_CHECK_SIZE to append a .b/.w/.l  
000016A2                           930      
000016A2  720A                     931      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
000016A4                           932      
000016A4                           933      ;at this point it will return with SUB.X and go to EA_START
000016A4  4EB9 00001900            934      JSR     EA_START
000016AA  4EF8 1102                935      JMP     OP_FINISH    
000016AE                           936      
000016AE                           937  
000016AE                           938  
000016AE                           939  OP_EOR:  ;(optional)
000016AE                           940  ;implement later if needed
000016AE                           941  
000016AE                           942  
000016AE                           943  OP_MULU:
000016AE  14FC 004D                944      MOVE.B  #'M', (A2)+
000016B2  14FC 0055                945      MOVE.B  #'U', (A2)+
000016B6  14FC 004C                946      MOVE.B  #'L', (A2)+
000016BA  14FC 0055                947      MOVE.B  #'U', (A2)+
000016BE                           948  
000016BE  720A                     949      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
000016C0                           950      
000016C0  4EB9 00001900            951      JSR     EA_START
000016C6  4EF8 1102                952      JMP     OP_FINISH    
000016CA                           953  
000016CA                           954  OP_MULS:  ;(optional)
000016CA  14FC 004D                955      MOVE.B  #'M', (A2)+
000016CE  14FC 0055                956      MOVE.B  #'U', (A2)+
000016D2  14FC 004C                957      MOVE.B  #'L', (A2)+
000016D6  14FC 0053                958      MOVE.B  #'S', (A2)+
000016DA                           959  
000016DA  720A                     960      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
000016DC                           961  
000016DC  4EB9 00001900            962      JSR     EA_START
000016E2  4EF8 1102                963      JMP     OP_FINISH
000016E6                           964  
000016E6                           965  
000016E6                           966  OP_AND:  ;(optional)
000016E6                           967  ;implement later if needed
000016E6                           968  
000016E6                           969  
000016E6                           970  OP_ADD:
000016E6  14FC 0041                971      MOVE.B  #'A', (A2)+
000016EA  14FC 0044                972      MOVE.B  #'D', (A2)+
000016EE  14FC 0044                973      MOVE.B  #'D', (A2)+
000016F2                           974  
000016F2                           975      ;call OP_CHECK_SIZE to append a .b/.w/.l
000016F2  4EB9 00001762            976      JSR     OP_CHECK_SIZE
000016F8                           977      
000016F8  720A                     978      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
000016FA                           979  
000016FA  4EB9 00001900            980      JSR     EA_START
00001700  4EF8 1102                981      JMP     OP_FINISH
00001704                           982  
00001704                           983  OP_ADDA:
00001704  14FC 0041                984      MOVE.B  #'A', (A2)+
00001708  14FC 0044                985      MOVE.B  #'D', (A2)+
0000170C  14FC 0044                986      MOVE.B  #'D', (A2)+
00001710  14FC 0041                987      MOVE.B  #'A', (A2)+
00001714                           988  
00001714                           989      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001714  4EB9 000017C8            990      JSR     OP_CHECK_SIZE_ADDA
0000171A                           991      
0000171A  720A                     992      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
0000171C                           993  
0000171C  4EB9 00001900            994      JSR     EA_START
00001722  4EF8 1102                995      JMP     OP_FINISH
00001726                           996  
00001726                           997  
00001726                           998  OP_ASL:
00001726  14FC 0041                999      MOVE.B  #'A', (A2)+
0000172A  14FC 0053               1000      MOVE.B  #'S', (A2)+
0000172E  14FC 004C               1001      MOVE.B  #'L', (A2)+
00001732                          1002  
00001732                          1003      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001732  4EB9 00001762           1004      JSR     OP_CHECK_SIZE
00001738                          1005      
00001738  720B                    1006      MOVE.L  #ea_type_rotation, D1                   ;preps for EA_START and puts 10 into D1
0000173A                          1007      
0000173A  4EB9 00001900           1008      JSR     EA_START
00001740  4EF8 1102               1009      JMP     OP_FINISH
00001744                          1010  
00001744                          1011  
00001744                          1012  OP_ASR:
00001744  14FC 0041               1013      MOVE.B  #'A', (A2)+
00001748  14FC 0053               1014      MOVE.B  #'S', (A2)+
0000174C  14FC 0052               1015      MOVE.B  #'R', (A2)+
00001750                          1016  
00001750                          1017      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001750  4EB9 00001762           1018      JSR     OP_CHECK_SIZE
00001756                          1019      
00001756  720B                    1020      MOVE.L  #ea_type_rotation, D1                   ;preps for EA_START and puts 10 into D1
00001758                          1021  
00001758  4EB9 00001900           1022      JSR     EA_START
0000175E  4EF8 1102               1023      JMP     OP_FINISH
00001762                          1024  
00001762                          1025  OP_LSL:  ;(optional)
00001762                          1026  ;implement later if needed
00001762                          1027  
00001762                          1028  
00001762                          1029  
00001762                          1030  OP_LSR:  ;(optional)
00001762                          1031  ;implement later if needed
00001762                          1032  
00001762                          1033  
00001762                          1034  
00001762                          1035  OP_ROL:  ;(optional)
00001762                          1036  ;implement later if needed
00001762                          1037  
00001762                          1038  
00001762                          1039  
00001762                          1040  OP_ROR:  ;(optional)
00001762                          1041  ;implement later if needed
00001762                          1042  
00001762                          1043  
00001762                          1044  
00001762                          1045  ;OP_MOVEM_R2M:
00001762                          1046  ;    MOVE.B  #'M', (A2)+
00001762                          1047  ;    MOVE.B  #'O', (A2)+
00001762                          1048  ;    MOVE.B  #'V', (A2)+
00001762                          1049  ;    MOVE.B  #'E', (A2)+
00001762                          1050  ;    MOVE.B  #'M', (A2)+
00001762                          1051      
00001762                          1052  ;    ;call OP_CHECK_SIZE to append a .b/.w/.l
00001762                          1053  ;    JSR     OP_CHECK_SIZE
00001762                          1054      
00001762                          1055  ;    MOVE.L  #ea_type_movem, D1                   ;preps for EA_START and puts 6 into D1
00001762                          1056      
00001762                          1057  ;    JSR     EA_START
00001762                          1058  ;    JMP     OP_FINISH
00001762                          1059  
00001762                          1060  
00001762                          1061  ;OP_MOVEM_M2R:
00001762                          1062  ;    MOVE.B  #'M', (A2)+
00001762                          1063  ;    MOVE.B  #'O', (A2)+
00001762                          1064  ;    MOVE.B  #'V', (A2)+
00001762                          1065  ;    MOVE.B  #'E', (A2)+
00001762                          1066  ;    MOVE.B  #'M', (A2)+
00001762                          1067      
00001762                          1068  ;    ;call OP_CHECK_SIZE to append a .b/.w/.l
00001762                          1069  ;    JSR     OP_CHECK_SIZE
00001762                          1070      
00001762                          1071  ;    MOVE.L  #ea_type_movem, D1                   ;preps for EA_START and puts 6 into D1
00001762                          1072      
00001762                          1073  ;    JSR     EA_START
00001762                          1074  ;    JMP     OP_FINISH
00001762                          1075  
00001762                          1076  
00001762                          1077  OP_UNSUPPORTED_OPCODE:
00001762                          1078  ;fill out
00001762                          1079  
00001762                          1080  ;D0 HAS COMPLETE INSTRUCTION
00001762                          1081  OP_CHECK_SIZE:
00001762  4241                    1082      CLR     D1                                  ;CLEAR D1
00001764  4242                    1083      CLR     D2                                  ;clear D2
00001766  2200                    1084      MOVE.L  D0,D1                               ;D0 and D1 both have complete opcode
00001768  0241 00F0               1085      ANDI.W  #nibble3,D1                         ;isolate nibble 3
0000176C  143C 0006               1086      MOVE.B  #right6, D2                         ;putting immediate value 6 in D2
00001770  E469                    1087      LSR.W   D2, D1                              ;bits 7,6 --> bits 1,0
00001772                          1088      
00001772                          1089       
00001772  B27C 0000               1090      CMP     #00,D1                              ;compare bits 1,0 to 00
00001776  6700 0032               1091      BEQ     OP_SIZE_BYTE                        ;if bits == 00, size byte
0000177A  B27C 0001               1092      CMP     #01,D1                              ;compare bits to 01
0000177E  6700 0034               1093      BEQ     OP_SIZE_WORD                        ;if bits == 01, size word
00001782  6000 003A               1094      BRA     OP_SIZE_LONG                        ;else size long
00001786                          1095  
00001786                          1096  
00001786                          1097  OP_CHECK_SIZE_MOVEM:
00001786  4241                    1098      CLR     D1                                  ;CLEAR D1
00001788  4242                    1099      CLR     D2                                  ;clear D2
0000178A  2200                    1100      MOVE.L  D0,D1                               ;D0 and D1 both have complete opcode
0000178C  0241 00F0               1101      ANDI.W  #nibble3,D1                         ;isolate nibble 3
00001790  143C 0006               1102      MOVE.B  #right6, D2                         ;putting immediate value 6 in D2
00001794  E469                    1103      LSR.W   D2, D1                              ;bits 7,6 --> bits 1,0
00001796                          1104      
00001796  0241 0001               1105      ANDI.W  #1,D1    
0000179A  B27C 0000               1106      CMP     #0,D1                              ;compare bits 1,0 to 00
0000179E  6700 0014               1107      BEQ     OP_SIZE_WORD                        ;if bits == 00, size WORD
000017A2  B27C 0001               1108      CMP     #1,D1                              ;compare bits to 01
000017A6  6700 0016               1109      BEQ     OP_SIZE_LONG                       ;if bits == 01, size LONG
000017AA                          1110  
000017AA                          1111  OP_SIZE_BYTE
000017AA  14FC 002E               1112      MOVE.B  #'.', (A2)+
000017AE  14FC 0042               1113      MOVE.B  #'B', (A2)+
000017B2  4E75                    1114      RTS
000017B4                          1115  
000017B4                          1116  OP_SIZE_WORD
000017B4  14FC 002E               1117      MOVE.B  #'.', (A2)+
000017B8  14FC 0057               1118      MOVE.B  #'W', (A2)+
000017BC  4E75                    1119      RTS
000017BE                          1120  
000017BE                          1121  
000017BE                          1122  OP_SIZE_LONG
000017BE  14FC 002E               1123      MOVE.B  #'.', (A2)+
000017C2  14FC 004C               1124      MOVE.B  #'L', (A2)+
000017C6  4E75                    1125      RTS
000017C8                          1126  
000017C8                          1127  
000017C8                          1128  OP_CHECK_SIZE_ADDA:
000017C8  4241                    1129      CLR     D1                                  ;CLEAR D1
000017CA  4242                    1130      CLR     D2                                  ;clear D2
000017CC  2200                    1131      MOVE.L  D0,D1                               ;D0 and D1 both have complete opcode
000017CE  0241 0F00               1132      ANDI.W  #nibble2,D1                         ;isolate nibble 2
000017D2  143C 0008               1133      MOVE.B  #right8, D2                         ;putting immediate value 8 in D2
000017D6  E469                    1134      LSR.W   D2, D1                              ;
000017D8                          1135      
000017D8                          1136      ;at this point we have our single bit in bit 0
000017D8                          1137      
000017D8  0241 0001               1138      ANDI.W  #0001,D1                            ;isolate bit 0
000017DC  B27C 0000               1139      CMP     #0,D1                               ;check if bit == 0
000017E0  67D2                    1140      BEQ     OP_SIZE_WORD                        ;if yes, size = word
000017E2  60DA                    1141      BRA     OP_SIZE_LONG                        ;else, size = long
000017E4                          1142   
000017E4                          1143  
000017E4                          1144  ;******************************** ATOI ******************************************************************************************************************************
000017E4                          1145  ATOI:
000017E4  2401                    1146          MOVE.L      D1,D2                   ;loop variable (size) is in D2
000017E6  2449                    1147          MOVEA.L     A1,A2                   ;pointer to next char
000017E8  4284                    1148          CLR.L       D4
000017EA                          1149  
000017EA                          1150  ATOI_LOOP  
000017EA  4243                    1151          CLR         D3                      ;clear d3
000017EC                          1152          ;CMP.B       #0,D2
000017EC                          1153          ;BEQ         ATOI_DONE               ;DONE
000017EC  5382                    1154          SUBI.L      #1,D2                   ;subtract 1 from loop counter
000017EE  161A                    1155          MOVE.B      (A2)+,D3                 ;move current byte to D3, then increment to next
000017F0  B63C 002F               1156          CMP.B       #$2F,D3
000017F4  6F00 0060               1157          BLE         ATOI_ERROR              ;if less than 30, not a number, branch to error
000017F8  B63C 0039               1158          CMP.B       #$39,D3                 ;check byte to see if number or letter
000017FC  6F00 002A               1159          BLE         ATOI_NUMBER             ;30<x<39 --> number
00001800  B63C 0040               1160          CMP.B       #$40,D3
00001804  6F00 0050               1161          BLE         ATOI_ERROR
00001808  B63C 0046               1162          CMP.B       #$46,D3
0000180C  6F00 0024               1163          BLE         ATOI_UPPERCASE_LETTER   ;less than 47, it is uppercase letter
00001810  B63C 0060               1164          CMP.B       #$60,D3
00001814  6F00 0040               1165          BLE         ATOI_ERROR
00001818  B63C 0066               1166          CMP.B       #$66,D3
0000181C  6F00 001E               1167          BLE         ATOI_LOWERCASE_LETTER
00001820  B63C 0067               1168          CMP.B       #$67,D3
00001824  6C00 0030               1169          BGE         ATOI_ERROR
00001828                          1170          
00001828                          1171          ;BNE         ATOI_LOOP                    ;run loop
00001828                          1172      
00001828                          1173  
00001828                          1174  ATOI_NUMBER
00001828                          1175  ;number --> d1 = d1 - $30
00001828  0403 0030               1176      SUBI.B          #$30, D3                    ;subtract 30 if number
0000182C                          1177      ;MOVE.B          D3,(A2)+                    ;move into A2 and post increment pointer
0000182C  4EF9 00001846           1178      JMP             ATOI_FORMAT                 ;testing
00001832                          1179      ;JMP            ATOI_LOOP                   ;loop
00001832                          1180  
00001832                          1181  ATOI_UPPERCASE_LETTER
00001832                          1182  ;letter --> d1 = d1 - $37
00001832  0403 0037               1183      SUBI.B          #$37,D3                     ;subtract 37 if UPPER case letter
00001836                          1184      ;MOVE.B          D3,(A2)+                    ;move into A2 and post increment pointer
00001836  4EF9 00001846           1185      JMP             ATOI_FORMAT                 ;testing
0000183C                          1186      ;JMP            ATOI_LOOP                   ;loop
0000183C                          1187  
0000183C                          1188  ATOI_LOWERCASE_LETTER
0000183C  0403 0057               1189      SUBI.B          #$57,D3                     ;subtract 57(20 + 37)
00001840                          1190      ;MOVE.B          D3,(A2)+                    ;move into A2 and post increment pointer
00001840  4EF9 00001846           1191      JMP             ATOI_FORMAT                 ;testing
00001846                          1192      ;JMP            ATOI_LOOP                  ;loop
00001846                          1193  
00001846                          1194  
00001846                          1195  ATOI_FORMAT
00001846  D803                    1196      ADD.B           D3,D4                       ;add the byte to D4 so can add later   
00001848  B43C 0000               1197      CMP.B           #0,D2                       
0000184C  6700 0008               1198      BEQ             ATOI_DONE                   ;check if done (loop counter D2 is at 0)
00001850  E984                    1199      ASL.L           #4,D4                       ;logical shift left to make room
00001852  4EF8 17EA               1200      JMP             ATOI_LOOP                   ;go back to loop
00001856                          1201  
00001856                          1202  ATOI_ERROR
00001856                          1203      ;come back to handle error when out of range
00001856                          1204      
00001856                          1205  
00001856                          1206  ATOI_DONE 
00001856  2284                    1207      MOVE.L         D4,(A1)                      ;at this point, move the new address in D4 to mem location                                
00001858  4E75                    1208      RTS                                         ;used to RTS after a branch statement
0000185A                          1209  
0000185A                          1210  ;************************************* ITOA *******************************************************************************************************************
0000185A                          1211  ;A0
0000185A                          1212  ;A1
0000185A                          1213  ;A2 = buffer (this is our decoded string that will print to screen)
0000185A                          1214  ;A3
0000185A                          1215  ;A4 = current memory address for buffer
0000185A                          1216  ;A5 = starting address / current address in memory
0000185A                          1217  ;A6 = ending address
0000185A                          1218  ;A7 = SP
0000185A                          1219  
0000185A                          1220  ;D0 = counter
0000185A                          1221  ;D1 = 
0000185A                          1222  ;D2 = ?
0000185A                          1223  ;D3 = buffer size (used for loop = 64)
0000185A                          1224  ;D4 = value being converted
0000185A                          1225  ;D5 =
0000185A                          1226  ;D6 = 
0000185A                          1227  ;D7 = 
0000185A                          1228  ITOA:
0000185A  280D                    1229      MOVE.L         A5,D4                    ;D4 has data to convert to ascii
0000185C                          1230  
0000185C                          1231  ITOA_LOOP:
0000185C  BA3C 0000               1232      CMP.B           #0,D5
00001860  6700 004C               1233      BEQ             ITOA_FINISH             ;when 0, branch to finish to complete
00001864                          1234  
00001864                          1235  
00001864                          1236  
00001864                          1237  
00001864                          1238  ITOA_BYTE:
00001864                          1239  
00001864                          1240  
00001864                          1241  
00001864                          1242  ITOA_WORD:
00001864                          1243  
00001864                          1244  
00001864                          1245  
00001864                          1246  ITOA_LONG:
00001864                          1247  
00001864                          1248  
00001864                          1249  
00001864                          1250  ITOA_ADDRESS:
00001864  4284                    1251      CLR.L       D4                          ;D4 = 0000 0000
00001866  280D                    1252      MOVE.L      A5,D4                       ;our address is now in D4 and ready to deconstruct
00001868  103C 0008               1253      MOVE.B      #8,D0                       ;counter
0000186C  4EF9 00001872           1254      JMP         ITOA_ADDRESS_LOOP
00001872                          1255  ITOA_ADDRESS_LOOP:
00001872  B03C 0000               1256      CMP.B       #0,D0                       ;check if done
00001876  6700 0036               1257      BEQ         ITOA_FINISH                 ;if at 0, branch to ITOA_FINISH
0000187A  E99C                    1258      ROL.L       #4,D4                       ;rotate left 4 bits, to get MSB to beginning 
0000187C  1204                    1259      MOVE.B      D4,D1                       ;store in D1 (this will be whole byte, we want half)
0000187E  0241 000F               1260      ANDI.W      #$000F,D1                   ;character is now isolated
00001882                          1261      
00001882  4EB9 0000188E           1262      JSR         ITOA_HEX2ASCII              ;JSR to convert
00001888  5340                    1263      SUBI        #1,D0                       ;subtract 1 from counter
0000188A  4EF8 1872               1264      JMP         ITOA_ADDRESS_LOOP           ;loop again!
0000188E                          1265  
0000188E                          1266  ITOA_HEX2ASCII:
0000188E  B23C 000A               1267      CMP.B       #$A,D1                      ;compare byte in D1 to hex value A
00001892  6C00 0012               1268      BGE         ITOA_LETTER                 ;if greater than/equal A, it is letter
00001896  B23C 000A               1269      CMP.B       #$A,D1                      ;compare byte in D1 to hex value A
0000189A  6D00 0002               1270      BLT         ITOA_NUMBER                 ;if less than, it is number
0000189E                          1271  
0000189E                          1272  ITOA_NUMBER:
0000189E  0601 0030               1273      ADDI.B      #$30,D1                     ;add $30 to D1 to convert
000018A2  14C1                    1274      MOVE.B      D1,(A2)+                    ;add to buffer and increment to next position
000018A4  4E75                    1275      RTS
000018A6                          1276  
000018A6                          1277  ITOA_LETTER:
000018A6  0601 0037               1278      ADDI.B      #$37,D1                     ;add 37 to D1 to convert
000018AA  14C1                    1279      MOVE.B      D1,(A2)+                    ;add to buffer and increment to next position
000018AC  4E75                    1280      RTS
000018AE                          1281  
000018AE                          1282  ITOA_FINISH:
000018AE  4E75                    1283      RTS
000018B0                          1284  
000018B0                          1285  
000018B0                          1286  ;************************************ Validate Addresses ******************************************
000018B0                          1287  
000018B0                          1288  VALIDATE_BEGINNING:
000018B0                          1289      
000018B0                          1290  
000018B0                          1291  
000018B0                          1292  
000018B0                          1293  ;******************************** Message Error Handling ***************************************************************************************************************** 
000018B0                          1294  STARTA_ERROR_LESS_THAN_ZERO:
000018B0  103C 000E               1295      MOVE.B  #14,D0
000018B4  43F9 000020C0           1296      LEA     error_message_1,A1      ;load the get_end_address message into A1
000018BA  4E4F                    1297      TRAP    #15    
000018BC  4EF8 1012               1298      JMP     GET_STARTING_ADDRESS
000018C0                          1299  
000018C0                          1300  STARTA_ERROR_NOT_EVEN:
000018C0  103C 000E               1301      MOVE.B  #14,D0
000018C4  43F9 000020EA           1302      LEA     error_message_2,A1      ;load error_message_2
000018CA  4E4F                    1303      TRAP    #15    
000018CC  4EF8 1012               1304      JMP     GET_STARTING_ADDRESS
000018D0                          1305  
000018D0                          1306  ENDA_ERROR_NOT_EVEN:
000018D0  103C 000E               1307      MOVE.B  #14,D0
000018D4  43F9 0000210A           1308      LEA     error_message_3,A1      ;load error_message_3
000018DA  4E4F                    1309      TRAP    #15
000018DC  4EF8 104A               1310      JMP     GET_ENDING_ADDRESS
000018E0                          1311  
000018E0                          1312  ENDA_ERROR_LARGE:
000018E0  103C 000E               1313      MOVE.B  #14,D0
000018E4  43F9 0000212A           1314      LEA     error_message_4,A1      ;load error_message_4
000018EA  4E4F                    1315      TRAP    #15
000018EC  4EF8 104A               1316      JMP     GET_ENDING_ADDRESS
000018F0                          1317      
000018F0                          1318  ENDA_ERROR_LESS_THAN_STARTA:
000018F0  103C 000E               1319      MOVE.B  #14,D0
000018F4  43F9 00002159           1320      LEA     error_message_5,A1      ;load error_message_5
000018FA  4E4F                    1321      TRAP    #15
000018FC  4EF8 104A               1322      JMP     GET_ENDING_ADDRESS
00001900                          1323  
00001900                          1324  ;****************************************** EA Stuff ********************************************************************************************************************* 
00001900                          1325  
00001900                          1326  EA_START:
00001900  41F9 0000190E           1327      LEA         EA_TYPE_TABLE, A0
00001906                          1328      
00001906  C2FC 0006               1329      MULU        #6,D1               ;computes opcode table jump displacement
0000190A  4EF0 1000               1330      JMP         0(A0,D1)            ;jump to correct table input
0000190E                          1331  
0000190E                          1332  
0000190E                          1333  EA_TYPE_TABLE:
0000190E  4EF9 0000195E           1334      JMP         EA_IMMEDIATE        ;0  DONE
00001914  4EF9 000019A0           1335      JMP         EA_MOVE             ;1  DONE
0000191A  4EF9 000019E6           1336      JMP         EA_MOVEA            ;2  DONE
00001920  4EF9 00001A2C           1337      JMP         EA_LEA              ;3  DONE
00001926  4EF9 00001A6C           1338      JMP         EA_DESTONLY         ;4  JMP, CLR
0000192C  4EF9 00001A6C           1339      JMP         EA_EXT              ;5
00001932  4EF9 00001A6C           1340      JMP         EA_MOVEM            ;6
00001938  4EF9 00001C82           1341      JMP         EA_TRAP             ;7
0000193E  4EF9 00001C82           1342      JMP         EA_QUICK            ;8  DONE
00001944  4EF9 00001CFE           1343      JMP         EA_BRANCH           ;9  DONE
0000194A  4EF9 00001DAC           1344      JMP         EA_MATH             ;10 DONE    DIVU, DIVS, SUB, CMP, MULU, ADD, ADDA
00001950  4EF9 00001E24           1345      JMP         EA_ROTATION         ;11         ASL, ASR, ???  
00001956  4EF9 0000195C           1346      JMP         EA_FINISH           ;
0000195C                          1347  
0000195C                          1348  EA_FINISH:
0000195C  4E75                    1349      RTS ; TAKE OUT LATER
0000195E                          1350      
0000195E                          1351  
0000195E                          1352  
0000195E                          1353  ;********************************************  EA_TYPE  ****************************************************   
0000195E                          1354  
0000195E                          1355  EA_IMMEDIATE:                               ;value 0
0000195E  14FC 0009               1356      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001962  14FC 0023               1357      MOVE.B  #'#',(A2)+                      ;add a # to buffer
00001966  14FC 0024               1358      MOVE.B  #'$',(A2)+                      ;add a $ to buffer
0000196A                          1359      
0000196A                          1360      ;check size which is bits 6,7 and store in D6
0000196A                          1361      ;get immediate value from memory based off size and store in D7
0000196A  4EB9 00001F50           1362      JSR     EA_CHECK_SIZE
00001970                          1363      
00001970                          1364      ;at this point our size is in D6 and data is in D7 and memory has been advanced
00001970                          1365      ;convert immediate data to ascii and put on buffer
00001970  4EB9 00001F7A           1366      JSR     EA_ITOA_IMMEDIATE
00001976                          1367      
00001976  41F9 00001E74           1368      LEA     EA_MODE_TABLE,A0                ;load table
0000197C  14FC 002C               1369      MOVE.B  #',',(A2)+                      ;add a # to buffer
00001980  14FC 0009               1370      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001984                          1371      
00001984                          1372      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
00001984                          1373      
00001984                          1374      ;isolate source mode - bits 3,4,5 and store in D4
00001984  2800                    1375      MOVE.L  D0,D4
00001986  E64C                    1376      LSR.W   #3,D4
00001988  0244 0007               1377      ANDI.W  #$7,D4
0000198C  C8FC 0006               1378      MULU    #6,D4
00001990                          1379      
00001990                          1380      ;isolate source register - bits 0,1,2 and store in D5
00001990  2A00                    1381      MOVE.L  D0,D5
00001992  0245 0007               1382      ANDI.W  #$7,D5
00001996                          1383  
00001996  4EB9 00001E70           1384      JSR     EA_JMP_HELPER
0000199C  4EF8 195C               1385      JMP     EA_FINISH
000019A0                          1386  
000019A0                          1387  ;D4 = mode      --> source / destination
000019A0                          1388  ;D5 = register  --> source / destination   
000019A0                          1389  EA_MOVE:
000019A0  14FC 0009               1390      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
000019A4  41F9 00001E74           1391      LEA     EA_MODE_TABLE,A0                ;load table
000019AA                          1392      
000019AA                          1393      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
000019AA                          1394      
000019AA                          1395      ;isolate source mode
000019AA  2800                    1396      MOVE.L  D0,D4
000019AC  E64C                    1397      LSR.W   #3,D4
000019AE  0244 0007               1398      ANDI.W  #$7,D4
000019B2  C8FC 0006               1399      MULU    #6,D4
000019B6                          1400          
000019B6                          1401      ;isolate source register
000019B6  2A00                    1402      MOVE.L  D0,D5
000019B8  0245 0007               1403      ANDI.W  #$7,D5
000019BC                          1404      
000019BC  4EB9 00001E70           1405      JSR    EA_JMP_HELPER
000019C2  14FC 002C               1406      MOVE.B  #',',(A2)+                  ;add ',' to buffer  
000019C6                          1407      
000019C6                          1408      ;isolate destination mode
000019C6  2800                    1409      MOVE.L  D0,D4
000019C8  EC4C                    1410      LSR.W   #6,D4
000019CA  0244 0007               1411      ANDI.W  #$7,D4
000019CE  C8FC 0006               1412      MULU    #6,D4
000019D2                          1413      
000019D2                          1414      ;isolate destination register 
000019D2  2A00                    1415      MOVE.L  D0,D5
000019D4  E84D                    1416      LSR.W   #4,D5
000019D6  EA4D                    1417      LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
000019D8  0245 0007               1418      ANDI.W  #$7,D5   
000019DC  4EB9 00001E70           1419      JSR     EA_JMP_HELPER
000019E2                          1420  
000019E2  4EF8 195C               1421      JMP     EA_FINISH
000019E6                          1422      
000019E6                          1423  
000019E6                          1424  EA_MOVEA:
000019E6  14FC 0009               1425      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
000019EA  41F9 00001E74           1426      LEA     EA_MODE_TABLE,A0                ;load table
000019F0                          1427  
000019F0                          1428      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
000019F0                          1429      
000019F0                          1430      ;isolate source mode
000019F0  2800                    1431      MOVE.L  D0,D4
000019F2  E64C                    1432      LSR.W   #3,D4
000019F4  0244 0007               1433      ANDI.W  #$7,D4
000019F8  C8FC 0006               1434      MULU    #6,D4
000019FC                          1435          
000019FC                          1436      ;isolate source register
000019FC  2A00                    1437      MOVE.L  D0,D5
000019FE  0245 0007               1438      ANDI.W  #$7,D5
00001A02                          1439      
00001A02  4EB9 00001E70           1440      JSR    EA_JMP_HELPER
00001A08  14FC 002C               1441      MOVE.B  #',',(A2)+                  ;add ',' to buffer
00001A0C                          1442      
00001A0C                          1443      ;isolate destination mode --> SHOULD ALWAYS BE 001 AND GO TO ADDRESS REGISTER
00001A0C  2800                    1444      MOVE.L  D0,D4
00001A0E  EC4C                    1445      LSR.W   #6,D4
00001A10  0244 0007               1446      ANDI.W  #$7,D4
00001A14  C8FC 0006               1447      MULU    #6,D4
00001A18                          1448      
00001A18                          1449      ;isolate destination register 
00001A18  2A00                    1450      MOVE.L  D0,D5
00001A1A  E84D                    1451      LSR.W   #4,D5
00001A1C  EA4D                    1452      LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
00001A1E  0245 0007               1453      ANDI.W  #$7,D5   
00001A22  4EB9 00001E70           1454      JSR     EA_JMP_HELPER
00001A28                          1455  
00001A28  4EF8 195C               1456      JMP     EA_FINISH
00001A2C                          1457  
00001A2C                          1458  EA_LEA:
00001A2C  14FC 0009               1459      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001A30  41F9 00001E74           1460      LEA     EA_MODE_TABLE,A0                ;load table
00001A36                          1461      
00001A36                          1462      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
00001A36                          1463      
00001A36                          1464      ;isolate source mode
00001A36  2800                    1465      MOVE.L  D0,D4
00001A38  E64C                    1466      LSR.W   #3,D4
00001A3A  0244 0007               1467      ANDI.W  #$7,D4
00001A3E  C8FC 0006               1468      MULU    #6,D4
00001A42                          1469          
00001A42                          1470      ;isolate source register
00001A42  2A00                    1471      MOVE.L  D0,D5
00001A44  0245 0007               1472      ANDI.W  #$7,D5
00001A48                          1473      
00001A48  4EB9 00001E70           1474      JSR    EA_JMP_HELPER
00001A4E  14FC 002C               1475      MOVE.B  #',',(A2)+                  ;add ',' to buffer
00001A52                          1476      
00001A52                          1477      ;destination always An
00001A52                          1478      ;MOVE.B  #'A',(A2)+                  ;add 'A' to buffer
00001A52                          1479      
00001A52                          1480      ;isolate destination register 
00001A52                          1481      ;MOVE.L  D0,D5
00001A52                          1482      ;LSR.W   #4,D5
00001A52                          1483      ;LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
00001A52                          1484      ;ANDI.W  #$7,D5
00001A52                          1485  
00001A52                          1486      ;isolate destination mode --> SHOULD ALWAYS BE 001 AND GO TO ADDRESS REGISTER
00001A52  7801                    1487      MOVE.L  #1,D4
00001A54  C8FC 0006               1488      MULU    #6,D4
00001A58                          1489      
00001A58                          1490      ;isolate destination register 
00001A58  2A00                    1491      MOVE.L  D0,D5
00001A5A  E84D                    1492      LSR.W   #4,D5
00001A5C  EA4D                    1493      LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
00001A5E  0245 0007               1494      ANDI.W  #$7,D5   
00001A62  4EB9 00001E70           1495      JSR     EA_JMP_HELPER
00001A68                          1496  
00001A68  4EF8 195C               1497      JMP     EA_FINISH
00001A6C                          1498  
00001A6C                          1499  EA_DESTONLY:        ;JMP, CLR
00001A6C                          1500  
00001A6C                          1501  
00001A6C                          1502  
00001A6C                          1503  
00001A6C                          1504  
00001A6C                          1505  EA_EXT:
00001A6C                          1506  
00001A6C                          1507  
00001A6C                          1508  
00001A6C                          1509  
00001A6C                          1510  
00001A6C                          1511  EA_MOVEM:
00001A6C  14FC 0009               1512      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001A70  41F9 00001E74           1513      LEA     EA_MODE_TABLE,A0                ;load table
00001A76                          1514      
00001A76  2200                    1515      MOVE.L  D0,D1                           ;
00001A78  341D                    1516      MOVE.W  (A5)+,D2                        ;come back and verify D2 is free!!!!!
00001A7A                          1517      
00001A7A                          1518      ;D1 = 4890 | D2 = 0080 (source)
00001A7A                          1519      
00001A7A                          1520      ;if direction (bit 10) == 0, destination is in opcode, source is in the second operand
00001A7A                          1521      ;if direction (bit 10) == 1, the source is in the opcode, destination is in the operand
00001A7A                          1522      
00001A7A                          1523      ;check direction (bit 10)
00001A7A  0241 0F00               1524      ANDI.W  #nibble2,D1
00001A7E  EA49                    1525      LSR.W   #5,D1
00001A80  EA49                    1526      LSR.W   #5,D1                           ;total of 10 shifts
00001A82  0241 0001               1527      ANDI.W  #1,D1
00001A86  B23C 0000               1528      CMP.B   #0,D1
00001A8A  6700 000A               1529      BEQ     EA_MOVEM_REG_TO_MEM
00001A8E  B23C 0001               1530      CMP.B   #1,D1
00001A92  6700 00F0               1531      BEQ     EA_MOVEM_MEM_TO_REG
00001A96                          1532      
00001A96                          1533      
00001A96                          1534  ;MOVEM.W    D/A2,(A7)    
00001A96                          1535  EA_MOVEM_REG_TO_MEM:                        ;bit 10 == 0
00001A96                          1536      ;check if data register or address register
00001A96  4246                    1537      CLR     D6
00001A98  3C02                    1538      MOVE.W  D2,D6
00001A9A  0246 FF00               1539      ANDI.W  #$FF00,D6                       ;isolate nibble 1 and 2
00001A9E  BC7C 0000               1540      CMP.W   #0,D6                           ;check if 0
00001AA2  6700 0006               1541      BEQ     EA_MOVEM_DATAREG_TO_MEM        ;if 0, source is data register
00001AA6  6000 008A               1542      BRA     EA_MOVEM_ADDRREG_TO_MEM        ;else it is address register
00001AAA                          1543  
00001AAA                          1544  
00001AAA                          1545  EA_MOVEM_DATAREG_TO_MEM:    
00001AAA  2C02                    1546      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001AAC  4247                    1547      CLR     D7
00001AAE                          1548      
00001AAE  1E3C 0000               1549      MOVE.B  #0,D7
00001AB2  4245                    1550      CLR D5
00001AB4  4243                    1551      CLR D3
00001AB6  4241                    1552      CLR D1
00001AB8                          1553      
00001AB8  14FC 0044               1554      MOVE.B  #'D',(A2)+                      ;add 'D' to buffer
00001ABC  6100 0162               1555      BSR     MOVEM_LOOP                      ;enter loop to get number
00001AC0                          1556      
00001AC0                          1557      
00001AC0                          1558      ;convert d3 to ascii and add to buffer
00001AC0  0603 0030               1559      ADDI.B  #$30,D3                         ;convert to ASCII
00001AC4  14C3                    1560      MOVE.B  D3,(A2)+                        ;put on buffer
00001AC6                          1561      
00001AC6                          1562      
00001AC6                          1563      ;check d5 and handle
00001AC6  0605 0030               1564      ADDI.B  #$30,D5
00001ACA                          1565      
00001ACA  4241                    1566      CLR     D1
00001ACC  323C 0000               1567      MOVE.W  #0,D1                           ;FLAG TO INDICATE D
00001AD0                          1568      
00001AD0  4EB9 00001B04           1569      JSR     MOVEM_CHECK_MULTIPLE
00001AD6                          1570      
00001AD6  14FC 002C               1571      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001ADA                          1572  
00001ADA  41F9 00001E74           1573      LEA     EA_MODE_TABLE,A0                ;load table
00001AE0                          1574      
00001AE0                          1575      ;isolate source mode
00001AE0  2800                    1576      MOVE.L  D0,D4
00001AE2  E64C                    1577      LSR.W   #3,D4   
00001AE4  0244 0007               1578      ANDI.W  #$7,D4
00001AE8                          1579      
00001AE8                          1580      ;check for mode 111 -> immediate data
00001AE8  B87C 0007               1581      CMP.W   #$7,D4
00001AEC                          1582      ;if immediate data, leave and get immediate data rather than another register
00001AEC  6700 0160               1583      BEQ     EA_MOVEM_IMMEDIATE_DESTINATION     
00001AF0                          1584      
00001AF0  C8FC 0006               1585      MULU    #6,D4
00001AF4                          1586       
00001AF4                          1587      ;isolate source register
00001AF4  2A00                    1588      MOVE.L  D0,D5
00001AF6  0245 0007               1589      ANDI.W  #$7,D5
00001AFA                          1590      
00001AFA  4EB9 00001E70           1591      JSR    EA_JMP_HELPER
00001B00  4EF8 195C               1592      JMP     EA_FINISH
00001B04                          1593  
00001B04                          1594  
00001B04                          1595      
00001B04                          1596  MOVEM_CHECK_MULTIPLE:
00001B04  BA43                    1597      CMP     D3,D5
00001B06  6600 0004               1598      BNE     MOVEM_MULTIPLE
00001B0A  4E75                    1599      RTS
00001B0C                          1600      
00001B0C                          1601  MOVEM_MULTIPLE:
00001B0C  14FC 002D               1602      MOVE.B  #'-',(A2)+                      ;add '-' to buffer
00001B10                          1603      ;CHECK D1 FOR A OR D
00001B10  B27C 0000               1604      CMP.W   #0,D1                           ;check if 0 --> D
00001B14  6700 000C               1605      BEQ     MOVEM_MULTIPLE_D
00001B18  B27C 0001               1606      CMP.W   #1,D1
00001B1C  6700 000C               1607      BEQ     MOVEM_MULTIPLE_A
00001B20                          1608  
00001B20  4E75                    1609      RTS
00001B22                          1610  
00001B22                          1611  MOVEM_MULTIPLE_D:
00001B22  14FC 0044               1612      MOVE.B  #'D',(A2)+                      ;add 'D' to buffer
00001B26  14C5                    1613      MOVE.B  D5,(A2)+                        ;put on buffer
00001B28  4E75                    1614      RTS
00001B2A                          1615  
00001B2A                          1616  MOVEM_MULTIPLE_A:
00001B2A  14FC 0041               1617      MOVE.B  #'A',(A2)+                      ;add 'D' to buffer
00001B2E  14C5                    1618      MOVE.B  D5,(A2)+                        ;put on buffer
00001B30  4E75                    1619      RTS
00001B32                          1620  
00001B32                          1621  EA_MOVEM_ADDRREG_TO_MEM:
00001B32  2C02                    1622      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001B34  4247                    1623      CLR     D7
00001B36                          1624      
00001B36  1E3C 0000               1625      MOVE.B  #0,D7
00001B3A  4245                    1626      CLR D5
00001B3C  4243                    1627      CLR D3
00001B3E  4241                    1628      CLR D1
00001B40                          1629      
00001B40  14FC 0041               1630      MOVE.B  #'A',(A2)+                      ;add 'A' to buffer
00001B44  E04E                    1631      LSR.W   #8,D6                           ;shift 8 times
00001B46  6100 00D8               1632      BSR     MOVEM_LOOP                      ;enter loop to get number
00001B4A                          1633      
00001B4A                          1634      ;convert d3 to ascii and add to buffer
00001B4A  0603 0030               1635      ADDI.B  #$30,D3                         ;convert to ASCII
00001B4E  14C3                    1636      MOVE.B  D3,(A2)+                        ;put on buffer
00001B50                          1637      
00001B50  0605 0030               1638      ADDI.B  #$30,D5
00001B54                          1639      
00001B54  4241                    1640      CLR     D1
00001B56  323C 0001               1641      MOVE.W  #1,D1                           ;FLAG TO INDICATE A
00001B5A                          1642      
00001B5A  4EB8 1B04               1643      JSR MOVEM_CHECK_MULTIPLE
00001B5E                          1644      
00001B5E  14FC 002C               1645      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001B62                          1646      ;MOVEM.s D7,
00001B62                          1647      
00001B62  41F9 00001E74           1648      LEA     EA_MODE_TABLE,A0                ;load table
00001B68                          1649      
00001B68                          1650      ;isolate source mode
00001B68  2800                    1651      MOVE.L  D0,D4
00001B6A  E64C                    1652      LSR.W   #3,D4
00001B6C  0244 0007               1653      ANDI.W  #$7,D4
00001B70  C8FC 0006               1654      MULU    #6,D4
00001B74                          1655          
00001B74                          1656      ;isolate source register
00001B74  2A00                    1657      MOVE.L  D0,D5
00001B76  0245 0007               1658      ANDI.W  #$7,D5
00001B7A                          1659      
00001B7A  4EB9 00001E70           1660      JSR    EA_JMP_HELPER
00001B80  4EF8 195C               1661      JMP     EA_FINISH
00001B84                          1662  
00001B84                          1663  ;MOVEM.W (A7),D/A2
00001B84                          1664  EA_MOVEM_MEM_TO_REG:                        ;bit 10 == 1
00001B84  41F9 00001E74           1665      LEA     EA_MODE_TABLE,A0                ;load table
00001B8A                          1666      
00001B8A                          1667      ;isolate source mode
00001B8A  2800                    1668      MOVE.L  D0,D4
00001B8C  E64C                    1669      LSR.W   #3,D4
00001B8E  0244 0007               1670      ANDI.W  #$7,D4
00001B92                          1671      
00001B92                          1672      
00001B92                          1673      ;check for mode 111 -> immediate data
00001B92  B87C 0007               1674      CMP.W   #$7,D4
00001B96                          1675      ;if immediate data, leave and get immediate data rather than another register
00001B96  6700 00C6               1676      BEQ     EA_MOVEM_IMMEDIATE_SOURCE
00001B9A                          1677  
00001B9A  C8FC 0006               1678      MULU    #6,D4
00001B9E                          1679          
00001B9E                          1680      ;isolate source register
00001B9E  2A00                    1681      MOVE.L  D0,D5
00001BA0  0245 0007               1682      ANDI.W  #$7,D5
00001BA4                          1683  
00001BA4  4EB9 00001E70           1684      JSR    EA_JMP_HELPER
00001BAA  14FC 002C               1685      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001BAE                          1686      
00001BAE                          1687      ;our operand is in D2
00001BAE  4246                    1688      CLR     D6
00001BB0  3C02                    1689      MOVE.W  D2,D6
00001BB2  0246 FF00               1690      ANDI.W  #$FF00,D6                       ;isolate nibble 1 and 2
00001BB6  BC7C 0000               1691      CMP.W   #0,D6                           ;check if 0
00001BBA  6700 0006               1692      BEQ     EA_MOVEM_MEM_TO_DATAREG        ;if 0, source is data register
00001BBE  6000 0030               1693      BRA     EA_MOVEM_MEM_TO_ADDRREG        ;else it is address register
00001BC2                          1694          
00001BC2                          1695  EA_MOVEM_MEM_TO_DATAREG: 
00001BC2  2C02                    1696      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001BC4  4247                    1697      CLR     D7
00001BC6                          1698      
00001BC6  1E3C 0000               1699      MOVE.B  #0,D7
00001BCA  4245                    1700      CLR D5
00001BCC  4243                    1701      CLR D3
00001BCE  4241                    1702      CLR D1
00001BD0                          1703      
00001BD0  14FC 0044               1704      MOVE.B  #'D',(A2)+                      ;add 'D' to buffer
00001BD4  6100 004A               1705      BSR     MOVEM_LOOP                      ;enter loop to get number
00001BD8                          1706      
00001BD8                          1707      ;convert d7 to ascii and add to buffer
00001BD8  0603 0030               1708      ADDI.B  #$30,D3                         ;convert to ASCII
00001BDC  14C3                    1709      MOVE.B  D3,(A2)+                        ;put on buffer
00001BDE                          1710  
00001BDE                          1711      ;check multiple
00001BDE  0605 0030               1712      ADDI.B  #$30,D5
00001BE2                          1713      
00001BE2  4241                    1714      CLR     D1
00001BE4  323C 0000               1715      MOVE.W  #0,D1                           ;FLAG TO INDICATE D
00001BE8                          1716      
00001BE8  4EB8 1B04               1717      JSR MOVEM_CHECK_MULTIPLE
00001BEC                          1718  
00001BEC  4EF8 195C               1719      JMP     EA_FINISH
00001BF0                          1720     
00001BF0                          1721  EA_MOVEM_MEM_TO_ADDRREG:
00001BF0  2C02                    1722      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001BF2  4247                    1723      CLR     D7  
00001BF4                          1724      
00001BF4  1E3C 0000               1725      MOVE.B  #0,D7
00001BF8  4245                    1726      CLR D5
00001BFA  4243                    1727      CLR D3
00001BFC  4241                    1728      CLR D1
00001BFE                          1729         
00001BFE  14FC 0041               1730      MOVE.B  #'A',(A2)+                      ;add 'A' to buffer
00001C02  E04E                    1731      LSR.W   #8,D6                           ;shift 8 times
00001C04  6100 001A               1732      BSR     MOVEM_LOOP                      ;enter loop to get number
00001C08                          1733      
00001C08                          1734      ;convert d7 to ascii and add to buffer
00001C08  0603 0030               1735      ADDI.B  #$30,D3                         ;convert to ASCII
00001C0C  14C3                    1736      MOVE.B  D3,(A2)+                        ;put on buffer
00001C0E                          1737  
00001C0E                          1738      ;check multiple   
00001C0E  0605 0030               1739      ADDI.B  #$30,D5 
00001C12  4241                    1740      CLR     D1
00001C14  323C 0001               1741      MOVE.W  #1,D1                           ;FLAG TO INDICATE A
00001C18                          1742      
00001C18  4EB8 1B04               1743      JSR MOVEM_CHECK_MULTIPLE
00001C1C                          1744  
00001C1C  4EF8 195C               1745      JMP     EA_FINISH
00001C20                          1746  
00001C20                          1747  MOVEM_LOOP  
00001C20                          1748      ;D1 = min_set_flag (0 = not set, 1 = set) | D3 = MIN | D5 = MAX | D7 = COUNTER (STARTS AT 0)
00001C20                          1749      ;D6 = OUR SECOND OPERAND
00001C20                          1750       
00001C20  E24E                    1751      LSR.W   #1,D6               ;1000
00001C22  6500 000C               1752      BCS     MOVEM_CARRY
00001C26  5247                    1753      ADDI.W  #1,D7
00001C28  BE7C 0008               1754      CMP     #8,D7
00001C2C  6FF2                    1755      BLE     MOVEM_LOOP
00001C2E  4E75                    1756      RTS
00001C30                          1757  
00001C30                          1758  MOVEM_CARRY:
00001C30  B27C 0000               1759      CMP         #0,D1
00001C34  6700 000A               1760      BEQ         MOVEM_SET_MIN
00001C38                          1761      
00001C38  3A07                    1762      MOVE.W      D7,D5
00001C3A  5247                    1763      ADDI.W      #1,D7  
00001C3C  4EF8 1C20               1764      JMP         MOVEM_LOOP
00001C40                          1765  
00001C40                          1766  MOVEM_SET_MIN:
00001C40  3607                    1767      MOVE.W      D7,D3           ;set min
00001C42  3A07                    1768      MOVE.W      D7,D5           ;set max
00001C44  323C 0001               1769      MOVE.W      #1,D1           ;set flag
00001C48  5247                    1770      ADDI.W      #1,D7  
00001C4A  4EF8 1C20               1771      JMP         MOVEM_LOOP
00001C4E                          1772  
00001C4E                          1773  
00001C4E                          1774  
00001C4E                          1775  EA_MOVEM_IMMEDIATE_DESTINATION:
00001C4E                          1776      ;GET NEXT WORD VALUE AT A5 AND INCREMENT
00001C4E  3E15                    1777      MOVE.W  (A5),D7                        ;immediate value is in D7 now
00001C50  14FC 0024               1778      MOVE.B  #'$',(A2)+                      ;add '$' to buffer
00001C54                          1779      
00001C54                          1780      ;convert to ascii and put on buffer
00001C54  4EB9 00001F9E           1781      JSR     EA_ITOA_WORD
00001C5A                          1782  
00001C5A  4EF8 195C               1783      JMP     EA_FINISH
00001C5E                          1784  
00001C5E                          1785  EA_MOVEM_IMMEDIATE_SOURCE:
00001C5E                          1786      ;GET NEXT WORD VALUE AT A5 AND INCREMENT
00001C5E  3E15                    1787      MOVE.W  (A5),D7                        ;immediate value is in D7 now
00001C60  14FC 0024               1788      MOVE.B  #'$',(A2)+                      ;add '$' to buffer
00001C64                          1789      
00001C64                          1790      ;convert to ascii and put on buffer
00001C64  4EB9 00001F9E           1791      JSR     EA_ITOA_WORD
00001C6A                          1792  
00001C6A                          1793      ;TRY THIS
00001C6A  14FC 002C               1794      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001C6E                          1795      
00001C6E                          1796      ;our operand is in D2
00001C6E  4246                    1797      CLR     D6
00001C70  3C02                    1798      MOVE.W  D2,D6
00001C72  0246 FF00               1799      ANDI.W  #$FF00,D6                       ;isolate nibble 1 and 2
00001C76  BC7C 0000               1800      CMP.W   #0,D6                           ;check if 0
00001C7A  6700 FF46               1801      BEQ     EA_MOVEM_MEM_TO_DATAREG        ;if 0, source is data register
00001C7E  6000 FF70               1802      BRA     EA_MOVEM_MEM_TO_ADDRREG        ;else it is address register
00001C82                          1803  
00001C82                          1804  
00001C82                          1805  
00001C82                          1806  
00001C82                          1807  
00001C82                          1808  
00001C82                          1809  
00001C82                          1810  EA_TRAP:
00001C82                          1811  
00001C82                          1812  
00001C82                          1813  
00001C82                          1814  
00001C82                          1815  
00001C82                          1816  EA_QUICK:
00001C82                          1817      ;FIGURE WHAT KIND? (ADDQ,SUBQ,MOVEQ)
00001C82                          1818      ;ADDQ/SUBQ  -->  opcode = 0101 (stored in D0)
00001C82                          1819      ;MOVEQ      -->  opcode = 0111 (stored in D0)
00001C82  14FC 0009               1820      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001C86  14FC 0023               1821      MOVE.B  #'#',(A2)+                  ;add a # to buffer
00001C8A  14FC 0024               1822      MOVE.B  #'$',(A2)+                  ;add a $ to buffer
00001C8E                          1823      
00001C8E  2200                    1824      MOVE.L  D0,D1                       ;should move into D1
00001C90                          1825      
00001C90                          1826      ;check for MOVEQ
00001C90  EC49                    1827      LSR.W   #right6,D1
00001C92  EC49                    1828      LSR.W   #right6,D1  
00001C94  B27C 0007               1829      CMP.W   #$7,D1
00001C98  6700 003A               1830      BEQ     EA_QUICK_MOVEQ
00001C9C                          1831      
00001C9C  4241                    1832      CLR     D1                          ;else not MOVEQ, reset D1 and continue with ADDQ / SUBQ
00001C9E  2200                    1833      MOVE.L  D0,D1
00001CA0  0241 0E00               1834      ANDI.W  #dest_reg,D1                ;isolate destination register(11,10,9)
00001CA4  E049                    1835      LSR.W   #right8,D1                  ;shift 8 times
00001CA6  E249                    1836      LSR.W   #right1,D1                  ;shift 1 time for total of 9 times
00001CA8                          1837      
00001CA8                          1838      ;at this point we have our number, so convert to ASCII and put on buffer
00001CA8  0601 0030               1839      ADDI.B  #$30,D1                     ;convert to ASCII
00001CAC  14C1                    1840      MOVE.B  D1,(A2)+                    ;put on buffer
00001CAE                          1841      
00001CAE                          1842      
00001CAE                          1843      ;ready for destination address
00001CAE  14FC 002C               1844      MOVE.B  #',',(A2)+                  ;add ',' to buffer  
00001CB2  41F9 00001E74           1845      LEA     EA_MODE_TABLE,A0            ;load table
00001CB8                          1846      
00001CB8                          1847      
00001CB8                          1848      ;isolate source mode
00001CB8  2800                    1849      MOVE.L  D0,D4
00001CBA  E64C                    1850      LSR.W   #3,D4
00001CBC  0244 0007               1851      ANDI.W  #$7,D4
00001CC0  C8FC 0006               1852      MULU    #6,D4
00001CC4                          1853          
00001CC4                          1854      ;isolate source register
00001CC4  2A00                    1855      MOVE.L  D0,D5
00001CC6  0245 0007               1856      ANDI.W  #$7,D5
00001CCA                          1857      
00001CCA  4EB9 00001E70           1858      JSR    EA_JMP_HELPER
00001CD0                          1859      
00001CD0  4EF8 195C               1860      JMP     EA_FINISH
00001CD4                          1861      
00001CD4                          1862      ;LSR.W       #right12,D1         ;shift D1 by 12 bits, leaving just 4 bits      --> gives shift count error
00001CD4                          1863      ;CMP.W       #$5,D1
00001CD4                          1864      ;BEQ         EA_ADDQ_SUBQ
00001CD4                          1865      
00001CD4                          1866  EA_QUICK_MOVEQ:
00001CD4  2200                    1867      MOVE.L  D0,D1
00001CD6  0241 00FF               1868      ANDI.W  #$00FF,D1               ;isolate bits 7-0
00001CDA                          1869      
00001CDA                          1870      ;our bits are isolated in D1, move to D7 for ITOA function
00001CDA  2E01                    1871      MOVE.L  D1,D7
00001CDC  4EB9 00001FDC           1872      JSR     EA_ITOA_BYTE_CONVERT
00001CE2                          1873      
00001CE2  14FC 002C               1874      MOVE.B  #',',(A2)+                  ;add ',' to buffer
00001CE6  14FC 0044               1875      MOVE.B  #'D',(A2)+                  ;add ',' to buffer
00001CEA  2200                    1876      MOVE.L  D0,D1
00001CEC  0241 0F00               1877      ANDI.W  #nibble2,D1
00001CF0  E049                    1878      LSR.W   #8,D1
00001CF2  E249                    1879      LSR.W   #1,D1
00001CF4                          1880      
00001CF4                          1881      ;at this point we have our number, so convert to ASCII and put on buffer
00001CF4  0601 0030               1882      ADDI.B  #$30,D1                     ;convert to ASCII
00001CF8  14C1                    1883      MOVE.B  D1,(A2)+                    ;put on buffer
00001CFA                          1884  
00001CFA  4EF8 195C               1885      JMP     EA_FINISH
00001CFE                          1886  
00001CFE                          1887  EA_BRANCH:
00001CFE                          1888      ;PROGRAM COUNTER @ A5
00001CFE                          1889      ;BRA or BSR
00001CFE                          1890      ;displacement bits are 7-0 
00001CFE  2200                    1891      MOVE.L  D0,D1
00001D00  0241 00FF               1892      ANDI.W  #$00FF,D1               ;isolate bits 7-0
00001D04                          1893      ;PERFORM CHECKS 0000 0000 = WORD VALUE, 1111 1111 = LONG VALUE
00001D04                          1894      
00001D04  B23C 0000               1895      CMP.B   #$00,D1
00001D08  6700 006C               1896      BEQ     EA_BRANCH_16
00001D0C                          1897      
00001D0C                          1898      ;if not 0
00001D0C  B23C 00FF               1899      CMP.B   #$FF,D1
00001D10  6700 007C               1900      BEQ     EA_BRANCH_32
00001D14                          1901      
00001D14                          1902      ;OTHERWISE... HANDLE DISPLACEMENT IN OPCODE!
00001D14                          1903      
00001D14  2200                    1904      MOVE.L  D0,D1
00001D16  0241 00FF               1905      ANDI.W  #$00FF,D1
00001D1A                          1906      
00001D1A  6000 0002               1907      BRA     EA_BRANCH_8_BIT_DISPLACEMENT
00001D1E                          1908      
00001D1E                          1909      
00001D1E                          1910  
00001D1E                          1911  EA_BRANCH_8_BIT_DISPLACEMENT:
00001D1E                          1912      ;D0,D1 HAVE OPCODE
00001D1E  EE49                    1913      LSR     #7,D1
00001D20                          1914      
00001D20  B23C 0000               1915      CMP.B   #0,D1
00001D24  6700 0006               1916      BEQ     EA_BRANCH_POSITIVE              ;bit = 0
00001D28  6000 0004               1917      BRA     EA_BRANCH_NEGATIVE              ;bit = 1
00001D2C                          1918  
00001D2C                          1919  EA_BRANCH_POSITIVE:
00001D2C  2200                    1920      MOVE.L  D0,D1
00001D2E                          1921      
00001D2E                          1922  
00001D2E                          1923  
00001D2E                          1924  EA_BRANCH_NEGATIVE:
00001D2E  2200                    1925      MOVE.L  D0,D1
00001D30  0241 00FF               1926      ANDI.W  #$00FF,D1
00001D34  4401                    1927      NEG.B   D1  
00001D36                          1928      
00001D36  3E0D                    1929      MOVE.W  A5,D7
00001D38  9E41                    1930      SUB     D1,D7
00001D3A                          1931      ;SUBI    #2,D2
00001D3A                          1932      
00001D3A  4EB9 00001D44           1933      JSR     EA_BRANCH_ITOA_HELPER
00001D40                          1934      
00001D40  4EF8 195C               1935      JMP     EA_FINISH
00001D44                          1936  
00001D44                          1937  
00001D44                          1938  EA_BRANCH_ITOA_HELPER:
00001D44                          1939      ;VALUE IN D2 --> 00000400
00001D44  2407                    1940      MOVE.L  D7,D2                   ;PRESERVE COPY
00001D46  E04F                    1941      LSR.W   #right8,D7
00001D48  E04F                    1942      LSR.W   #right8,D7
00001D4A  E04F                    1943      LSR.W   #right8,D7
00001D4C  4EB9 00001FDC           1944      JSR     EA_ITOA_BYTE_CONVERT
00001D52                          1945  
00001D52  2E02                    1946      MOVE.L  D2,D7
00001D54  E04F                    1947      LSR.W   #right8,D7
00001D56  E04F                    1948      LSR.W   #right8,D7    
00001D58  4EB9 00001FDC           1949      JSR     EA_ITOA_BYTE_CONVERT
00001D5E                          1950  
00001D5E  2E02                    1951      MOVE.L  D2,D7
00001D60  E04F                    1952      LSR.W   #right8,D7
00001D62  4EB9 00001FDC           1953      JSR     EA_ITOA_BYTE_CONVERT
00001D68                          1954  
00001D68  2E02                    1955      MOVE.L  D2,D7
00001D6A  4EB9 00001FDC           1956      JSR     EA_ITOA_BYTE_CONVERT
00001D70                          1957  
00001D70  4EF9 00002014           1958      JMP     EA_ITOA_DONE
00001D76                          1959  
00001D76                          1960  EA_BRANCH_16:
00001D76  3215                    1961      MOVE.W  (A5),D1                    ;CHECK WHERE POINTER IS WHEN HITS HERE
00001D78                          1962      ;D1 WILL HAVE OUR DISPLACEMENT (0E32)
00001D78                          1963      ;ADD 0E32 TO PC + 2
00001D78  3E01                    1964      MOVE.W  D1,D7
00001D7A  DE4D                    1965      ADD.W   A5,D7
00001D7C                          1966      ;SUBI.B  #2,D7
00001D7C                          1967      
00001D7C  14FC 0009               1968      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001D80  14FC 0024               1969      MOVE.B  #'$',(A2)+                  ;add '$' to buffer
00001D84                          1970      
00001D84                          1971      ;convert to ASCII and put on buffer
00001D84                          1972      ;D7 HAS DISPLACEMENT   
00001D84  4EB9 00001D8E           1973      JSR     BRANCH_16_ITOA
00001D8A                          1974      
00001D8A  4EF8 195C               1975      JMP     EA_FINISH
00001D8E                          1976  
00001D8E                          1977  EA_BRANCH_32:
00001D8E                          1978      ;come back and implement branch 32
00001D8E                          1979  
00001D8E                          1980  
00001D8E                          1981  
00001D8E                          1982  BRANCH_16_ITOA:
00001D8E                          1983      ;D7 HAS OUR DISPLACEMENT... CONVERT TO ASCII!   ;D7 = 1234
00001D8E  E04F                    1984      LSR.W   #right8,D7                              ;D7 = 0012
00001D90  4EB9 00001FDC           1985      JSR     EA_ITOA_BYTE_CONVERT                    ;BUFFER WILL HAVE 12
00001D96  3E1D                    1986      MOVE.W  (A5)+,D7                                ;D7 = 0E32
00001D98  DE4D                    1987      ADD.W   A5,D7                                   ;D7 = 123
00001D9A  5507                    1988      SUBI.B  #2,D7                                   ;SUBI 2 to account for post increment of A5
00001D9C  0247 00FF               1989      ANDI.W  #$00FF,D7                               ;D7 = 0034
00001DA0  4EB9 00001FDC           1990      JSR     EA_ITOA_BYTE_CONVERT                    ;BUFFER WILL HAVE 1234
00001DA6                          1991      
00001DA6  4EF9 00002014           1992      JMP     EA_ITOA_DONE
00001DAC                          1993  
00001DAC                          1994  
00001DAC                          1995  EA_MATH:
00001DAC                          1996      ;source mode 3, 4, 5 | source register 0, 1, 2 | destination register 11, 10, 9
00001DAC  14FC 0009               1997      MOVE.B  #$09, (A2)+             ;add a ' ' to buffer
00001DB0  41F9 00001E74           1998      LEA     EA_MODE_TABLE,A0        ;load mode table
00001DB6                          1999      
00001DB6                          2000      ;isolate source mode
00001DB6  2800                    2001      MOVE.L  D0,D4
00001DB8  E64C                    2002      LSR.W   #3,D4
00001DBA  0244 0007               2003      ANDI.W  #$7,D4
00001DBE  C8FC 0006               2004      MULU    #6,D4
00001DC2                          2005      
00001DC2                          2006      ;isolate source register
00001DC2  2A00                    2007      MOVE.L  D0,D5
00001DC4  0245 0007               2008      ANDI.W  #$7,D5
00001DC8                          2009      
00001DC8  4EB9 00001E70           2010      JSR     EA_JMP_HELPER
00001DCE                          2011      
00001DCE  14FC 002C               2012      MOVE.B  #',',(A2)+              ;add a ',' to buffer
00001DD2                          2013      
00001DD2                          2014      ;condition for ADDA - opcode == 1101 && bits 7,6 == 11
00001DD2                          2015      ;check for ADDA and leave if yes, otherwise continue
00001DD2  2200                    2016      MOVE.L  D0,D1                   ;complete opcode in D1
00001DD4  EC49                    2017      LSR.W   #6,D1                   ;shift right 6
00001DD6  EC49                    2018      LSR.W   #6,D1                   ;shift another 6 to = 12 total
00001DD8                          2019      
00001DD8  B27C 000D               2020      CMP     #$D,D1                  ;check if opcode = 1101
00001DDC  6600 002C               2021      BNE     EA_MATH_CONTINUE        ;if not 1101, skip and go to math
00001DE0                          2022      
00001DE0                          2023      ;if we are here, we know opcode is 1101 and further check
00001DE0  2200                    2024      MOVE.L  D0,D1
00001DE2  EC49                    2025      LSR.W   #6,D1
00001DE4  0241 0003               2026      ANDI.W  #3,D1
00001DE8  B23C 0003               2027      CMP.B   #3,D1
00001DEC  6600 001C               2028      BNE     EA_MATH_CONTINUE
00001DF0                          2029      
00001DF0                          2030      ;if d1 == 3, both conditions met so process as ADDA
00001DF0                          2031      ;destination mode is 1 (address register)
00001DF0  7801                    2032      MOVE.L  #1,D4
00001DF2  C8FC 0006               2033      MULU    #6,D4
00001DF6                          2034      
00001DF6                          2035      ;isolate destination register 
00001DF6  2A00                    2036      MOVE.L  D0,D5
00001DF8  E84D                    2037      LSR.W   #4,D5
00001DFA  EA4D                    2038      LSR.W   #5,D5                      
00001DFC  0245 0007               2039      ANDI.W  #$7,D5   
00001E00                          2040   
00001E00  4EB9 00001E70           2041      JSR     EA_JMP_HELPER 
00001E06  4EF8 195C               2042      JMP     EA_FINISH
00001E0A                          2043          
00001E0A                          2044  EA_MATH_CONTINUE:       
00001E0A                          2045      ;destination mode is 0 (data register)
00001E0A  7800                    2046      MOVE.L  #0,D4
00001E0C  C8FC 0006               2047      MULU    #6,D4
00001E10                          2048      
00001E10                          2049      ;isolate destination register 
00001E10  2A00                    2050      MOVE.L  D0,D5
00001E12  E84D                    2051      LSR.W   #4,D5
00001E14  EA4D                    2052      LSR.W   #5,D5                      
00001E16  0245 0007               2053      ANDI.W  #$7,D5  
00001E1A                          2054      
00001E1A  4EB9 00001E70           2055      JSR     EA_JMP_HELPER 
00001E20  4EF8 195C               2056      JMP     EA_FINISH
00001E24                          2057      
00001E24                          2058  
00001E24                          2059  EA_ROTATION:
00001E24  14FC 0009               2060      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001E28  2200                    2061      MOVE.L  D0,D1                       ;complete opcode
00001E2A  EA49                    2062      LSR.W   #5,D1                       ;shift right 5
00001E2C  0241 0001               2063      ANDI.W  #1,D1
00001E30                          2064      
00001E30  B27C 0000               2065      CMP     #0,D1
00001E34  6700 002E               2066      BEQ     EA_ROTATION_IMMEDIATE       ;it is immediate value
00001E38  6000 0030               2067      BRA     EA_ROTATION_REGISTER        ;else register 
00001E3C                          2068  
00001E3C                          2069  EA_ROTATION_CONTINUE:
00001E3C  2200                    2070      MOVE.L  D0,D1                       ;get rotation value
00001E3E  0241 0F00               2071      ANDI.W  #nibble2,D1                 ;isolate nibble 2
00001E42  E049                    2072      LSR.W   #8,D1
00001E44  E249                    2073      LSR.W   #1,D1                       :total of 9 shifts right
00001E46                          2074      
00001E46                          2075      ;at this point we have our number, so convert to ASCII and put on buffer
00001E46  0601 0030               2076      ADDI.B  #$30,D1                     ;convert to ASCII
00001E4A  14C1                    2077      MOVE.B  D1,(A2)+                    ;put on buffer
00001E4C                          2078      
00001E4C  14FC 002C               2079      MOVE.B  #',',(A2)+                  ;add ',' to buffer 
00001E50  14FC 0044               2080      MOVE.B  #'D',(A2)+                  ;add 'D' to buffer
00001E54                          2081      
00001E54  2200                    2082      MOVE.L  D0,D1                       ;complete opcode
00001E56  0241 0007               2083      ANDI.W  #7,D1                       
00001E5A                          2084      
00001E5A  0601 0030               2085      ADDI.B  #$30,D1                     ;convert to ASCII
00001E5E  14C1                    2086      MOVE.B  D1,(A2)+                    ;put on buffer
00001E60                          2087      
00001E60  4EF8 195C               2088      JMP     EA_FINISH                   ;done
00001E64                          2089  
00001E64                          2090  EA_ROTATION_IMMEDIATE:
00001E64  14FC 0023               2091      MOVE.B  #'#',(A2)+                  ;add '#' to buffer
00001E68  60D2                    2092      BRA     EA_ROTATION_CONTINUE
00001E6A                          2093      
00001E6A                          2094  EA_ROTATION_REGISTER:
00001E6A  14FC 0044               2095      MOVE.B  #'D',(A2)+                  ;add '#' to buffer
00001E6E  60CC                    2096      BRA     EA_ROTATION_CONTINUE
00001E70                          2097      
00001E70                          2098  EA_JMP_HELPER
00001E70  4EF0 4000               2099      JMP     0(A0,D4)
00001E74                          2100  
00001E74                          2101  
00001E74                          2102  ;********************************************  EA_MODE_TABLE  ****************************************************  
00001E74                          2103  EA_MODE_TABLE:
00001E74  4EF9 00001EA4           2104      JMP     EA_MODE_000
00001E7A  4EF9 00001EB2           2105      JMP     EA_MODE_001
00001E80  4EF9 00001EC0           2106      JMP     EA_MODE_010
00001E86  4EF9 00001ED6           2107      JMP     EA_MODE_011
00001E8C  4EF9 00001EF0           2108      JMP     EA_MODE_100
00001E92  4EF9 00001F08           2109      JMP     EA_MODE_101
00001E98  4EF9 00001F08           2110      JMP     EA_MODE_110
00001E9E  4EF9 00001F08           2111      JMP     EA_MODE_111
00001EA4                          2112      ;JMP     EA_MODE_FINISH
00001EA4                          2113  
00001EA4                          2114  ;********************************************  EA_MODE_XXX  ****************************************************    
00001EA4                          2115  EA_MODE_000:                                        ;Data register 'Dn'
00001EA4  14FC 0044               2116      MOVE.B  #'D',(A2)+                              ;put D on buffer
00001EA8  1605                    2117      MOVE.B D5,D3                                    ;move to d3 for conversion
00001EAA  4EB9 00001F48           2118      JSR     EA_HEX_TO_ASCII                         ;puts register on buffer  
00001EB0  4E75                    2119      RTS
00001EB2                          2120      
00001EB2                          2121  EA_MODE_001:                                        ;Address Register 'An'
00001EB2  14FC 0041               2122      MOVE.B  #'A',(A2)+                              ;put A on buffer
00001EB6  1605                    2123      MOVE.B  D5,D3                                   ;move to d3 for conversion
00001EB8  4EB9 00001F48           2124      JSR     EA_HEX_TO_ASCII                         ;puts register on buffer  
00001EBE  4E75                    2125      RTS
00001EC0                          2126  
00001EC0                          2127  EA_MODE_010:                                        ;Address direct --> '(An)'
00001EC0  14FC 0028               2128      MOVE.B  #'(',(A2)+                              ;put ( on buffer
00001EC4  14FC 0041               2129      MOVE.B  #'A',(A2)+                              ;put A on buffer
00001EC8  1605                    2130      MOVE.B  D5,D3                                   ;move to D3 for conversion
00001ECA  4EB9 00001F48           2131      JSR     EA_HEX_TO_ASCII                         ;convert and put on buffer   
00001ED0  14FC 0029               2132      MOVE.B  #')',(A2)+                              ;put ) on buffer
00001ED4  4E75                    2133      RTS
00001ED6                          2134  
00001ED6                          2135  EA_MODE_011:                                        ;Address with Postincrement --> '(An)+' 
00001ED6  14FC 0028               2136      MOVE.B  #'(',(A2)+                              ;put ( on buffer
00001EDA  14FC 0041               2137      MOVE.B  #'A',(A2)+                              ;put A on buffer
00001EDE  1605                    2138      MOVE.B  D5,D3                                   ;move to D3 for conversion
00001EE0  4EB9 00001F48           2139      JSR     EA_HEX_TO_ASCII                         ;convert and put on buffer   
00001EE6  14FC 0029               2140      MOVE.B  #')',(A2)+                              ;put ) on buffer
00001EEA  14FC 002B               2141      MOVE.B  #'+',(A2)+                              ;put + on buffer
00001EEE  4E75                    2142      RTS
00001EF0                          2143  
00001EF0                          2144  EA_MODE_100:                                        ;Address with Predecrement --> '-(An)'
00001EF0  14FC 002D               2145      MOVE.B  #'-',(A2)+                              ;put - on buffer
00001EF4  14FC 0028               2146      MOVE.B  #'(',(A2)+                              ;put ( on buffer
00001EF8  14FC 0041               2147      MOVE.B  #'A',(A2)+                              ;put A on buffer
00001EFC  1605                    2148      MOVE.B  D5,D3                                   ;move to D3 for conversion
00001EFE  4EB9 00001F48           2149      JSR     EA_HEX_TO_ASCII                         ;convert and put on buffer   
00001F04  14FC 0029               2150      MOVE.B  #')',(A2)+                              ;put ) on buffer
00001F08                          2151  
00001F08                          2152  
00001F08                          2153  
00001F08                          2154  ;unsupported
00001F08                          2155  EA_MODE_101:                                        
00001F08                          2156  ;Address with Displacement --> '(d16, An)
00001F08                          2157      
00001F08                          2158  ;unsupported
00001F08                          2159  EA_MODE_110:
00001F08                          2160  
00001F08                          2161  
00001F08                          2162  
00001F08                          2163  ;some form of immediate data: short, long, immediate
00001F08                          2164  EA_MODE_111:
00001F08                          2165      ;D4 = MODE | D5 = register (000, 001, 100)
00001F08                          2166      ;000 = Absolute Short (xxx).w
00001F08                          2167      ;001 = Absolute Long (xxx).l
00001F08                          2168      ;100 = Immediate data
00001F08                          2169      
00001F08  BA3C 0000               2170      CMP.B   #000,D5
00001F0C  6700 0012               2171      BEQ     EA_111_ABSOLUTE_SHORT
00001F10  BA3C 0001               2172      CMP.B   #001,D5
00001F14  6700 001E               2173      BEQ     EA_111_ABSOLUTE_LONG
00001F18  BA3C 0064               2174      CMP.B   #100,D5
00001F1C  6700 002A               2175      BEQ     EA_111_IMMEDIATE
00001F20                          2176      
00001F20                          2177      ;HANDLE ERROR
00001F20                          2178              
00001F20                          2179      
00001F20                          2180  EA_111_ABSOLUTE_SHORT:
00001F20                          2181      ;A5 is looking at correct spot
00001F20                          2182      ;ADD WORD VALUE AT A5 ON TO BUFFER AT A2 AND INCREMENT BY WORD
00001F20  14FC 0024               2183      MOVE.B  #'$',(A2)+                              ;put $ on buffer
00001F24  3E15                    2184      MOVE.W  (A5),D7
00001F26  4246                    2185      CLR     D6
00001F28  1C3C 0001               2186      MOVE.B  #01,D6                                  ;word size in EA_ITOA_IMMEDIATE
00001F2C  4EB9 00001F7A           2187      JSR     EA_ITOA_IMMEDIATE
00001F32  4E75                    2188      RTS
00001F34                          2189  
00001F34                          2190  EA_111_ABSOLUTE_LONG:
00001F34  14FC 0024               2191      MOVE.B  #'$',(A2)+                              ;put $ on buffer
00001F38  3E15                    2192      MOVE.W  (A5),D7
00001F3A  4246                    2193      CLR     D6
00001F3C  1C3C 0002               2194      MOVE.B  #02,D6                                  ;long size in EA_ITOA_IMMEDIATE        
00001F40  4EB9 00001F7A           2195      JSR     EA_ITOA_IMMEDIATE
00001F46  4E75                    2196      RTS
00001F48                          2197  
00001F48                          2198  EA_111_IMMEDIATE:
00001F48                          2199      
00001F48                          2200  
00001F48                          2201     
00001F48                          2202      
00001F48                          2203  
00001F48                          2204  EA_HEX_TO_ASCII:
00001F48  0603 0030               2205      ADDI.B      #$30,D3                     ;add $30 to D1 to convert
00001F4C  14C3                    2206      MOVE.B      D3,(A2)+                    ;add to buffer and increment to next position
00001F4E  4E75                    2207      RTS     
00001F50                          2208  
00001F50                          2209  
00001F50                          2210  EA_CHECK_SIZE:
00001F50  4246                    2211      CLR     D6
00001F52  2C00                    2212      MOVE.L  D0,D6                           ;complete opcode --> D6
00001F54  0246 00F0               2213      ANDI.W  #nibble3,D6                     ;isolating nibble 3
00001F58  EC4E                    2214      LSR.W   #right6,D6                      ;shifting bits 7,6 --> 1,0
00001F5A                          2215      
00001F5A  BC7C 0000               2216      CMP     #00,D6
00001F5E  6700 000E               2217      BEQ     EA_SIZE_BYTE
00001F62  BC7C 0001               2218      CMP     #01,D6
00001F66  6700 000A               2219      BEQ     EA_SIZE_WORD
00001F6A  6000 000A               2220      BRA     EA_SIZE_LONG
00001F6E                          2221  
00001F6E                          2222  EA_SIZE_BYTE:
00001F6E  3E1D                    2223      MOVE.W  (A5)+,D7
00001F70                          2224      ;MOVE.B  #4,D3;                          SET UP COUNTER
00001F70  4E75                    2225      RTS
00001F72                          2226  
00001F72                          2227  EA_SIZE_WORD:
00001F72  3E15                    2228      MOVE.W  (A5),D7
00001F74                          2229      ;MOVE.B  #4,D3;                          SET UP COUNTER
00001F74  4E75                    2230      RTS
00001F76                          2231  
00001F76                          2232  EA_SIZE_LONG:
00001F76  3E15                    2233      MOVE.W  (A5),D7
00001F78                          2234      ;MOVE.B  #8,D3;                          SET UP COUNTER
00001F78  4E75                    2235      RTS
00001F7A                          2236  
00001F7A                          2237  
00001F7A                          2238  
00001F7A                          2239  EA_ITOA_IMMEDIATE:
00001F7A                          2240      ;D3 = counter, D7 = value to be converted, D6 = size
00001F7A  BC3C 0000               2241      CMP.B   #%00,D6
00001F7E  6700 0012               2242      BEQ     EA_ITOA_BYTE
00001F82  BC3C 0001               2243      CMP.B   #%01,D6
00001F86  6700 0016               2244      BEQ     EA_ITOA_WORD
00001F8A  BC3C 0002               2245      CMP.B   #%10,D6     
00001F8E  6700 0024               2246      BEQ     EA_ITOA_LONG
00001F92                          2247      
00001F92                          2248  
00001F92                          2249  ;EA_IT0A_IMMEDIATE_LOOP
00001F92                          2250  ;    CMP.B   #0,D3                       ;check if loop done
00001F92                          2251  ;    BEQ     EA_ITOA_FINISH              ;if = 0, loop done
00001F92                          2252      
00001F92                          2253  EA_ITOA_BYTE:
00001F92  4EB9 00001FDC           2254      JSR     EA_ITOA_BYTE_CONVERT
00001F98                          2255      
00001F98  4EF9 00002014           2256      JMP     EA_ITOA_DONE
00001F9E                          2257  
00001F9E                          2258  
00001F9E                          2259  EA_ITOA_WORD:
00001F9E  E04F                    2260      LSR.W   #right8,D7
00001FA0  4EB9 00001FDC           2261      JSR     EA_ITOA_BYTE_CONVERT
00001FA6  3E1D                    2262      MOVE.W  (A5)+,D7
00001FA8  4EB9 00001FDC           2263      JSR     EA_ITOA_BYTE_CONVERT
00001FAE                          2264      
00001FAE  4EF9 00002014           2265      JMP     EA_ITOA_DONE
00001FB4                          2266      
00001FB4                          2267  EA_ITOA_LONG:
00001FB4  E04F                    2268      LSR.W   #right8,D7
00001FB6  4EB9 00001FDC           2269      JSR     EA_ITOA_BYTE_CONVERT
00001FBC  3E1D                    2270      MOVE.W  (A5)+,D7
00001FBE  4EB9 00001FDC           2271      JSR     EA_ITOA_BYTE_CONVERT
00001FC4                          2272  
00001FC4  3E15                    2273      MOVE.W  (A5),D7
00001FC6  E04F                    2274      LSR.W   #right8,D7
00001FC8  4EB9 00001FDC           2275      JSR     EA_ITOA_BYTE_CONVERT
00001FCE  3E1D                    2276      MOVE.W  (A5)+,D7
00001FD0  4EB9 00001FDC           2277      JSR     EA_ITOA_BYTE_CONVERT
00001FD6                          2278  
00001FD6  4EF9 00002014           2279      JMP     EA_ITOA_DONE
00001FDC                          2280  
00001FDC                          2281  EA_ITOA_BYTE_CONVERT:
00001FDC  3607                    2282      MOVE.W  D7,D3
00001FDE  0243 00F0               2283      ANDI.W  #$F0,D3
00001FE2  E84B                    2284      LSR.W   #right4,D3
00001FE4  4EB9 00001FF8           2285      JSR     EA_ITOA_NIBBLE_CONVERT
00001FEA                          2286      
00001FEA  3607                    2287      MOVE.W  D7,D3
00001FEC  0243 000F               2288      ANDI.W  #$0F,D3
00001FF0  4EB9 00001FF8           2289      JSR     EA_ITOA_NIBBLE_CONVERT
00001FF6  4E75                    2290      RTS
00001FF8                          2291  
00001FF8                          2292  EA_ITOA_NIBBLE_CONVERT:
00001FF8  B63C 0009               2293      CMP.B   #9,D3
00001FFC  6E00 000E               2294      BGT     EA_ITOA_LETTER
00002000  6000 0002               2295      BRA     EA_ITOA_NUMBER
00002004                          2296  
00002004                          2297  EA_ITOA_HEX2ASCII:
00002004                          2298  
00002004                          2299  
00002004                          2300  
00002004                          2301  EA_ITOA_NUMBER:
00002004  0603 0030               2302      ADDI.B  #$30,D3
00002008  14C3                    2303      MOVE.B  D3,(A2)+
0000200A  4E75                    2304      RTS
0000200C                          2305  
0000200C                          2306  EA_ITOA_LETTER:
0000200C  0603 0037               2307      ADDI.B  #$37,D3
00002010  14C3                    2308      MOVE.B  D3,(A2)+
00002012  4E75                    2309      RTS
00002014                          2310  
00002014                          2311  EA_ITOA_DONE
00002014  4E75                    2312      RTS
00002016                          2313  
00002016                          2314      
00002016                          2315  ;****************************************** MESSAGES ***************************************************
00002016= 57 65 6C 63 6F 6D ...   2316  welcome_message         DC.B    'Welcome to 68k disassembler',CR,LF,0
00002034                          2317  
00002034= 50 6C 65 61 73 65 ...   2318  get_start_address       DC.B    'Please enter a starting address in hexadecimal',CR,LF,0
00002065                          2319  
00002065= 50 6C 65 61 73 65 ...   2320  get_end_address         DC.B    'Please enter an ending address in hexadecimal',CR,LF,0
00002095                          2321  
00002095= 49 6E 76 61 6C 69 ...   2322  atoi_error_invalid      DC.B    'Invalid address, characters must be $0-F',CR,LF,0
000020C0                          2323  
000020C0                          2324  
000020C0= 49 6E 76 61 6C 69 ...   2325  error_message_1         DC.B    'Invalid Address: Must be greater than 0',CR,LF,0
000020EA                          2326  
000020EA= 49 6E 76 61 6C 69 ...   2327  error_message_2         DC.B    'Invalid Address: Must be even',CR,LF,0
0000210A                          2328  
0000210A= 49 6E 76 61 6C 69 ...   2329  error_message_3         DC.B    'Invalid Address: Must be even',CR,LF,0
0000212A                          2330  
0000212A= 49 6E 76 61 6C 69 ...   2331  error_message_4         DC.B    'Invalid Address: Must be less than $00FFFFFF',CR,LF,0
00002159                          2332  
00002159= 49 6E 76 61 6C 69 ...   2333  error_message_5         DC.B    'Invalid Address: Must be greater than starting address',CR,LF,0
00002192                          2334  
00002192= 48 69 74 20 45 6E ...   2335  prompt_enter            DC.B    'Hit Enter to Continue',CR,LF,0
000021AA                          2336  
000021AA                          2337  
000021AA                          2338  ascii_start:
000021AA                          2339      DS.w    10          ;specify size later?
000021BE                          2340      
000021BE                          2341  ascii_end:
000021BE                          2342      DS.w    10          ;specify size later?
000021D2                          2343  
000021D2                          2344  buffer                  ;storing op code
000021D2                          2345      DS.W    64          ;do we leave as .w or change to .l ?
00002252                          2346      
00002252                          2347  
00002252                          2348      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_END           21BE
ASCII_START         21AA
ATOI                17E4
ATOI_DONE           1856
ATOI_ERROR          1856
ATOI_ERROR_INVALID  2095
ATOI_FORMAT         1846
ATOI_LOOP           17EA
ATOI_LOWERCASE_LETTER  183C
ATOI_NUMBER         1828
ATOI_UPPERCASE_LETTER  1832
BRANCH_16_ITOA      1D8E
BUFFER              21D2
BUFFER_SIZE         40
CR                  D
DECODING_LOOP       108A
DEST_MODE           1C0
DEST_REG            E00
DONE                10C8
EA_111_ABSOLUTE_LONG  1F34
EA_111_ABSOLUTE_SHORT  1F20
EA_111_IMMEDIATE    1F48
EA_BRANCH           1CFE
EA_BRANCH_16        1D76
EA_BRANCH_32        1D8E
EA_BRANCH_8_BIT_DISPLACEMENT  1D1E
EA_BRANCH_ITOA_HELPER  1D44
EA_BRANCH_NEGATIVE  1D2E
EA_BRANCH_POSITIVE  1D2C
EA_CHECK_SIZE       1F50
EA_DESTONLY         1A6C
EA_EXT              1A6C
EA_FINISH           195C
EA_HEX_TO_ASCII     1F48
EA_IMMEDIATE        195E
EA_ITOA_BYTE        1F92
EA_ITOA_BYTE_CONVERT  1FDC
EA_ITOA_DONE        2014
EA_ITOA_HEX2ASCII   2004
EA_ITOA_IMMEDIATE   1F7A
EA_ITOA_LETTER      200C
EA_ITOA_LONG        1FB4
EA_ITOA_NIBBLE_CONVERT  1FF8
EA_ITOA_NUMBER      2004
EA_ITOA_WORD        1F9E
EA_JMP_HELPER       1E70
EA_LEA              1A2C
EA_MATH             1DAC
EA_MATH_CONTINUE    1E0A
EA_MODE_000         1EA4
EA_MODE_001         1EB2
EA_MODE_010         1EC0
EA_MODE_011         1ED6
EA_MODE_100         1EF0
EA_MODE_101         1F08
EA_MODE_110         1F08
EA_MODE_111         1F08
EA_MODE_TABLE       1E74
EA_MOVE             19A0
EA_MOVEA            19E6
EA_MOVEM            1A6C
EA_MOVEM_ADDRREG_TO_MEM  1B32
EA_MOVEM_DATAREG_TO_MEM  1AAA
EA_MOVEM_IMMEDIATE_DESTINATION  1C4E
EA_MOVEM_IMMEDIATE_SOURCE  1C5E
EA_MOVEM_MEM_TO_ADDRREG  1BF0
EA_MOVEM_MEM_TO_DATAREG  1BC2
EA_MOVEM_MEM_TO_REG  1B84
EA_MOVEM_REG_TO_MEM  1A96
EA_QUICK            1C82
EA_QUICK_MOVEQ      1CD4
EA_ROTATION         1E24
EA_ROTATION_CONTINUE  1E3C
EA_ROTATION_IMMEDIATE  1E64
EA_ROTATION_REGISTER  1E6A
EA_SIZE_BYTE        1F6E
EA_SIZE_LONG        1F76
EA_SIZE_WORD        1F72
EA_START            1900
EA_TRAP             1C82
EA_TYPE_BRANCH      9
EA_TYPE_DESTONLY    4
EA_TYPE_EXT         5
EA_TYPE_IMMEDIATE   0
EA_TYPE_LEA         3
EA_TYPE_MATH        A
EA_TYPE_MOVE        1
EA_TYPE_MOVEA       2
EA_TYPE_MOVEA6      C
EA_TYPE_MOVEM       6
EA_TYPE_QUICK       8
EA_TYPE_ROTATION    B
EA_TYPE_TABLE       190E
EA_TYPE_TRAP        7
ENDA_ERROR_LARGE    18E0
ENDA_ERROR_LESS_THAN_STARTA  18F0
ENDA_ERROR_NOT_EVEN  18D0
ERROR_MESSAGE_1     20C0
ERROR_MESSAGE_2     20EA
ERROR_MESSAGE_3     210A
ERROR_MESSAGE_4     212A
ERROR_MESSAGE_5     2159
FILLED_SCREEN       10B4
GET_ENDING_ADDRESS  104A
GET_END_ADDRESS     2065
GET_STARTING_ADDRESS  1012
GET_START_ADDRESS   2034
ITOA                185A
ITOA_ADDRESS        1864
ITOA_ADDRESS_LOOP   1872
ITOA_BYTE           1864
ITOA_FINISH         18AE
ITOA_HEX2ASCII      188E
ITOA_LETTER         18A6
ITOA_LONG           1864
ITOA_LOOP           185C
ITOA_NUMBER         189E
ITOA_WORD           1864
LF                  A
LINES_PER_SCREEN    1E
MOVEM_CARRY         1C30
MOVEM_CHECK_MULTIPLE  1B04
MOVEM_LOOP          1C20
MOVEM_MULTIPLE      1B0C
MOVEM_MULTIPLE_A    1B2A
MOVEM_MULTIPLE_D    1B22
MOVEM_SET_MIN       1C40
NIBBLE1             F000
NIBBLE2             F00
NIBBLE3             F0
NIBBLE4             F
OPCODE0000          117E
OPCODE0001          1198
OPCODE0010          119E
OPCODE0011          11B8
OPCODE0100          11D2
OPCODE0101          11EC
OPCODE0110          1208
OPCODE0111          1222
OPCODE1000          1228
OPCODE1001          1244
OPCODE1010          124A
OPCODE1011          1250
OPCODE1100          1256
OPCODE1101          1272
OPCODE1110          128E
OPCODE1111          12AE
OP_0000_TABLE       12B4
OP_0100_TABLE       1314
OP_0110_TABLE       1374
OP_ADD              16E6
OP_ADDA             1704
OP_ADDI             1436
OP_ADDQ             15A6
OP_AND              16E6
OP_ANDI             13F2
OP_ASL              1726
OP_ASR              1744
OP_BEQ              161A
OP_BRA              15EA
OP_BSR              1602
OP_CHECK_SIZE       1762
OP_CHECK_SIZE_ADDA  17C8
OP_CHECK_SIZE_MOVEM  1786
OP_CLR              15A6
OP_CMP              1690
OP_CMPI             147A
OP_DATA_CLR         1108
OP_DATA_CLR_LOOP    1114
OP_DIVS             1656
OP_DIVU             163A
OP_EOR              16AE
OP_EORI             1458
OP_EXT              15A6
OP_FINISH           1102
OP_JMP              15A6
OP_JSR              15A6
OP_LEA              158E
OP_LSL              1762
OP_LSR              1762
OP_MOVEAL           14C0
OP_MOVEAW           150C
OP_MOVEB            149C
OP_MOVEL            14E8
OP_MOVEM            1568
OP_MOVEQ            161A
OP_MOVEW            1534
OP_MULS             16CA
OP_MULU             16AE
OP_NOP              1558
OP_NOT              15A6
OP_OR               1672
OP_ORI              13D4
OP_ROL              1762
OP_ROR              1762
OP_RTE              15A6
OP_RTS              15A6
OP_SIZE_BYTE        17AA
OP_SIZE_LONG        17BE
OP_SIZE_WORD        17B4
OP_START            10CC
OP_STOP             15A6
OP_SUB              1672
OP_SUBI             1414
OP_SUBQ             15C8
OP_TABLE            111E
OP_TRAP             15A6
OP_UNSUPPORTED_OPCODE  1762
PROMPT_ENTER        2192
REPEAT_OR_FINISH    10AE
RIGHT1              1
RIGHT10             A
RIGHT12             C
RIGHT16             10
RIGHT2              2
RIGHT24             18
RIGHT3              3
RIGHT4              4
RIGHT5              5
RIGHT6              6
RIGHT7              7
RIGHT8              8
RIGHT9              9
STACK               A0000
START               1000
STARTA_ERROR_LESS_THAN_ZERO  18B0
STARTA_ERROR_NOT_EVEN  18C0
START_DECODING      1088
VALIDATE_BEGINNING  18B0
WELCOME             1006
WELCOME_MESSAGE     2016
