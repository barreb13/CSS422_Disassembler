00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/11/2021 12:14:43 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler V1.8(ish)
00000000                             3  * Written by : Brent and Parker
00000000                             4  * Date       : 3/10/21
00000000                             5  * Description: Final Project for CSS 422
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  ;************************ Define Constants ********************************* 
00000000  =0000000D                  9  CR                  EQU     $0D     ;carriage return
00000000  =0000000A                 10  LF                  EQU     $0a     ;line feed
00000000  =000A0000                 11  stack               EQU     $000A0000
00000000  =0000001E                 12  lines_per_screen    EQU     30
00000000  =00000040                 13  buffer_size         EQU     64      ;size of buffer
00000000  =0000F000                 14  nibble1             EQU     $F000   ;1st nibble in code (bits 15-12)
00000000  =00000F00                 15  nibble2             EQU     $0F00   ;2nd nibble in code (bits 11-8)
00000000  =000000F0                 16  nibble3             EQU     $00F0   ;3rd nibble in code (bits 7-4)
00000000  =0000000F                 17  nibble4             EQU     $000F   ;4th nibble in code (bits 3-0)
00000000  =00000001                 18  right1              EQU     1       ;shift 1 time
00000000  =00000002                 19  right2              EQU     2       ;shift 2 times
00000000  =00000003                 20  right3              EQU     3       ;shift 3 times to extract src mode
00000000  =00000004                 21  right4              EQU     4       ;shift 4 times to extract 3rd nibble
00000000  =00000005                 22  right5              EQU     5       ;shift 5 times (unused)
00000000  =00000006                 23  right6              EQU     6       ;shift 6 times to extract dst mode
00000000  =00000007                 24  right7              EQU     7       ;shift 7 times
00000000  =00000008                 25  right8              EQU     8       ;shift 8 to extract 2nd nibble
00000000  =00000009                 26  right9              EQU     9       ;shift 9 times to check 2nd nibble?
00000000  =0000000A                 27  right10             EQU     10      ;shift 10
00000000  =0000000C                 28  right12             EQU     12      ;shift 12 to extract 3rd byte
00000000  =00000010                 29  right16             EQU     16      ;shift 16 to extract 2nd byte
00000000  =00000018                 30  right24             EQU     24      ;shift 24 to extract 1st byte
00000000  =000001C0                 31  dest_mode           EQU     $01C0   ; --> 0000 0001 1100 0000 (used for destination in MOVE/MOVEA
00000000  =00000E00                 32  dest_reg            EQU     $0E00   ;destination register (0000 0111 0000 0000)
00000000                            33  
00000000  =00000000                 34  ea_type_immediate   EQU     0
00000000  =00000001                 35  ea_type_move        EQU     1
00000000  =00000002                 36  ea_type_movea       EQU     2
00000000  =0000000C                 37  ea_type_movea6      EQU     12
00000000  =00000003                 38  ea_type_lea         EQU     3
00000000  =00000004                 39  ea_type_destonly    EQU     4
00000000  =00000005                 40  ea_type_ext         EQU     5
00000000  =00000006                 41  ea_type_movem       EQU     6
00000000  =00000007                 42  ea_type_trap        EQU     7
00000000  =00000008                 43  ea_type_quick       EQU     8
00000000  =00000009                 44  ea_type_branch      EQU     9
00000000  =0000000A                 45  ea_type_math        EQU     10
00000000  =0000000B                 46  ea_type_rotation    EQU     11
00000000                            47  
00000000                            48  
00000000                            49  ;flags???
00000000                            50  
00000000                            51  
00000000                            52  
00001000                            53      ORG    $1000
00001000                            54  START:                              ;first instruction of program
00001000  4FF9 000A0000             55      LEA     stack, SP               ;SP @ $A0000
00001006                            56  
00001006                            57  
00001006                            58  
00001006                            59  ;********************************** Welcome Message ******************************************** 
00001006                            60  WELCOME:
00001006  43F9 00001F42             61      LEA     welcome_message,A1      ;load the welcome message into A1
0000100C  103C 000E                 62      MOVE.B  #14,D0
00001010  4E4F                      63      TRAP    #15                     ;print contents of welcome_message
00001012                            64  
00001012                            65  
00001012                            66  ;*********************************** Get Starting Address *************************************** 
00001012                            67  GET_STARTING_ADDRESS:
00001012                            68      ;prompt for address
00001012  103C 000E                 69      MOVE.B  #14,D0    
00001016  43F9 00001F60             70      LEA     get_start_address,A1    ;load the get_start_address message into A1
0000101C  4E4F                      71      TRAP    #15                     ;print get_start_address
0000101E                            72      
0000101E                            73      ;get user input address, store, and convert
0000101E  43F9 000020BE             74      LEA     ascii_start,A1          ;store
00001024  103C 0002                 75      MOVE.B  #2,D0                   ;get user input    
00001028  4E4F                      76      TRAP    #15                     ;another trap to get input
0000102A  4EB9 000017A6             77      JSR     ATOI                    ;address is now in hex format in memory location
00001030                            78      
00001030                            79      
00001030                            80      ;at this point our address is in D4 in hex
00001030                            81      ;check if > 0
00001030  B8BC 00000000             82      CMP.L   #0,D4                       ;compare to D4
00001036  6F00 083A                 83      BLE     STARTA_ERROR_LESS_THAN_ZERO ;branch to ERROR_LESS_THAN_ZERO if less than 0
0000103A                            84      
0000103A                            85      ;?? MOVE.L  (A1),D3
0000103A                            86      
0000103A                            87      ;address is > 0 so check if even / odd
0000103A  E29C                      88      ROR.L   #1,D4
0000103C  6500 0844                 89      BCS     STARTA_ERROR_NOT_EVEN
00001040  E39C                      90      ROL.L   #1,D4    
00001042                            91      
00001042                            92      ;address is > 0 and verified even
00001042  2A39 000020BE             93      MOVE.l    (ascii_start),D5      ;load into A5
00001048  2A45                      94      MOVE.l    D5,A5                ;load into A5
0000104A                            95  
0000104A                            96  
0000104A                            97  ;******************************** Get Ending Address ******************************************** 
0000104A                            98  GET_ENDING_ADDRESS:
0000104A                            99      ;prompt for address 
0000104A  103C 000E                100      MOVE.B  #14,D0
0000104E  43F9 00001F91            101      LEA     get_end_address,A1      ;load the get_end_address message into A1  
00001054  4E4F                     102      TRAP    #15                     ;print get_end_address
00001056                           103      
00001056                           104      ;get user input address, store, and convert
00001056  43F9 000020D2            105      LEA     ascii_end,A1            ;store 
0000105C  103C 0002                106      MOVE.B  #2,D0                   ;get user input
00001060  4E4F                     107      TRAP    #15                     ;another trap to get intput
00001062  4EB9 000017A6            108      JSR ATOI
00001068                           109  
00001068                           110      ;perform checks:
00001068                           111      ;1.) even
00001068  E29C                     112      ROR.L   #1,D4
0000106A  6500 0826                113      BCS     ENDA_ERROR_NOT_EVEN
0000106E  E39C                     114      ROL.L   #1,D4    
00001070                           115      
00001070                           116      ;2.) less than 00FFFFFF
00001070  B8BC 00FFFFFF            117      CMP.L   #$00FFFFFF,D4
00001076  6C00 082A                118      BGE     ENDA_ERROR_LARGE    
0000107A                           119      
0000107A                           120      ;3.) greater than starting address
0000107A  BBC4                     121      CMP.L   D4,A5
0000107C  6C00 0834                122      BGE     ENDA_ERROR_LESS_THAN_STARTA
00001080                           123      
00001080                           124      ;good --> store in A6
00001080  2C39 000020D2            125      MOVE.l    (ascii_end),D6      ;load into D6
00001086  2C46                     126      MOVE.l    D6,A6               ;load into A6
00001088                           127  
00001088                           128  
00001088                           129  ;************************************ Main Loop???? ***********************************************
00001088                           130  ;get pointer to first given address
00001088                           131  ;pull hex code from that address and store in A1?
00001088                           132  ;take hex code and go to OP_TABLE
00001088                           133  
00001088                           134  
00001088                           135  ;A5 = starting address
00001088                           136  ;A6 = ending address
00001088                           137  START_DECODING:
00001088                           138      ;CLR.L   D2                             ;clear screen line counter
00001088                           139  
00001088                           140  DECODING_LOOP:
00001088  4EB9 00001092            141      JSR     OP_START                       ;get complete line of instruction to decode   
0000108E                           142      
0000108E                           143  
0000108E                           144      ;print tot screen
0000108E                           145      
0000108E                           146      ;check if finished or if screen is filled
0000108E                           147      ;handle checks
0000108E                           148     
0000108E                           149      
0000108E                           150  DONE:
0000108E  FFFF FFFF                151      SIMHALT                                 ; halt simulator
00001092                           152  
00001092                           153  
00001092                           154  
00001092                           155  ;************************************ OP Stuff *************************************************************************************************************************** 
00001092                           156  
00001092                           157  ;A0 = POINTER TO OP_TABLE???
00001092                           158  ;A1 = 
00001092                           159  ;A2 = buffer (this is our decoded string that will print to screen)
00001092                           160  ;A3 = 
00001092                           161  ;A4 = current memory address for buffer (used for clearing????)
00001092                           162  ;A5 = starting address / current address in memory
00001092                           163  ;A6 = ending address
00001092                           164  ;A7 = SP
00001092                           165  
00001092                           166  ;D0
00001092                           167  ;D1
00001092                           168  ;D2 = ?
00001092                           169  ;D3 = buffer size (used for loop = 64)
00001092                           170  ;D4 = 
00001092                           171  ;D5
00001092                           172  ;D6
00001092                           173  ;D7
00001092                           174  
00001092                           175  OP_START
00001092                           176      ;get complete line? 
00001092                           177      ;everything happens in here
00001092                           178      
00001092                           179      ;MOVEM.L         D2/A6, -(SP)
00001092                           180  
00001092  4EB9 000010CA            181      JSR         OP_DATA_CLR         ;clear buffer
00001098  45F9 000020E6            182      LEA         buffer, A2          ;A2 now points to buffer, which is cleared
0000109E                           183      
0000109E                           184  
0000109E                           185      ;print out current mem address by putting into buffer and then adding a ' ' (tab)
0000109E  7403                     186      MOVE.L      #$0003,D2           ;? BINARY --> 0011 ?
000010A0  4EB9 00001826            187      JSR         ITOA_ADDRESS        ;convert A5 (current address) to ASCII and put in buffer
000010A6  14FC 0009                188      MOVE.B      #$09, (A2)+         ;adds a ' ' to buffer
000010AA                           189      
000010AA                           190      ;at this point buffer has the memory address and a space, ready for op code                     !!TESTED UP UNTIL THIS POINT AND GOOD!!
000010AA                           191      
000010AA  41F9 000010E0            192      LEA         OP_TABLE, A0
000010B0  4280                     193      CLR.L       D0
000010B2  301D                     194      MOVE.W      (A5)+,D0            ;moves opcode from current address into D0
000010B4  2200                     195      MOVE.L      D0,D1               ;should move into D1
000010B6  143C 000C                196      MOVE.B      #right12,D2         ;move immediate value 12 into D2
000010BA  E469                     197      LSR.W       D2,D1               ;shift D1 by 12 bits, leaving just 4 bits (this is our opcode???)
000010BC  C2FC 0006                198      MULU        #6,D1               ;computes opcode table jump displacement
000010C0  4EF0 1000                199      JMP         0(A0,D1)            ;jumps to opcode table entry (A0 = OP_TABLE)
000010C4                           200  
000010C4                           201  OP_FINISH:
000010C4  4CDF 4004                202      MOVEM.L     (SP)+, D2/A6
000010C8  4E75                     203      RTS                             ;returns to DECODING_LOOP !?!?!?!?!?
000010CA                           204  
000010CA                           205  
000010CA                           206  OP_DATA_CLR:
000010CA  4283                     207      CLR.L       D3                  ; ? What is D3????
000010CC                           208      ;MOVE.B      #buffer_size,D3     ; put 64 into D3
000010CC  163C 000A                209      MOVE.B      #10,D3     ; put 10 into D3                                                                 ;delete after testing and use 64
000010D0  49F9 000020E6            210      LEA         buffer, A4          ; what address register?
000010D6                           211  
000010D6                           212  OP_DATA_CLR_LOOP:
000010D6  18FC 0000                213      MOVE.B      #0, (A4)+
000010DA  5343                     214      SUBI        #1, D3
000010DC  6EF8                     215      BGT         OP_DATA_CLR_LOOP
000010DE  4E75                     216      RTS                                 ;need RTS to return
000010E0                           217  
000010E0                           218  
000010E0                           219  ;********************************* jump table ****************************************
000010E0                           220  OP_TABLE:
000010E0  4EF9 00001140            221      JMP         opcode0000              ;ORI (ANDI, SUBI, ADDI, EORI, CMPI)                                 $0
000010E6  4EF9 0000115A            222      JMP         opcode0001              ;MOVE.B                                                             $1    
000010EC  4EF9 00001160            223      JMP         opcode0010              ;MOVEA.L, MOVE.L                                                    $2
000010F2  4EF9 0000117A            224      JMP         opcode0011              ;MOVEA.W MOVE.W                                                     $3
000010F8  4EF9 00001194            225      JMP         opcode0100              ;NOP, MOVEM, LEA (CLR, NOT, EXT, TRAP, STOP, RTE, RTS, JSR, JMP     $4
000010FE  4EF9 000011AE            226      JMP         opcode0101              ;ADDQ (SUBQ)                                                        $5
00001104  4EF9 000011CA            227      JMP         opcode0110              ;BRA.bw, BSR.bw (BEQ)                                               $6
0000110A  4EF9 000011E4            228      JMP         opcode0111              ;MOVEQ.l                                                            $7
00001110  4EF9 000011EA            229      JMP         opcode1000              ;DIVU (DIVS, OR)                                                    $8
00001116  4EF9 00001206            230      JMP         opcode1001              ;SUB                                                                $9
0000111C  4EF9 0000120C            231      JMP         opcode1010              ;not assigned                                                       $A
00001122  4EF9 00001212            232      JMP         opcode1011              ;CMP (EOR)                                                          $B
00001128  4EF9 00001218            233      JMP         opcode1100              ;MULU (MULS, AND)                                                   $C
0000112E  4EF9 00001234            234      JMP         opcode1101              ;ADD, ADDA                                                          $D
00001134  4EF9 00001250            235      JMP         opcode1110              ;ASL, ASR (LSL, LSR, ROL, ROR)                                      $E
0000113A  4EF9 00001270            236      JMP         opcode1111              ;not assigned                                                       $F
00001140                           237  
00001140                           238  
00001140                           239  
00001140                           240  
00001140                           241  ;A0 = POINTER TO OP_TABLE???
00001140                           242  ;A1 = 
00001140                           243  ;A2 = buffer (this is our decoded string that will print to screen)
00001140                           244  ;A3 = pointer to op_xxx_table
00001140                           245  ;A4 = current memory address for buffer (used for clearing????)
00001140                           246  ;A5 = starting address / current address in memory
00001140                           247  ;A6 = ending address
00001140                           248  ;A7 = SP
00001140                           249  
00001140                           250  ;D0 = full instruction
00001140                           251  ;D1 = full instruction for manipulating (temporary)
00001140                           252  ;D2 = will store immediate value for comparing
00001140                           253  ;D3 = buffer size (used for loop = 64)
00001140                           254  ;D4 = 
00001140                           255  ;D5 = 
00001140                           256  ;D6 = 
00001140                           257  ;D7 = 
00001140                           258  
00001140                           259  
00001140                           260  
00001140                           261  ;ORI (ANDI, SUBI, ADDI, EORI, CMPI)                                 $0
00001140                           262  opcode0000:                                 
00001140  2200                     263      MOVE.L      D0,D1                   ;D1 has full instruction
00001142  0241 0F00                264      ANDI.W      #nibble2,D1             ;check bits 11,10,9,8
00001146  143C 0008                265      MOVE.B      #right8, D2             ;store immediate value 8 in D2
0000114A  E469                     266      LSR.W       D2, D1                  ;shift to isolate next nibble (bits 11-8)
0000114C  C2FC 0006                267      MULU        #6, D1                  ;multiply by 6 to get displacement
00001150  47F9 00001276            268      LEA         OP_0000_TABLE, A3       ;load op_0000_table into address register
00001156  4EF3 1000                269      JMP         0(A3,D1)                ;jumps to opcode table entry (A0 = OP_TABLE)
0000115A                           270  
0000115A                           271  ;MOVE.B                                                             $1
0000115A                           272  opcode0001:
0000115A  4EF9 0000145E            273      JMP         OP_MOVEB                ;no need to break down, only MOVE.B
00001160                           274  
00001160                           275  
00001160                           276  ;MOVEA.L, MOVE.L                                                    $2
00001160                           277  opcode0010:
00001160  2200                     278      MOVE.L      D0,D1                   ;D1 has full instruction
00001162  0241 01C0                279      ANDI        #dest_mode, D1          ;0000 0001 1100 0000
00001166  143C 0006                280      MOVE.B      #right6, D2             ;D2 now 00000111
0000116A  E469                     281      LSR.W       D2, D1                  ;shifting destination mode in D1 to far right by 3
0000116C  B23C 0001                282      CMP.B       #1,D1                   ;does d1 = 001?
00001170  6700 0310                283      BEQ         OP_MOVEAL               ;if d1 = 001, go to MOVEA
00001174  4EF9 000014AA            284      JMP         OP_MOVEL                ;else jump to MOVEL
0000117A                           285      
0000117A                           286  
0000117A                           287  
0000117A                           288  
0000117A                           289  ;MOVEA.W MOVE.W                                                     $3
0000117A                           290  opcode0011:
0000117A  2200                     291      MOVE.L      D0,D1                   ;D1 has full instruction
0000117C  0241 01C0                292      ANDI        #dest_mode, D1          ;0000 0001 1100 0000
00001180  143C 0006                293      MOVE.B      #right6, D2             ;D2 now 00000111
00001184  E469                     294      LSR.W       D2, D1                  ;shifting destination mode in D1 to far right by 3
00001186  B23C 0001                295      CMP.B       #1,D1                   ;does d1 = 001?
0000118A  6700 0342                296      BEQ         OP_MOVEAW               ;if d1 = 001, go to MOVEAW
0000118E  4EF9 000014F6            297      JMP         OP_MOVEW                ;else jump to MOVEW
00001194                           298  
00001194                           299  
00001194                           300  
00001194                           301  
00001194                           302  ;NOP, MOVEM, LEA (CLR, NOT, EXT, TRAP, STOP, RTE, RTS, JSR, JMP)     $4
00001194                           303  opcode0100:
00001194  2200                     304      MOVE.L      D0,D1                   ;D1 has full instruction
00001196  0241 0F00                305      ANDI.W      #nibble2,D1             ;check bits 11,10,9,8
0000119A  143C 0008                306      MOVE.B      #right8, D2             ;store immediate value 8 in D2
0000119E  E469                     307      LSR.W       D2, D1                  ;shift to isolate next nibble (bits 11-8)
000011A0  C2FC 0006                308      MULU        #6, D1                  ;multiply by 6 to get displacement
000011A4  47F9 000012D6            309      LEA         OP_0100_TABLE, A3       ;load op_0000_table into address register
000011AA  4EF3 1000                310      JMP         0(A3,D1)                ;jumps to opcode table entry (A0 = OP_TABLE)
000011AE                           311  
000011AE                           312  
000011AE                           313  ;ADDQ (SUBQ)                                                        $5
000011AE                           314  opcode0101:
000011AE                           315      ;JMP         OP_ADDQ
000011AE                           316      
000011AE                           317      
000011AE                           318      ;3/8/21
000011AE  2200                     319      MOVE.L      D0,D1
000011B0  0241 0F00                320      ANDI.W      #nibble2,D1
000011B4  E049                     321      LSR.W       #right8,D1
000011B6  0241 0001                322      ANDI.W      #1,D1
000011BA  B23C 0000                323      CMP.B       #0,D1
000011BE  6700 03A8                324      BEQ         OP_ADDQ
000011C2  B23C 0001                325      CMP.B       #1,D1   
000011C6  6700 03C2                326      BEQ         OP_SUBQ
000011CA                           327      ;HANDLE ERROR
000011CA                           328  
000011CA                           329  
000011CA                           330  ;EA_ADDQ_SUBQ:
000011CA                           331  ;    ;CHECK BIT 8 FOR ADDQ OR SUBQ
000011CA                           332  ;    CMP.W       #nibble2,D1
000011CA                           333  ;    LSR.W       #right7,D1     
000011CA                           334  ;    ANDI.W      #1,D1
000011CA                           335  ;    CMP.B       #0,D1
000011CA                           336  ;    BEQ         EA_ADDQ
000011CA                           337  ;    CMP.B       #1,D1  
000011CA                           338  ;    BEQ         EA_SUBQ
000011CA                           339  ;    ;HANDLE ERROR      
000011CA                           340  
000011CA                           341  
000011CA                           342  ;BRA.bw, BSR.bw (BEQ)                                               $6
000011CA                           343  opcode0110:
000011CA  2200                     344      MOVE.L      D0,D1                   ;D1 has full instruction
000011CC  0241 0F00                345      ANDI.W      #nibble2,D1             ;check bits 11,10,9,8
000011D0  143C 0008                346      MOVE.B      #right8, D2             ;store immediate value 8 in D2
000011D4  E469                     347      LSR.W       D2, D1                  ;shift to isolate next nibble (bits 11-8)
000011D6  C2FC 0006                348      MULU        #6, D1                  ;multiply by 6 to get displacement
000011DA  47F9 00001336            349      LEA         OP_0110_TABLE, A3       ;load op_0110_table into address register
000011E0  4EF3 1000                350      JMP         0(A3,D1)                ;jumps to opcode table entry (A0 = OP_TABLE)
000011E4                           351      
000011E4                           352      ;come back and check when debugging. if this does not work then skip jump table
000011E4                           353  
000011E4                           354  
000011E4                           355  ;MOVEQ                                                            $7
000011E4                           356  opcode0111:
000011E4  4EF9 000015DC            357      JMP         OP_MOVEQ
000011EA                           358  
000011EA                           359  
000011EA                           360  
000011EA                           361  ;DIVU (DIVS, OR)                                                    $8
000011EA                           362  opcode1000:
000011EA  2200                     363      MOVE.L      D0,D1
000011EC  0241 0F00                364      ANDI.W      #nibble2,D1
000011F0  E049                     365      LSR.W       #8,D1
000011F2  0201 0001                366      ANDI.B      #1,D1
000011F6  B23C 0000                367      CMP.B       #0,D1
000011FA  6700 0400                368      BEQ         OP_DIVU
000011FE  B23C 0001                369      CMP.B       #1,D1
00001202  6700 0414                370      BEQ         OP_DIVS
00001206                           371      ;HANDLE ERROR
00001206                           372  
00001206                           373  ;SUB                                                                $9
00001206                           374  opcode1001:
00001206  4EF9 00001634            375      JMP         OP_SUB
0000120C                           376  
0000120C                           377  
0000120C                           378  ;not assigned                                                       $A
0000120C                           379  opcode1010:
0000120C  4EF9 00001724            380      JMP         OP_UNSUPPORTED_OPCODE
00001212                           381  
00001212                           382  
00001212                           383  ;CMP (EOR)                                                          $B
00001212                           384  opcode1011:
00001212  4EF9 00001652            385      JMP         OP_CMP
00001218                           386  
00001218                           387  
00001218                           388  ;MULU (MULS, AND)                                                   $C
00001218                           389  opcode1100:
00001218  2200                     390      MOVE.L      D0,D1
0000121A  0241 0F00                391      ANDI.W      #nibble2,D1
0000121E  E049                     392      LSR.W       #8,D1
00001220  0201 0001                393      ANDI.B      #1,D1
00001224  B23C 0000                394      CMP.B       #0,D1
00001228  6700 0446                395      BEQ         OP_MULU
0000122C  B23C 0001                396      CMP.B       #1,D1
00001230  6700 045A                397      BEQ         OP_MULS
00001234                           398      ;HANDLE ERROR
00001234                           399  
00001234                           400  ;ADD, ADDA                                                          $D
00001234                           401  opcode1101:
00001234                           402      ;ADD and ADDA differ on bits 6,7... ADD will never be 11 for bits 6,7... use as check
00001234  4241                     403      CLR         D1
00001236  4242                     404      CLR         D2
00001238  2200                     405      MOVE.L      D0,D1
0000123A  0241 00F0                406      ANDI.W      #nibble3, D1
0000123E  143C 0006                407      MOVE.B      #right6, D2
00001242  E469                     408      LSR.W       D2,D1
00001244                           409      
00001244                           410      ;at this point we have our bits of interest in bits 1,0
00001244                           411      
00001244  B27C 0003                412      CMP         #3,D1                              ;check if bits == 11
00001248  6700 047C                413      BEQ         OP_ADDA                             ;if yes, branch ADDA
0000124C  6000 045A                414      BRA         OP_ADD                              ;else branch ADD
00001250                           415  
00001250                           416  
00001250                           417  
00001250                           418  ;ASL, ASR (LSL, LSR, ROL, ROR)                                      $E
00001250                           419  opcode1110:
00001250  4241                     420      CLR D1
00001252  4242                     421      CLR D2
00001254  2200                     422      MOVE.L      D0, D1
00001256  0241 0F00                423      ANDI.W      #nibble2, D1
0000125A  143C 0008                424      MOVE.B      #right8, D2
0000125E  E469                     425      LSR.W       D2, D1                              ;D1 has 0003 or 0004
00001260  0241 0001                426      ANDI.W      #0001,D1                           ;isolate single bit
00001264                           427      
00001264                           428      ;at this point we have our single bit of interest in bit 0
00001264                           429      
00001264  B27C 0000                430      CMP         #0,D1                           ;check if bit == 0
00001268  6700 049C                431      BEQ         OP_ASR                          ;if yes, branch to ASR
0000126C  6000 047A                432      BRA         OP_ASL                          ;else, branch to ASL
00001270                           433  
00001270                           434  
00001270                           435  ;not assigned                                                       $F
00001270                           436  opcode1111:
00001270  4EF9 00001724            437      JMP         OP_UNSUPPORTED_OPCODE
00001276                           438  
00001276                           439  
00001276                           440  ;******************************** OP_XXX_TABLES ************************************
00001276                           441  ;once in OP_XXX_TABLE , we will use these entries to jump to specific op code to put into buffer
00001276                           442  
00001276                           443  OP_0000_TABLE:
00001276  4EF9 00001396            444      jmp OP_ORI                                      ;0  
0000127C  4EF9 00001724            445      jmp OP_UNSUPPORTED_OPCODE                       ;1
00001282  4EF9 000013B4            446      jmp OP_ANDI                                     ;2
00001288  4EF9 00001724            447      jmp OP_UNSUPPORTED_OPCODE                       ;3
0000128E  4EF9 000013D6            448      jmp OP_SUBI                                     ;4
00001294  4EF9 00001724            449      jmp OP_UNSUPPORTED_OPCODE                       ;5
0000129A  4EF9 000013F8            450      jmp OP_ADDI                                     ;6
000012A0  4EF9 00001724            451      jmp OP_UNSUPPORTED_OPCODE                       ;7
000012A6  4EF9 00001724            452      jmp OP_UNSUPPORTED_OPCODE                       ;8
000012AC  4EF9 00001724            453      jmp OP_UNSUPPORTED_OPCODE                       ;9
000012B2  4EF9 0000141A            454      jmp OP_EORI                                     ;10
000012B8  4EF9 00001724            455      jmp OP_UNSUPPORTED_OPCODE                       ;11
000012BE  4EF9 0000143C            456      jmp OP_CMPI                                     ;12
000012C4  4EF9 00001724            457      jmp OP_UNSUPPORTED_OPCODE                       ;13
000012CA  4EF9 00001724            458      jmp OP_UNSUPPORTED_OPCODE                       ;14
000012D0  4EF9 00001724            459      jmp OP_UNSUPPORTED_OPCODE                       ;15
000012D6                           460  
000012D6                           461  ;OP_0001_TABLE:
000012D6                           462  ;    jmp OP_MOVEB
000012D6                           463  
000012D6                           464  
000012D6                           465  ;OP_0010_TABLE:
000012D6                           466  ;   jmp OP_MOVEAL
000012D6                           467  ;   jmp OP_MOVEL
000012D6                           468  
000012D6                           469  
000012D6                           470  ;OP_0011_TABLE:
000012D6                           471  
000012D6                           472  
000012D6                           473  
000012D6                           474  ;NOP, MOVEM, LEA (CLR, NOT, EXT, TRAP, STOP, RTE, RTS, JSR, JMP     $4
000012D6                           475  ;NOP    1110
000012D6                           476  ;MOVEM  1D00
000012D6                           477  ;LEA    AN1
000012D6                           478  OP_0100_TABLE:
000012D6  4EF9 00001724            479      jmp OP_UNSUPPORTED_OPCODE                           ;0  
000012DC  4EF9 00001550            480      jmp OP_LEA                                          ;1      (address 0001)
000012E2  4EF9 00001724            481      jmp OP_UNSUPPORTED_OPCODE                           ;2
000012E8  4EF9 00001550            482      jmp OP_LEA                                          ;3      (address 0011)
000012EE  4EF9 00001724            483      jmp OP_UNSUPPORTED_OPCODE                           ;4 
000012F4  4EF9 00001550            484      jmp OP_LEA                                          ;5      (address 0101)
000012FA  4EF9 00001724            485      jmp OP_UNSUPPORTED_OPCODE                           ;6 
00001300  4EF9 00001550            486      jmp OP_LEA                                          ;7      (address 0111) 
00001306  4EF9 0000152A            487      jmp OP_MOVEM                                        ;8                          ;jmp OP_MOVEM_R2M
0000130C  4EF9 00001550            488      jmp OP_LEA                                          ;9      (address 1001) 
00001312  4EF9 00001724            489      jmp OP_UNSUPPORTED_OPCODE                           ;10 
00001318  4EF9 00001550            490      jmp OP_LEA                                          ;11     (address 1011) 
0000131E  4EF9 0000152A            491      jmp OP_MOVEM                                        ;12                         ;jmp OP_MOVEM_M2R    
00001324  4EF9 00001550            492      jmp OP_LEA                                          ;13     (address 1101)
0000132A  4EF9 0000151A            493      jmp OP_NOP                                          ;14
00001330  4EF9 00001550            494      jmp OP_LEA                                          ;15     (address 1111)
00001336                           495  
00001336                           496  
00001336                           497  ;OP_0101_TABLE:
00001336                           498  
00001336                           499  
00001336                           500  
00001336                           501  ;BRA nibble 2 = 0000 (0) , BSR nibble 2 = 0001 (1)
00001336                           502  OP_0110_TABLE:
00001336  4EF9 000015AC            503      jmp OP_BRA                                          ;0
0000133C  4EF9 000015C4            504      jmp OP_BSR                                          ;1
00001342  4EF9 00001724            505      jmp OP_UNSUPPORTED_OPCODE                           ;2
00001348  4EF9 00001724            506      jmp OP_UNSUPPORTED_OPCODE                           ;3
0000134E  4EF9 00001724            507      jmp OP_UNSUPPORTED_OPCODE                           ;4
00001354  4EF9 00001724            508      jmp OP_UNSUPPORTED_OPCODE                           ;5
0000135A  4EF9 00001724            509      jmp OP_UNSUPPORTED_OPCODE                           ;6
00001360  4EF9 00001724            510      jmp OP_UNSUPPORTED_OPCODE                           ;7
00001366  4EF9 00001724            511      jmp OP_UNSUPPORTED_OPCODE                           ;8
0000136C  4EF9 00001724            512      jmp OP_UNSUPPORTED_OPCODE                           ;9
00001372  4EF9 00001724            513      jmp OP_UNSUPPORTED_OPCODE                           ;10
00001378  4EF9 00001724            514      jmp OP_UNSUPPORTED_OPCODE                           ;11
0000137E  4EF9 00001724            515      jmp OP_UNSUPPORTED_OPCODE                           ;12
00001384  4EF9 00001724            516      jmp OP_UNSUPPORTED_OPCODE                           ;13
0000138A  4EF9 00001724            517      jmp OP_UNSUPPORTED_OPCODE                           ;14
00001390  4EF9 00001724            518      jmp OP_UNSUPPORTED_OPCODE                           ;15
00001396                           519  
00001396                           520  
00001396                           521  ;OP_0111_TABLE:
00001396                           522  ;implement later if needed
00001396                           523  
00001396                           524  
00001396                           525  ;OP_1000_TABLE:
00001396                           526  ;implement later if needed
00001396                           527  
00001396                           528  
00001396                           529  ;OP_1001_TABLE:
00001396                           530  ;implement later if needed
00001396                           531  
00001396                           532  
00001396                           533  ;OP_1010_TABLE:
00001396                           534  ;implement later if needed
00001396                           535  
00001396                           536  
00001396                           537  ;OP_1011_TABLE:
00001396                           538  ;implement later if needed
00001396                           539  
00001396                           540  
00001396                           541  ;OP_1100_TABLE:
00001396                           542  ;implement later if needed
00001396                           543  
00001396                           544  
00001396                           545  ;OP_1101_TABLE:
00001396                           546  ;implement later if needed
00001396                           547  
00001396                           548  
00001396                           549  ;OP_1110_TABLE:
00001396                           550  ;implement later if needed
00001396                           551  
00001396                           552  
00001396                           553  ;OP_1111_TABLE:
00001396                           554  ;implement later if needed
00001396                           555  
00001396                           556  
00001396                           557  
00001396                           558  
00001396                           559  ;******************************** OP_INSTRUCTION_XXXX******************************************
00001396                           560  ;this is where we are putting ascii text into buffer
00001396                           561  
00001396                           562  
00001396                           563  OP_ORI:
00001396  14FC 004F                564      MOVE.B  #'O', (A2)+
0000139A  14FC 0052                565      MOVE.B  #'R', (A2)+
0000139E  14FC 0049                566      MOVE.B  #'I', (A2)+
000013A2                           567      
000013A2                           568      ;call OP_CHECK_SIZE to append a .b/.w/.l
000013A2  4EB9 00001724            569      JSR     OP_CHECK_SIZE
000013A8                           570      
000013A8  7200                     571      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
000013AA                           572  
000013AA  4EB9 000018C2            573      JSR     EA_START
000013B0  4EF8 10C4                574      JMP     OP_FINISH
000013B4                           575  
000013B4                           576  OP_ANDI:  ;(optional)
000013B4  14FC 0041                577      MOVE.B  #'A', (A2)+
000013B8  14FC 004E                578      MOVE.B  #'N', (A2)+
000013BC  14FC 0044                579      MOVE.B  #'D', (A2)+
000013C0  14FC 0049                580      MOVE.B  #'I', (A2)+
000013C4                           581      
000013C4                           582      ;call OP_CHECK_SIZE to append a .b/.w/.l
000013C4  4EB9 00001724            583      JSR     OP_CHECK_SIZE
000013CA                           584      
000013CA  7200                     585      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
000013CC                           586  
000013CC  4EB9 000018C2            587      JSR     EA_START
000013D2  4EF8 10C4                588      JMP     OP_FINISH
000013D6                           589  
000013D6                           590  
000013D6                           591  OP_SUBI:  ;(optional)
000013D6  14FC 0053                592      MOVE.B  #'S', (A2)+
000013DA  14FC 0055                593      MOVE.B  #'U', (A2)+
000013DE  14FC 0042                594      MOVE.B  #'B', (A2)+
000013E2  14FC 0049                595      MOVE.B  #'I', (A2)+
000013E6                           596      
000013E6                           597      ;call OP_CHECK_SIZE to append a .b/.w/.l
000013E6  4EB9 00001724            598      JSR     OP_CHECK_SIZE
000013EC                           599      
000013EC  7200                     600      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
000013EE                           601  
000013EE  4EB9 000018C2            602      JSR     EA_START
000013F4  4EF8 10C4                603      JMP     OP_FINISH
000013F8                           604  
000013F8                           605  
000013F8                           606  OP_ADDI:  ;(optional)
000013F8  14FC 0041                607      MOVE.B  #'A', (A2)+
000013FC  14FC 0044                608      MOVE.B  #'D', (A2)+
00001400  14FC 0044                609      MOVE.B  #'D', (A2)+
00001404  14FC 0049                610      MOVE.B  #'I', (A2)+
00001408                           611      
00001408                           612      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001408  4EB9 00001724            613      JSR     OP_CHECK_SIZE
0000140E                           614     
0000140E  7200                     615      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
00001410                           616  
00001410  4EB9 000018C2            617      JSR     EA_START
00001416  4EF8 10C4                618      JMP     OP_FINISH
0000141A                           619  
0000141A                           620  
0000141A                           621  OP_EORI:  ;(optional)
0000141A  14FC 0045                622      MOVE.B  #'E', (A2)+
0000141E  14FC 004F                623      MOVE.B  #'O', (A2)+
00001422  14FC 0052                624      MOVE.B  #'R', (A2)+
00001426  14FC 0049                625      MOVE.B  #'I', (A2)+
0000142A                           626      
0000142A                           627      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000142A  4EB9 00001724            628      JSR     OP_CHECK_SIZE
00001430                           629      
00001430  7200                     630      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
00001432                           631      
00001432  4EB9 000018C2            632      JSR     EA_START
00001438  4EF8 10C4                633      JMP     OP_FINISH
0000143C                           634  
0000143C                           635  
0000143C                           636  OP_CMPI:  ;(optional)
0000143C  14FC 0043                637      MOVE.B  #'C', (A2)+
00001440  14FC 004D                638      MOVE.B  #'M', (A2)+
00001444  14FC 0050                639      MOVE.B  #'P', (A2)+
00001448  14FC 0049                640      MOVE.B  #'I', (A2)+
0000144C                           641      
0000144C                           642      
0000144C                           643      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000144C  4EB9 00001724            644      JSR     OP_CHECK_SIZE
00001452                           645  
00001452  7200                     646      MOVE.L  #ea_type_immediate, D1              ;preps for EA_START and puts 0 into D1
00001454                           647  
00001454  4EB9 000018C2            648      JSR     EA_START
0000145A  4EF8 10C4                649      JMP     OP_FINISH
0000145E                           650  
0000145E                           651  
0000145E                           652  OP_MOVEB:
0000145E  14FC 004D                653      MOVE.B  #'M', (A2)+
00001462  14FC 004F                654      MOVE.B  #'O', (A2)+
00001466  14FC 0056                655      MOVE.B  #'V', (A2)+
0000146A  14FC 0045                656      MOVE.B  #'E', (A2)+
0000146E  14FC 002E                657      MOVE.B  #'.', (A2)+
00001472  14FC 0042                658      MOVE.B  #'B', (A2)+
00001476                           659      
00001476  7201                     660      MOVE.L  #ea_type_move, D1                   ;preps for EA_START and puts 1 into D1
00001478                           661      
00001478  4EB9 000018C2            662      JSR     EA_START
0000147E  4EF8 10C4                663      JMP     OP_FINISH
00001482                           664  
00001482                           665  OP_MOVEAL:
00001482  14FC 004D                666      MOVE.B  #'M', (A2)+
00001486  14FC 004F                667      MOVE.B  #'O', (A2)+
0000148A  14FC 0056                668      MOVE.B  #'V', (A2)+
0000148E  14FC 0045                669      MOVE.B  #'E', (A2)+
00001492  14FC 0041                670      MOVE.B  #'A', (A2)+
00001496  14FC 002E                671      MOVE.B  #'.', (A2)+
0000149A  14FC 004C                672      MOVE.B  #'L', (A2)+
0000149E                           673      
0000149E  7202                     674      MOVE.L  #ea_type_movea, D1                   ;preps for EA_START and puts 2 into D1
000014A0                           675      
000014A0  4EB9 000018C2            676      JSR     EA_START
000014A6  4EF8 10C4                677      JMP     OP_FINISH
000014AA                           678  
000014AA                           679  OP_MOVEL:
000014AA  14FC 004D                680      MOVE.B  #'M', (A2)+
000014AE  14FC 004F                681      MOVE.B  #'O', (A2)+
000014B2  14FC 0056                682      MOVE.B  #'V', (A2)+
000014B6  14FC 0045                683      MOVE.B  #'E', (A2)+
000014BA  14FC 002E                684      MOVE.B  #'.', (A2)+
000014BE  14FC 004C                685      MOVE.B  #'L', (A2)+
000014C2                           686      
000014C2  7201                     687      MOVE.L  #ea_type_move, D1                   ;preps for EA_START and puts 1 into D1
000014C4                           688      
000014C4  4EB9 000018C2            689      JSR     EA_START
000014CA  4EF8 10C4                690      JMP     OP_FINISH
000014CE                           691  
000014CE                           692  
000014CE                           693  OP_MOVEAW:
000014CE  14FC 004D                694      MOVE.B  #'M', (A2)+
000014D2  14FC 004F                695      MOVE.B  #'O', (A2)+
000014D6  14FC 0056                696      MOVE.B  #'V', (A2)+
000014DA  14FC 0045                697      MOVE.B  #'E', (A2)+
000014DE  14FC 0041                698      MOVE.B  #'A', (A2)+
000014E2  14FC 002E                699      MOVE.B  #'.', (A2)+
000014E6  14FC 0057                700      MOVE.B  #'W', (A2)+
000014EA                           701      
000014EA  7202                     702      MOVE.L  #ea_type_movea, D1                   ;preps for EA_START and puts 2 into D1
000014EC                           703      
000014EC  4EB9 000018C2            704      JSR     EA_START
000014F2  4EF8 10C4                705      JMP     OP_FINISH
000014F6                           706  
000014F6                           707  
000014F6                           708  OP_MOVEW:
000014F6  14FC 004D                709      MOVE.B  #'M', (A2)+
000014FA  14FC 004F                710      MOVE.B  #'O', (A2)+
000014FE  14FC 0056                711      MOVE.B  #'V', (A2)+
00001502  14FC 0045                712      MOVE.B  #'E', (A2)+
00001506  14FC 002E                713      MOVE.B  #'.', (A2)+
0000150A  14FC 0057                714      MOVE.B  #'W', (A2)+
0000150E                           715      
0000150E  7201                     716      MOVE.L  #ea_type_move, D1                   ;preps for EA_START and puts 1 into D1
00001510                           717      
00001510  4EB9 000018C2            718      JSR     EA_START
00001516  4EF8 10C4                719      JMP     OP_FINISH
0000151A                           720  
0000151A                           721  
0000151A                           722  OP_NOP:
0000151A  14FC 004E                723      MOVE.B  #'N', (A2)+
0000151E  14FC 004F                724      MOVE.B  #'O', (A2)+
00001522  14FC 0050                725      MOVE.B  #'P', (A2)+
00001526                           726      
00001526                           727      ;NO EA
00001526  4EF8 10C4                728      JMP     OP_FINISH
0000152A                           729  
0000152A                           730  
0000152A                           731  OP_MOVEM:
0000152A                           732      ;see movemd2r or movemr2d... see below at bottom ?????
0000152A                           733      
0000152A  14FC 004D                734      MOVE.B  #'M', (A2)+
0000152E  14FC 004F                735      MOVE.B  #'O', (A2)+
00001532  14FC 0056                736      MOVE.B  #'V', (A2)+
00001536  14FC 0045                737      MOVE.B  #'E', (A2)+
0000153A  14FC 004D                738      MOVE.B  #'M', (A2)+
0000153E                           739      
0000153E                           740      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000153E  4EB9 00001748            741      JSR     OP_CHECK_SIZE_MOVEM
00001544                           742      
00001544  7206                     743      MOVE.L  #ea_type_movem, D1                   ;preps for EA_START and puts 6 into D1
00001546                           744      
00001546  4EB9 000018C2            745      JSR     EA_START
0000154C  4EF8 10C4                746      JMP     OP_FINISH
00001550                           747  
00001550                           748  OP_LEA:
00001550  14FC 004C                749      MOVE.B  #'L', (A2)+
00001554  14FC 0045                750      MOVE.B  #'E', (A2)+
00001558  14FC 0041                751      MOVE.B  #'A', (A2)+
0000155C                           752      
0000155C  7203                     753      MOVE.L  #ea_type_lea, D1                   ;preps for EA_START and puts 3 into D1
0000155E                           754      
0000155E  4EB9 000018C2            755      JSR     EA_START
00001564  4EF8 10C4                756      JMP     OP_FINISH
00001568                           757  
00001568                           758  OP_CLR:  ;(optional)
00001568                           759  ;implement later if needed
00001568                           760  
00001568                           761  
00001568                           762  OP_NOT:  ;(optional)
00001568                           763  ;implement later if needed
00001568                           764  
00001568                           765  
00001568                           766  OP_EXT:  ;(optional)
00001568                           767  ;implement later if needed
00001568                           768  
00001568                           769  
00001568                           770  OP_TRAP:  ;(optional)
00001568                           771  ;implement later if needed
00001568                           772  
00001568                           773   
00001568                           774  OP_STOP:  ;(optional)
00001568                           775  ;implement later if needed
00001568                           776  
00001568                           777  
00001568                           778  OP_RTE:  ;(optional)
00001568                           779  ;implement later if needed
00001568                           780  
00001568                           781  
00001568                           782  OP_RTS:  ;(optional)
00001568                           783  ;implement later if needed
00001568                           784  
00001568                           785  
00001568                           786  OP_JSR:  ;(optional)
00001568                           787  ;implement later if needed
00001568                           788  
00001568                           789  
00001568                           790  OP_JMP:  ;(optional)
00001568                           791  ;implement later if needed
00001568                           792  
00001568                           793  
00001568                           794  OP_ADDQ:
00001568  14FC 0041                795      MOVE.B  #'A', (A2)+
0000156C  14FC 0044                796      MOVE.B  #'D', (A2)+
00001570  14FC 0044                797      MOVE.B  #'D', (A2)+
00001574  14FC 0051                798      MOVE.B  #'Q', (A2)+
00001578                           799      
00001578                           800      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001578  4EB9 00001724            801      JSR     OP_CHECK_SIZE
0000157E                           802  
0000157E  7208                     803      MOVE.L  #ea_type_quick, D1                   ;preps for EA_START and puts 8 into D1
00001580                           804  
00001580  4EB9 000018C2            805      JSR     EA_START
00001586  4EF8 10C4                806      JMP     OP_FINISH
0000158A                           807  
0000158A                           808  OP_SUBQ:  ;(optional)
0000158A  14FC 0053                809      MOVE.B  #'S', (A2)+
0000158E  14FC 0055                810      MOVE.B  #'U', (A2)+
00001592  14FC 0042                811      MOVE.B  #'B', (A2)+
00001596  14FC 0051                812      MOVE.B  #'Q', (A2)+
0000159A                           813      
0000159A                           814      ;call OP_CHECK_SIZE to append a .b/.w/.l
0000159A  4EB9 00001724            815      JSR     OP_CHECK_SIZE
000015A0                           816      
000015A0  7208                     817      MOVE.L  #ea_type_quick, D1                   ;preps for EA_START and puts 8 into D1
000015A2                           818  
000015A2  4EB9 000018C2            819      JSR     EA_START
000015A8  4EF8 10C4                820      JMP     OP_FINISH
000015AC                           821  
000015AC                           822  OP_BRA:                                     ;???? DO WE DEFINE SIZE HERE OR AFTER????
000015AC  14FC 0042                823      MOVE.B  #'B', (A2)+
000015B0  14FC 0052                824      MOVE.B  #'R', (A2)+
000015B4  14FC 0041                825      MOVE.B  #'A', (A2)+
000015B8                           826  
000015B8  7209                     827      MOVE.L  #ea_type_branch,D1
000015BA                           828      
000015BA  4EB9 000018C2            829      JSR     EA_START
000015C0  4EF8 10C4                830      JMP     OP_FINISH
000015C4                           831  
000015C4                           832  
000015C4                           833  OP_BSR:
000015C4  14FC 0042                834      MOVE.B  #'B', (A2)+
000015C8  14FC 0053                835      MOVE.B  #'S', (A2)+
000015CC  14FC 0052                836      MOVE.B  #'R', (A2)+
000015D0                           837      
000015D0  7209                     838      MOVE.L  #ea_type_branch,D1
000015D2                           839      
000015D2  4EB9 000018C2            840      JSR     EA_START                        ;DO WE HAVE EA?
000015D8  4EF8 10C4                841      JMP     OP_FINISH
000015DC                           842  
000015DC                           843  
000015DC                           844  OP_BEQ:
000015DC                           845  ;implement later if needed
000015DC                           846  
000015DC                           847  
000015DC                           848  OP_MOVEQ:
000015DC  14FC 004D                849      MOVE.B  #'M', (A2)+
000015E0  14FC 004F                850      MOVE.B  #'O', (A2)+
000015E4  14FC 0056                851      MOVE.B  #'V', (A2)+
000015E8  14FC 0045                852      MOVE.B  #'E', (A2)+
000015EC  14FC 0051                853      MOVE.B  #'Q', (A2)+
000015F0                           854      
000015F0                           855      ;DO WE NEED A .L ?
000015F0                           856      
000015F0  7208                     857      MOVE.L  #ea_type_quick, D1                   ;preps for EA_START and puts 8 into D1
000015F2                           858      
000015F2  4EB9 000018C2            859      JSR     EA_START
000015F8  4EF8 10C4                860      JMP     OP_FINISH
000015FC                           861  
000015FC                           862  
000015FC                           863  OP_DIVU:
000015FC  14FC 0044                864      MOVE.B  #'D', (A2)+
00001600  14FC 0049                865      MOVE.B  #'I', (A2)+
00001604  14FC 0056                866      MOVE.B  #'V', (A2)+
00001608  14FC 0055                867      MOVE.B  #'U', (A2)+
0000160C                           868    
0000160C  720A                     869      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
0000160E                           870    
0000160E  4EB9 000018C2            871      JSR     EA_START
00001614  4EF8 10C4                872      JMP     OP_FINISH    
00001618                           873  
00001618                           874  
00001618                           875  OP_DIVS  ;(optional)
00001618  14FC 0044                876      MOVE.B  #'D', (A2)+
0000161C  14FC 0049                877      MOVE.B  #'I', (A2)+
00001620  14FC 0056                878      MOVE.B  #'V', (A2)+
00001624  14FC 0053                879      MOVE.B  #'S', (A2)+
00001628                           880    
00001628  720A                     881      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
0000162A                           882    
0000162A  4EB9 000018C2            883      JSR     EA_START
00001630  4EF8 10C4                884      JMP     OP_FINISH   
00001634                           885  
00001634                           886  
00001634                           887  OP_OR  ;(optional)
00001634                           888  ;implement later if needed
00001634                           889  
00001634                           890  
00001634                           891  OP_SUB:
00001634  14FC 0053                892      MOVE.B  #'S', (A2)+
00001638  14FC 0055                893      MOVE.B  #'U', (A2)+
0000163C  14FC 0042                894      MOVE.B  #'B', (A2)+
00001640                           895  
00001640  4EB9 00001724            896      JSR     OP_CHECK_SIZE                       ;call OP_CHECK_SIZE to append a .b/.w/.l
00001646                           897      
00001646  720A                     898      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
00001648                           899      
00001648                           900      ;at this point it will return with SUB.X and go to EA_START
00001648  4EB9 000018C2            901      JSR     EA_START
0000164E  4EF8 10C4                902      JMP     OP_FINISH    
00001652                           903  
00001652                           904  
00001652                           905  OP_CMP:
00001652  14FC 0043                906      MOVE.B  #'C', (A2)+
00001656  14FC 004D                907      MOVE.B  #'M', (A2)+
0000165A  14FC 0050                908      MOVE.B  #'P', (A2)+
0000165E                           909    
0000165E  4EB9 00001724            910      JSR     OP_CHECK_SIZE                       ;call OP_CHECK_SIZE to append a .b/.w/.l  
00001664                           911      
00001664  720A                     912      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
00001666                           913      
00001666                           914      ;at this point it will return with SUB.X and go to EA_START
00001666  4EB9 000018C2            915      JSR     EA_START
0000166C  4EF8 10C4                916      JMP     OP_FINISH    
00001670                           917      
00001670                           918  
00001670                           919  
00001670                           920  OP_EOR:  ;(optional)
00001670                           921  ;implement later if needed
00001670                           922  
00001670                           923  
00001670                           924  OP_MULU:
00001670  14FC 004D                925      MOVE.B  #'M', (A2)+
00001674  14FC 0055                926      MOVE.B  #'U', (A2)+
00001678  14FC 004C                927      MOVE.B  #'L', (A2)+
0000167C  14FC 0055                928      MOVE.B  #'U', (A2)+
00001680                           929  
00001680  720A                     930      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
00001682                           931      
00001682  4EB9 000018C2            932      JSR     EA_START
00001688  4EF8 10C4                933      JMP     OP_FINISH    
0000168C                           934  
0000168C                           935  OP_MULS:  ;(optional)
0000168C  14FC 004D                936      MOVE.B  #'M', (A2)+
00001690  14FC 0055                937      MOVE.B  #'U', (A2)+
00001694  14FC 004C                938      MOVE.B  #'L', (A2)+
00001698  14FC 0053                939      MOVE.B  #'S', (A2)+
0000169C                           940  
0000169C  720A                     941      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
0000169E                           942  
0000169E  4EB9 000018C2            943      JSR     EA_START
000016A4  4EF8 10C4                944      JMP     OP_FINISH
000016A8                           945  
000016A8                           946  
000016A8                           947  OP_AND:  ;(optional)
000016A8                           948  ;implement later if needed
000016A8                           949  
000016A8                           950  
000016A8                           951  OP_ADD:
000016A8  14FC 0041                952      MOVE.B  #'A', (A2)+
000016AC  14FC 0044                953      MOVE.B  #'D', (A2)+
000016B0  14FC 0044                954      MOVE.B  #'D', (A2)+
000016B4                           955  
000016B4                           956      ;call OP_CHECK_SIZE to append a .b/.w/.l
000016B4  4EB9 00001724            957      JSR     OP_CHECK_SIZE
000016BA                           958      
000016BA  720A                     959      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
000016BC                           960  
000016BC  4EB9 000018C2            961      JSR     EA_START
000016C2  4EF8 10C4                962      JMP     OP_FINISH
000016C6                           963  
000016C6                           964  OP_ADDA:
000016C6  14FC 0041                965      MOVE.B  #'A', (A2)+
000016CA  14FC 0044                966      MOVE.B  #'D', (A2)+
000016CE  14FC 0044                967      MOVE.B  #'D', (A2)+
000016D2  14FC 0041                968      MOVE.B  #'A', (A2)+
000016D6                           969  
000016D6                           970      ;call OP_CHECK_SIZE to append a .b/.w/.l
000016D6  4EB9 0000178A            971      JSR     OP_CHECK_SIZE_ADDA
000016DC                           972      
000016DC  720A                     973      MOVE.L  #ea_type_math, D1                   ;preps for EA_START and puts 10 into D1
000016DE                           974  
000016DE  4EB9 000018C2            975      JSR     EA_START
000016E4  4EF8 10C4                976      JMP     OP_FINISH
000016E8                           977  
000016E8                           978  
000016E8                           979  OP_ASL:
000016E8  14FC 0041                980      MOVE.B  #'A', (A2)+
000016EC  14FC 0053                981      MOVE.B  #'S', (A2)+
000016F0  14FC 004C                982      MOVE.B  #'L', (A2)+
000016F4                           983  
000016F4                           984      ;call OP_CHECK_SIZE to append a .b/.w/.l
000016F4  4EB9 00001724            985      JSR     OP_CHECK_SIZE
000016FA                           986      
000016FA  720B                     987      MOVE.L  #ea_type_rotation, D1                   ;preps for EA_START and puts 10 into D1
000016FC                           988      
000016FC  4EB9 000018C2            989      JSR     EA_START
00001702  4EF8 10C4                990      JMP     OP_FINISH
00001706                           991  
00001706                           992  
00001706                           993  OP_ASR:
00001706  14FC 0041                994      MOVE.B  #'A', (A2)+
0000170A  14FC 0053                995      MOVE.B  #'S', (A2)+
0000170E  14FC 0052                996      MOVE.B  #'R', (A2)+
00001712                           997  
00001712                           998      ;call OP_CHECK_SIZE to append a .b/.w/.l
00001712  4EB9 00001724            999      JSR     OP_CHECK_SIZE
00001718                          1000      
00001718  720B                    1001      MOVE.L  #ea_type_rotation, D1                   ;preps for EA_START and puts 10 into D1
0000171A                          1002  
0000171A  4EB9 000018C2           1003      JSR     EA_START
00001720  4EF8 10C4               1004      JMP     OP_FINISH
00001724                          1005  
00001724                          1006  OP_LSL:  ;(optional)
00001724                          1007  ;implement later if needed
00001724                          1008  
00001724                          1009  
00001724                          1010  
00001724                          1011  OP_LSR:  ;(optional)
00001724                          1012  ;implement later if needed
00001724                          1013  
00001724                          1014  
00001724                          1015  
00001724                          1016  OP_ROL:  ;(optional)
00001724                          1017  ;implement later if needed
00001724                          1018  
00001724                          1019  
00001724                          1020  
00001724                          1021  OP_ROR:  ;(optional)
00001724                          1022  ;implement later if needed
00001724                          1023  
00001724                          1024  
00001724                          1025  
00001724                          1026  ;OP_MOVEM_R2M:
00001724                          1027  ;    MOVE.B  #'M', (A2)+
00001724                          1028  ;    MOVE.B  #'O', (A2)+
00001724                          1029  ;    MOVE.B  #'V', (A2)+
00001724                          1030  ;    MOVE.B  #'E', (A2)+
00001724                          1031  ;    MOVE.B  #'M', (A2)+
00001724                          1032      
00001724                          1033  ;    ;call OP_CHECK_SIZE to append a .b/.w/.l
00001724                          1034  ;    JSR     OP_CHECK_SIZE
00001724                          1035      
00001724                          1036  ;    MOVE.L  #ea_type_movem, D1                   ;preps for EA_START and puts 6 into D1
00001724                          1037      
00001724                          1038  ;    JSR     EA_START
00001724                          1039  ;    JMP     OP_FINISH
00001724                          1040  
00001724                          1041  
00001724                          1042  ;OP_MOVEM_M2R:
00001724                          1043  ;    MOVE.B  #'M', (A2)+
00001724                          1044  ;    MOVE.B  #'O', (A2)+
00001724                          1045  ;    MOVE.B  #'V', (A2)+
00001724                          1046  ;    MOVE.B  #'E', (A2)+
00001724                          1047  ;    MOVE.B  #'M', (A2)+
00001724                          1048      
00001724                          1049  ;    ;call OP_CHECK_SIZE to append a .b/.w/.l
00001724                          1050  ;    JSR     OP_CHECK_SIZE
00001724                          1051      
00001724                          1052  ;    MOVE.L  #ea_type_movem, D1                   ;preps for EA_START and puts 6 into D1
00001724                          1053      
00001724                          1054  ;    JSR     EA_START
00001724                          1055  ;    JMP     OP_FINISH
00001724                          1056  
00001724                          1057  
00001724                          1058  OP_UNSUPPORTED_OPCODE:
00001724                          1059  ;fill out
00001724                          1060  
00001724                          1061  ;D0 HAS COMPLETE INSTRUCTION
00001724                          1062  OP_CHECK_SIZE:
00001724  4241                    1063      CLR     D1                                  ;CLEAR D1
00001726  4242                    1064      CLR     D2                                  ;clear D2
00001728  2200                    1065      MOVE.L  D0,D1                               ;D0 and D1 both have complete opcode
0000172A  0241 00F0               1066      ANDI.W  #nibble3,D1                         ;isolate nibble 3
0000172E  143C 0006               1067      MOVE.B  #right6, D2                         ;putting immediate value 6 in D2
00001732  E469                    1068      LSR.W   D2, D1                              ;bits 7,6 --> bits 1,0
00001734                          1069      
00001734                          1070       
00001734  B27C 0000               1071      CMP     #00,D1                              ;compare bits 1,0 to 00
00001738  6700 0032               1072      BEQ     OP_SIZE_BYTE                        ;if bits == 00, size byte
0000173C  B27C 0001               1073      CMP     #01,D1                              ;compare bits to 01
00001740  6700 0034               1074      BEQ     OP_SIZE_WORD                        ;if bits == 01, size word
00001744  6000 003A               1075      BRA     OP_SIZE_LONG                        ;else size long
00001748                          1076  
00001748                          1077  
00001748                          1078  OP_CHECK_SIZE_MOVEM:
00001748  4241                    1079      CLR     D1                                  ;CLEAR D1
0000174A  4242                    1080      CLR     D2                                  ;clear D2
0000174C  2200                    1081      MOVE.L  D0,D1                               ;D0 and D1 both have complete opcode
0000174E  0241 00F0               1082      ANDI.W  #nibble3,D1                         ;isolate nibble 3
00001752  143C 0006               1083      MOVE.B  #right6, D2                         ;putting immediate value 6 in D2
00001756  E469                    1084      LSR.W   D2, D1                              ;bits 7,6 --> bits 1,0
00001758                          1085      
00001758  0241 0001               1086      ANDI.W  #1,D1    
0000175C  B27C 0000               1087      CMP     #0,D1                              ;compare bits 1,0 to 00
00001760  6700 0014               1088      BEQ     OP_SIZE_WORD                        ;if bits == 00, size WORD
00001764  B27C 0001               1089      CMP     #1,D1                              ;compare bits to 01
00001768  6700 0016               1090      BEQ     OP_SIZE_LONG                       ;if bits == 01, size LONG
0000176C                          1091  
0000176C                          1092  OP_SIZE_BYTE
0000176C  14FC 002E               1093      MOVE.B  #'.', (A2)+
00001770  14FC 0042               1094      MOVE.B  #'B', (A2)+
00001774  4E75                    1095      RTS
00001776                          1096  
00001776                          1097  OP_SIZE_WORD
00001776  14FC 002E               1098      MOVE.B  #'.', (A2)+
0000177A  14FC 0057               1099      MOVE.B  #'W', (A2)+
0000177E  4E75                    1100      RTS
00001780                          1101  
00001780                          1102  
00001780                          1103  OP_SIZE_LONG
00001780  14FC 002E               1104      MOVE.B  #'.', (A2)+
00001784  14FC 004C               1105      MOVE.B  #'L', (A2)+
00001788  4E75                    1106      RTS
0000178A                          1107  
0000178A                          1108  
0000178A                          1109  OP_CHECK_SIZE_ADDA:
0000178A  4241                    1110      CLR     D1                                  ;CLEAR D1
0000178C  4242                    1111      CLR     D2                                  ;clear D2
0000178E  2200                    1112      MOVE.L  D0,D1                               ;D0 and D1 both have complete opcode
00001790  0241 0F00               1113      ANDI.W  #nibble2,D1                         ;isolate nibble 2
00001794  143C 0008               1114      MOVE.B  #right8, D2                         ;putting immediate value 8 in D2
00001798  E469                    1115      LSR.W   D2, D1                              ;
0000179A                          1116      
0000179A                          1117      ;at this point we have our single bit in bit 0
0000179A                          1118      
0000179A  0241 0001               1119      ANDI.W  #0001,D1                            ;isolate bit 0
0000179E  B27C 0000               1120      CMP     #0,D1                               ;check if bit == 0
000017A2  67D2                    1121      BEQ     OP_SIZE_WORD                        ;if yes, size = word
000017A4  60DA                    1122      BRA     OP_SIZE_LONG                        ;else, size = long
000017A6                          1123   
000017A6                          1124  
000017A6                          1125  ;******************************** ATOI ******************************************************************************************************************************
000017A6                          1126  ATOI:
000017A6  2401                    1127          MOVE.L      D1,D2                   ;loop variable (size) is in D2
000017A8  2449                    1128          MOVEA.L     A1,A2                   ;pointer to next char
000017AA  4284                    1129          CLR.L       D4
000017AC                          1130  
000017AC                          1131  ATOI_LOOP  
000017AC  4243                    1132          CLR         D3                      ;clear d3
000017AE                          1133          ;CMP.B       #0,D2
000017AE                          1134          ;BEQ         ATOI_DONE               ;DONE
000017AE  5382                    1135          SUBI.L      #1,D2                   ;subtract 1 from loop counter
000017B0  161A                    1136          MOVE.B      (A2)+,D3                 ;move current byte to D3, then increment to next
000017B2  B63C 002F               1137          CMP.B       #$2F,D3
000017B6  6F00 0060               1138          BLE         ATOI_ERROR              ;if less than 30, not a number, branch to error
000017BA  B63C 0039               1139          CMP.B       #$39,D3                 ;check byte to see if number or letter
000017BE  6F00 002A               1140          BLE         ATOI_NUMBER             ;30<x<39 --> number
000017C2  B63C 0040               1141          CMP.B       #$40,D3
000017C6  6F00 0050               1142          BLE         ATOI_ERROR
000017CA  B63C 0046               1143          CMP.B       #$46,D3
000017CE  6F00 0024               1144          BLE         ATOI_UPPERCASE_LETTER   ;less than 47, it is uppercase letter
000017D2  B63C 0060               1145          CMP.B       #$60,D3
000017D6  6F00 0040               1146          BLE         ATOI_ERROR
000017DA  B63C 0066               1147          CMP.B       #$66,D3
000017DE  6F00 001E               1148          BLE         ATOI_LOWERCASE_LETTER
000017E2  B63C 0067               1149          CMP.B       #$67,D3
000017E6  6C00 0030               1150          BGE         ATOI_ERROR
000017EA                          1151          
000017EA                          1152          ;BNE         ATOI_LOOP                    ;run loop
000017EA                          1153      
000017EA                          1154  
000017EA                          1155  ATOI_NUMBER
000017EA                          1156  ;number --> d1 = d1 - $30
000017EA  0403 0030               1157      SUBI.B          #$30, D3                    ;subtract 30 if number
000017EE                          1158      ;MOVE.B          D3,(A2)+                    ;move into A2 and post increment pointer
000017EE  4EF9 00001808           1159      JMP             ATOI_FORMAT                 ;testing
000017F4                          1160      ;JMP            ATOI_LOOP                   ;loop
000017F4                          1161  
000017F4                          1162  ATOI_UPPERCASE_LETTER
000017F4                          1163  ;letter --> d1 = d1 - $37
000017F4  0403 0037               1164      SUBI.B          #$37,D3                     ;subtract 37 if UPPER case letter
000017F8                          1165      ;MOVE.B          D3,(A2)+                    ;move into A2 and post increment pointer
000017F8  4EF9 00001808           1166      JMP             ATOI_FORMAT                 ;testing
000017FE                          1167      ;JMP            ATOI_LOOP                   ;loop
000017FE                          1168  
000017FE                          1169  ATOI_LOWERCASE_LETTER
000017FE  0403 0057               1170      SUBI.B          #$57,D3                     ;subtract 57(20 + 37)
00001802                          1171      ;MOVE.B          D3,(A2)+                    ;move into A2 and post increment pointer
00001802  4EF9 00001808           1172      JMP             ATOI_FORMAT                 ;testing
00001808                          1173      ;JMP            ATOI_LOOP                  ;loop
00001808                          1174  
00001808                          1175  
00001808                          1176  ATOI_FORMAT
00001808  D803                    1177      ADD.B           D3,D4                       ;add the byte to D4 so can add later   
0000180A  B43C 0000               1178      CMP.B           #0,D2                       
0000180E  6700 0008               1179      BEQ             ATOI_DONE                   ;check if done (loop counter D2 is at 0)
00001812  E984                    1180      ASL.L           #4,D4                       ;logical shift left to make room
00001814  4EF8 17AC               1181      JMP             ATOI_LOOP                   ;go back to loop
00001818                          1182  
00001818                          1183  ATOI_ERROR
00001818                          1184      ;come back to handle error when out of range
00001818                          1185      
00001818                          1186  
00001818                          1187  ATOI_DONE 
00001818  2284                    1188      MOVE.L         D4,(A1)                      ;at this point, move the new address in D4 to mem location                                
0000181A  4E75                    1189      RTS                                         ;used to RTS after a branch statement
0000181C                          1190  
0000181C                          1191  ;************************************* ITOA *******************************************************************************************************************
0000181C                          1192  ;A0
0000181C                          1193  ;A1
0000181C                          1194  ;A2 = buffer (this is our decoded string that will print to screen)
0000181C                          1195  ;A3
0000181C                          1196  ;A4 = current memory address for buffer
0000181C                          1197  ;A5 = starting address / current address in memory
0000181C                          1198  ;A6 = ending address
0000181C                          1199  ;A7 = SP
0000181C                          1200  
0000181C                          1201  ;D0 = counter
0000181C                          1202  ;D1 = 
0000181C                          1203  ;D2 = ?
0000181C                          1204  ;D3 = buffer size (used for loop = 64)
0000181C                          1205  ;D4 = value being converted
0000181C                          1206  ;D5 =
0000181C                          1207  ;D6 = 
0000181C                          1208  ;D7 = 
0000181C                          1209  ITOA:
0000181C  280D                    1210      MOVE.L         A5,D4                    ;D4 has data to convert to ascii
0000181E                          1211  
0000181E                          1212  ITOA_LOOP:
0000181E  BA3C 0000               1213      CMP.B           #0,D5
00001822  6700 004C               1214      BEQ             ITOA_FINISH             ;when 0, branch to finish to complete
00001826                          1215  
00001826                          1216  
00001826                          1217  
00001826                          1218  
00001826                          1219  ITOA_BYTE:
00001826                          1220  
00001826                          1221  
00001826                          1222  
00001826                          1223  ITOA_WORD:
00001826                          1224  
00001826                          1225  
00001826                          1226  
00001826                          1227  ITOA_LONG:
00001826                          1228  
00001826                          1229  
00001826                          1230  
00001826                          1231  ITOA_ADDRESS:
00001826  4284                    1232      CLR.L       D4                          ;D4 = 0000 0000
00001828  280D                    1233      MOVE.L      A5,D4                       ;our address is now in D4 and ready to deconstruct
0000182A  103C 0008               1234      MOVE.B      #8,D0                       ;counter
0000182E  4EF9 00001834           1235      JMP         ITOA_ADDRESS_LOOP
00001834                          1236  ITOA_ADDRESS_LOOP:
00001834  B03C 0000               1237      CMP.B       #0,D0                       ;check if done
00001838  6700 0036               1238      BEQ         ITOA_FINISH                 ;if at 0, branch to ITOA_FINISH
0000183C  E99C                    1239      ROL.L       #4,D4                       ;rotate left 4 bits, to get MSB to beginning 
0000183E  1204                    1240      MOVE.B      D4,D1                       ;store in D1 (this will be whole byte, we want half)
00001840  0241 000F               1241      ANDI.W      #$000F,D1                   ;character is now isolated
00001844                          1242      
00001844  4EB9 00001850           1243      JSR         ITOA_HEX2ASCII              ;JSR to convert
0000184A  5340                    1244      SUBI        #1,D0                       ;subtract 1 from counter
0000184C  4EF8 1834               1245      JMP         ITOA_ADDRESS_LOOP           ;loop again!
00001850                          1246  
00001850                          1247  ITOA_HEX2ASCII:
00001850  B23C 000A               1248      CMP.B       #$A,D1                      ;compare byte in D1 to hex value A
00001854  6C00 0012               1249      BGE         ITOA_LETTER                 ;if greater than/equal A, it is letter
00001858  B23C 000A               1250      CMP.B       #$A,D1                      ;compare byte in D1 to hex value A
0000185C  6D00 0002               1251      BLT         ITOA_NUMBER                 ;if less than, it is number
00001860                          1252  
00001860                          1253  ITOA_NUMBER:
00001860  0601 0030               1254      ADDI.B      #$30,D1                     ;add $30 to D1 to convert
00001864  14C1                    1255      MOVE.B      D1,(A2)+                    ;add to buffer and increment to next position
00001866  4E75                    1256      RTS
00001868                          1257  
00001868                          1258  ITOA_LETTER:
00001868  0601 0037               1259      ADDI.B      #$37,D1                     ;add 37 to D1 to convert
0000186C  14C1                    1260      MOVE.B      D1,(A2)+                    ;add to buffer and increment to next position
0000186E  4E75                    1261      RTS
00001870                          1262  
00001870                          1263  ITOA_FINISH:
00001870  4E75                    1264      RTS
00001872                          1265  
00001872                          1266  
00001872                          1267  ;************************************ Validate Addresses ******************************************
00001872                          1268  
00001872                          1269  VALIDATE_BEGINNING:
00001872                          1270      
00001872                          1271  
00001872                          1272  
00001872                          1273  
00001872                          1274  ;******************************** Message Error Handling ***************************************************************************************************************** 
00001872                          1275  STARTA_ERROR_LESS_THAN_ZERO:
00001872  103C 000E               1276      MOVE.B  #14,D0
00001876  43F9 00001FEC           1277      LEA     error_message_1,A1      ;load the get_end_address message into A1
0000187C  4E4F                    1278      TRAP    #15    
0000187E  4EF8 1012               1279      JMP     GET_STARTING_ADDRESS
00001882                          1280  
00001882                          1281  STARTA_ERROR_NOT_EVEN:
00001882  103C 000E               1282      MOVE.B  #14,D0
00001886  43F9 00002016           1283      LEA     error_message_2,A1      ;load error_message_2
0000188C  4E4F                    1284      TRAP    #15    
0000188E  4EF8 1012               1285      JMP     GET_STARTING_ADDRESS
00001892                          1286  
00001892                          1287  ENDA_ERROR_NOT_EVEN:
00001892  103C 000E               1288      MOVE.B  #14,D0
00001896  43F9 00002036           1289      LEA     error_message_3,A1      ;load error_message_3
0000189C  4E4F                    1290      TRAP    #15
0000189E  4EF8 104A               1291      JMP     GET_ENDING_ADDRESS
000018A2                          1292  
000018A2                          1293  ENDA_ERROR_LARGE:
000018A2  103C 000E               1294      MOVE.B  #14,D0
000018A6  43F9 00002056           1295      LEA     error_message_4,A1      ;load error_message_4
000018AC  4E4F                    1296      TRAP    #15
000018AE  4EF8 104A               1297      JMP     GET_ENDING_ADDRESS
000018B2                          1298      
000018B2                          1299  ENDA_ERROR_LESS_THAN_STARTA:
000018B2  103C 000E               1300      MOVE.B  #14,D0
000018B6  43F9 00002085           1301      LEA     error_message_5,A1      ;load error_message_5
000018BC  4E4F                    1302      TRAP    #15
000018BE  4EF8 104A               1303      JMP     GET_ENDING_ADDRESS
000018C2                          1304  
000018C2                          1305  ;****************************************** EA Stuff ********************************************************************************************************************* 
000018C2                          1306  
000018C2                          1307  EA_START:
000018C2  41F9 000018D0           1308      LEA         EA_TYPE_TABLE, A0
000018C8                          1309      
000018C8  C2FC 0006               1310      MULU        #6,D1               ;computes opcode table jump displacement
000018CC  4EF0 1000               1311      JMP         0(A0,D1)            ;jump to correct table input
000018D0                          1312  
000018D0                          1313  
000018D0                          1314  EA_TYPE_TABLE:
000018D0  4EF9 00001920           1315      JMP         EA_IMMEDIATE        ;0  DONE
000018D6  4EF9 00001962           1316      JMP         EA_MOVE             ;1  DONE
000018DC  4EF9 000019A8           1317      JMP         EA_MOVEA            ;2  DONE
000018E2  4EF9 000019EE           1318      JMP         EA_LEA              ;3  DONE
000018E8  4EF9 00001A2E           1319      JMP         EA_DESTONLY         ;4  JMP, CLR
000018EE  4EF9 00001A2E           1320      JMP         EA_EXT              ;5
000018F4  4EF9 00001A2E           1321      JMP         EA_MOVEM            ;6
000018FA  4EF9 00001C14           1322      JMP         EA_TRAP             ;7
00001900  4EF9 00001C14           1323      JMP         EA_QUICK            ;8  DONE
00001906  4EF9 00001C90           1324      JMP         EA_BRANCH           ;9  DONE
0000190C  4EF9 00001CD8           1325      JMP         EA_MATH             ;10 DONE    DIVU, DIVS, SUB, CMP, MULU, ADD, ADDA
00001912  4EF9 00001D50           1326      JMP         EA_ROTATION         ;11         ASL, ASR, ???  
00001918  4EF9 0000191E           1327      JMP         EA_FINISH           ;
0000191E                          1328  
0000191E                          1329  EA_FINISH:
0000191E  4E75                    1330      RTS ; TAKE OUT LATER
00001920                          1331      
00001920                          1332  
00001920                          1333  
00001920                          1334  ;********************************************  EA_TYPE  ****************************************************   
00001920                          1335  
00001920                          1336  EA_IMMEDIATE:                               ;value 0
00001920  14FC 0009               1337      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001924  14FC 0023               1338      MOVE.B  #'#',(A2)+                      ;add a # to buffer
00001928  14FC 0024               1339      MOVE.B  #'$',(A2)+                      ;add a $ to buffer
0000192C                          1340      
0000192C                          1341      ;check size which is bits 6,7 and store in D6
0000192C                          1342      ;get immediate value from memory based off size and store in D7
0000192C  4EB9 00001E7C           1343      JSR     EA_CHECK_SIZE
00001932                          1344      
00001932                          1345      ;at this point our size is in D6 and data is in D7 and memory has been advanced
00001932                          1346      ;convert immediate data to ascii and put on buffer
00001932  4EB9 00001EA6           1347      JSR     EA_ITOA_IMMEDIATE
00001938                          1348      
00001938  41F9 00001DA0           1349      LEA     EA_MODE_TABLE,A0                ;load table
0000193E  14FC 002C               1350      MOVE.B  #',',(A2)+                      ;add a # to buffer
00001942  14FC 0009               1351      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001946                          1352      
00001946                          1353      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
00001946                          1354      
00001946                          1355      ;isolate source mode - bits 3,4,5 and store in D4
00001946  2800                    1356      MOVE.L  D0,D4
00001948  E64C                    1357      LSR.W   #3,D4
0000194A  0244 0007               1358      ANDI.W  #$7,D4
0000194E  C8FC 0006               1359      MULU    #6,D4
00001952                          1360      
00001952                          1361      ;isolate source register - bits 0,1,2 and store in D5
00001952  2A00                    1362      MOVE.L  D0,D5
00001954  0245 0007               1363      ANDI.W  #$7,D5
00001958                          1364  
00001958  4EB9 00001D9C           1365      JSR     EA_JMP_HELPER
0000195E  4EF8 191E               1366      JMP     EA_FINISH
00001962                          1367  
00001962                          1368  ;D4 = mode      --> source / destination
00001962                          1369  ;D5 = register  --> source / destination   
00001962                          1370  EA_MOVE:
00001962  14FC 0009               1371      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001966  41F9 00001DA0           1372      LEA     EA_MODE_TABLE,A0                ;load table
0000196C                          1373      
0000196C                          1374      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
0000196C                          1375      
0000196C                          1376      ;isolate source mode
0000196C  2800                    1377      MOVE.L  D0,D4
0000196E  E64C                    1378      LSR.W   #3,D4
00001970  0244 0007               1379      ANDI.W  #$7,D4
00001974  C8FC 0006               1380      MULU    #6,D4
00001978                          1381          
00001978                          1382      ;isolate source register
00001978  2A00                    1383      MOVE.L  D0,D5
0000197A  0245 0007               1384      ANDI.W  #$7,D5
0000197E                          1385      
0000197E  4EB9 00001D9C           1386      JSR    EA_JMP_HELPER
00001984  14FC 002C               1387      MOVE.B  #',',(A2)+                  ;add ',' to buffer  
00001988                          1388      
00001988                          1389      ;isolate destination mode
00001988  2800                    1390      MOVE.L  D0,D4
0000198A  EC4C                    1391      LSR.W   #6,D4
0000198C  0244 0007               1392      ANDI.W  #$7,D4
00001990  C8FC 0006               1393      MULU    #6,D4
00001994                          1394      
00001994                          1395      ;isolate destination register 
00001994  2A00                    1396      MOVE.L  D0,D5
00001996  E84D                    1397      LSR.W   #4,D5
00001998  EA4D                    1398      LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
0000199A  0245 0007               1399      ANDI.W  #$7,D5   
0000199E  4EB9 00001D9C           1400      JSR     EA_JMP_HELPER
000019A4                          1401  
000019A4  4EF8 191E               1402      JMP     EA_FINISH
000019A8                          1403      
000019A8                          1404  
000019A8                          1405  EA_MOVEA:
000019A8  14FC 0009               1406      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
000019AC  41F9 00001DA0           1407      LEA     EA_MODE_TABLE,A0                ;load table
000019B2                          1408  
000019B2                          1409      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
000019B2                          1410      
000019B2                          1411      ;isolate source mode
000019B2  2800                    1412      MOVE.L  D0,D4
000019B4  E64C                    1413      LSR.W   #3,D4
000019B6  0244 0007               1414      ANDI.W  #$7,D4
000019BA  C8FC 0006               1415      MULU    #6,D4
000019BE                          1416          
000019BE                          1417      ;isolate source register
000019BE  2A00                    1418      MOVE.L  D0,D5
000019C0  0245 0007               1419      ANDI.W  #$7,D5
000019C4                          1420      
000019C4  4EB9 00001D9C           1421      JSR    EA_JMP_HELPER
000019CA  14FC 002C               1422      MOVE.B  #',',(A2)+                  ;add ',' to buffer
000019CE                          1423      
000019CE                          1424      ;isolate destination mode --> SHOULD ALWAYS BE 001 AND GO TO ADDRESS REGISTER
000019CE  2800                    1425      MOVE.L  D0,D4
000019D0  EC4C                    1426      LSR.W   #6,D4
000019D2  0244 0007               1427      ANDI.W  #$7,D4
000019D6  C8FC 0006               1428      MULU    #6,D4
000019DA                          1429      
000019DA                          1430      ;isolate destination register 
000019DA  2A00                    1431      MOVE.L  D0,D5
000019DC  E84D                    1432      LSR.W   #4,D5
000019DE  EA4D                    1433      LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
000019E0  0245 0007               1434      ANDI.W  #$7,D5   
000019E4  4EB9 00001D9C           1435      JSR     EA_JMP_HELPER
000019EA                          1436  
000019EA  4EF8 191E               1437      JMP     EA_FINISH
000019EE                          1438  
000019EE                          1439  EA_LEA:
000019EE  14FC 0009               1440      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
000019F2  41F9 00001DA0           1441      LEA     EA_MODE_TABLE,A0                ;load table
000019F8                          1442      
000019F8                          1443      ;source mode are bits 3,4,5   |         ;source register are bits 0,1,2
000019F8                          1444      
000019F8                          1445      ;isolate source mode
000019F8  2800                    1446      MOVE.L  D0,D4
000019FA  E64C                    1447      LSR.W   #3,D4
000019FC  0244 0007               1448      ANDI.W  #$7,D4
00001A00  C8FC 0006               1449      MULU    #6,D4
00001A04                          1450          
00001A04                          1451      ;isolate source register
00001A04  2A00                    1452      MOVE.L  D0,D5
00001A06  0245 0007               1453      ANDI.W  #$7,D5
00001A0A                          1454      
00001A0A  4EB9 00001D9C           1455      JSR    EA_JMP_HELPER
00001A10  14FC 002C               1456      MOVE.B  #',',(A2)+                  ;add ',' to buffer
00001A14                          1457      
00001A14                          1458      ;destination always An
00001A14                          1459      ;MOVE.B  #'A',(A2)+                  ;add 'A' to buffer
00001A14                          1460      
00001A14                          1461      ;isolate destination register 
00001A14                          1462      ;MOVE.L  D0,D5
00001A14                          1463      ;LSR.W   #4,D5
00001A14                          1464      ;LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
00001A14                          1465      ;ANDI.W  #$7,D5
00001A14                          1466  
00001A14                          1467      ;isolate destination mode --> SHOULD ALWAYS BE 001 AND GO TO ADDRESS REGISTER
00001A14  7801                    1468      MOVE.L  #1,D4
00001A16  C8FC 0006               1469      MULU    #6,D4
00001A1A                          1470      
00001A1A                          1471      ;isolate destination register 
00001A1A  2A00                    1472      MOVE.L  D0,D5
00001A1C  E84D                    1473      LSR.W   #4,D5
00001A1E  EA4D                    1474      LSR.W   #5,D5                       ;HAVE TO BREAK UP SHIFT TO STAY UNDER 8????
00001A20  0245 0007               1475      ANDI.W  #$7,D5   
00001A24  4EB9 00001D9C           1476      JSR     EA_JMP_HELPER
00001A2A                          1477  
00001A2A  4EF8 191E               1478      JMP     EA_FINISH
00001A2E                          1479  
00001A2E                          1480  EA_DESTONLY:        ;JMP, CLR
00001A2E                          1481  
00001A2E                          1482  
00001A2E                          1483  
00001A2E                          1484  
00001A2E                          1485  
00001A2E                          1486  EA_EXT:
00001A2E                          1487  
00001A2E                          1488  
00001A2E                          1489  
00001A2E                          1490  
00001A2E                          1491  
00001A2E                          1492  EA_MOVEM:
00001A2E  14FC 0009               1493      MOVE.B  #$09, (A2)+                     ;adds a ' ' to buffer
00001A32  41F9 00001DA0           1494      LEA     EA_MODE_TABLE,A0                ;load table
00001A38                          1495      
00001A38  2200                    1496      MOVE.L  D0,D1                           ;
00001A3A  341D                    1497      MOVE.W  (A5)+,D2                        ;come back and verify D2 is free!!!!!
00001A3C                          1498      
00001A3C                          1499      ;D1 = 4890 | D2 = 0080 (source)
00001A3C                          1500      
00001A3C                          1501      ;if direction (bit 10) == 0, destination is in opcode, source is in the second operand
00001A3C                          1502      ;if direction (bit 10) == 1, the source is in the opcode, destination is in the operand
00001A3C                          1503      
00001A3C                          1504      ;check direction (bit 10)
00001A3C  0241 0F00               1505      ANDI.W  #nibble2,D1
00001A40  EA49                    1506      LSR.W   #5,D1
00001A42  EA49                    1507      LSR.W   #5,D1                           ;total of 10 shifts
00001A44  0241 0001               1508      ANDI.W  #1,D1
00001A48  B23C 0000               1509      CMP.B   #0,D1
00001A4C  6700 000A               1510      BEQ     EA_MOVEM_REG_TO_MEM
00001A50  B23C 0001               1511      CMP.B   #1,D1
00001A54  6700 00EC               1512      BEQ     EA_MOVEM_MEM_TO_REG
00001A58                          1513      
00001A58                          1514      
00001A58                          1515  ;MOVEM.W    D/A2,(A7)    
00001A58                          1516  EA_MOVEM_REG_TO_MEM:                        ;bit 10 == 0
00001A58                          1517      ;check if data register or address register
00001A58  4246                    1518      CLR     D6
00001A5A  3C02                    1519      MOVE.W  D2,D6
00001A5C  0246 FF00               1520      ANDI.W  #$FF00,D6                       ;isolate nibble 1 and 2
00001A60  BC7C 0000               1521      CMP.W   #0,D6                           ;check if 0
00001A64  6700 0006               1522      BEQ     EA_MOVEM_DATAREG_TO_MEM        ;if 0, source is data register
00001A68  6000 0088               1523      BRA     EA_MOVEM_ADDRREG_TO_MEM        ;else it is address register
00001A6C                          1524  
00001A6C                          1525  
00001A6C                          1526  EA_MOVEM_DATAREG_TO_MEM:    
00001A6C  2C02                    1527      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001A6E  4247                    1528      CLR     D7
00001A70                          1529      
00001A70  1E3C 0000               1530      MOVE.B  #0,D7
00001A74  4245                    1531      CLR D5
00001A76  4243                    1532      CLR D3
00001A78                          1533      
00001A78  14FC 0044               1534      MOVE.B  #'D',(A2)+                      ;add 'D' to buffer
00001A7C  6100 0140               1535      BSR     MOVEM_LOOP                      ;enter loop to get number
00001A80                          1536      
00001A80                          1537      
00001A80                          1538      ;convert d3 to ascii and add to buffer
00001A80  0603 0030               1539      ADDI.B  #$30,D3                         ;convert to ASCII
00001A84  14C3                    1540      MOVE.B  D3,(A2)+                        ;put on buffer
00001A86                          1541      
00001A86                          1542      
00001A86                          1543      ;check d5 and handle
00001A86  0605 0030               1544      ADDI.B  #$30,D5
00001A8A                          1545      
00001A8A  4241                    1546      CLR     D1
00001A8C  323C 0000               1547      MOVE.W  #0,D1                           ;FLAG TO INDICATE D
00001A90                          1548      
00001A90  4EB9 00001AC4           1549      JSR     MOVEM_CHECK_MULTIPLE
00001A96                          1550      
00001A96  14FC 002C               1551      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001A9A                          1552  
00001A9A  41F9 00001DA0           1553      LEA     EA_MODE_TABLE,A0                ;load table
00001AA0                          1554      
00001AA0                          1555      ;isolate source mode
00001AA0  2800                    1556      MOVE.L  D0,D4
00001AA2  E64C                    1557      LSR.W   #3,D4   
00001AA4  0244 0007               1558      ANDI.W  #$7,D4
00001AA8                          1559      
00001AA8                          1560      ;check for mode 111 -> immediate data
00001AA8  B87C 0007               1561      CMP.W   #$7,D4
00001AAC                          1562      ;if immediate data, leave and get immediate data rather than another register
00001AAC  6700 0134               1563      BEQ     EA_MOVEM_IMMEDIATE_DESTINATION     
00001AB0                          1564      
00001AB0  C8FC 0006               1565      MULU    #6,D4
00001AB4                          1566       
00001AB4                          1567      ;isolate source register
00001AB4  2A00                    1568      MOVE.L  D0,D5
00001AB6  0245 0007               1569      ANDI.W  #$7,D5
00001ABA                          1570      
00001ABA  4EB9 00001D9C           1571      JSR    EA_JMP_HELPER
00001AC0  4EF8 191E               1572      JMP     EA_FINISH
00001AC4                          1573  
00001AC4                          1574  
00001AC4                          1575      
00001AC4                          1576  MOVEM_CHECK_MULTIPLE:
00001AC4  BA43                    1577      CMP     D3,D5
00001AC6  6600 0004               1578      BNE     MOVEM_MULTIPLE
00001ACA  4E75                    1579      RTS
00001ACC                          1580      
00001ACC                          1581  MOVEM_MULTIPLE:
00001ACC  14FC 002D               1582      MOVE.B  #'-',(A2)+                      ;add '-' to buffer
00001AD0                          1583      ;CHECK D1 FOR A OR D
00001AD0  B27C 0000               1584      CMP.W   #0,D1                           ;check if 0 --> D
00001AD4  6700 000C               1585      BEQ     MOVEM_MULTIPLE_D
00001AD8  B27C 0001               1586      CMP.W   #1,D1
00001ADC  6700 000C               1587      BEQ     MOVEM_MULTIPLE_A
00001AE0                          1588  
00001AE0  4E75                    1589      RTS
00001AE2                          1590  
00001AE2                          1591  MOVEM_MULTIPLE_D:
00001AE2  14FC 0044               1592      MOVE.B  #'D',(A2)+                      ;add 'D' to buffer
00001AE6  14C5                    1593      MOVE.B  D5,(A2)+                        ;put on buffer
00001AE8  4E75                    1594      RTS
00001AEA                          1595  
00001AEA                          1596  MOVEM_MULTIPLE_A:
00001AEA  14FC 0041               1597      MOVE.B  #'A',(A2)+                      ;add 'D' to buffer
00001AEE  14C5                    1598      MOVE.B  D5,(A2)+                        ;put on buffer
00001AF0  4E75                    1599      RTS
00001AF2                          1600  
00001AF2                          1601  EA_MOVEM_ADDRREG_TO_MEM:
00001AF2  2C02                    1602      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001AF4  4247                    1603      CLR     D7
00001AF6                          1604      
00001AF6  1E3C 0000               1605      MOVE.B  #0,D7
00001AFA  4245                    1606      CLR D5
00001AFC  4243                    1607      CLR D3
00001AFE                          1608      
00001AFE  14FC 0041               1609      MOVE.B  #'A',(A2)+                      ;add 'A' to buffer
00001B02  E04E                    1610      LSR.W   #8,D6                           ;shift 8 times
00001B04  6100 00B8               1611      BSR     MOVEM_LOOP                      ;enter loop to get number
00001B08                          1612      
00001B08                          1613      ;convert d3 to ascii and add to buffer
00001B08  0603 0030               1614      ADDI.B  #$30,D3                         ;convert to ASCII
00001B0C  14C3                    1615      MOVE.B  D3,(A2)+                        ;put on buffer
00001B0E                          1616      
00001B0E  0605 0030               1617      ADDI.B  #$30,D5
00001B12                          1618      
00001B12  4241                    1619      CLR     D1
00001B14  323C 0001               1620      MOVE.W  #1,D1                           ;FLAG TO INDICATE A
00001B18                          1621      
00001B18  4EB8 1AC4               1622      JSR MOVEM_CHECK_MULTIPLE
00001B1C                          1623      
00001B1C  14FC 002C               1624      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001B20                          1625      ;MOVEM.s D7,
00001B20                          1626      
00001B20  41F9 00001DA0           1627      LEA     EA_MODE_TABLE,A0                ;load table
00001B26                          1628      
00001B26                          1629      ;isolate source mode
00001B26  2800                    1630      MOVE.L  D0,D4
00001B28  E64C                    1631      LSR.W   #3,D4
00001B2A  0244 0007               1632      ANDI.W  #$7,D4
00001B2E  C8FC 0006               1633      MULU    #6,D4
00001B32                          1634          
00001B32                          1635      ;isolate source register
00001B32  2A00                    1636      MOVE.L  D0,D5
00001B34  0245 0007               1637      ANDI.W  #$7,D5
00001B38                          1638      
00001B38  4EB9 00001D9C           1639      JSR    EA_JMP_HELPER
00001B3E  4EF8 191E               1640      JMP     EA_FINISH
00001B42                          1641  
00001B42                          1642  ;MOVEM.W (A7),D/A2
00001B42                          1643  EA_MOVEM_MEM_TO_REG:                        ;bit 10 == 1
00001B42  41F9 00001DA0           1644      LEA     EA_MODE_TABLE,A0                ;load table
00001B48                          1645      
00001B48                          1646      ;isolate source mode
00001B48  2800                    1647      MOVE.L  D0,D4
00001B4A  E64C                    1648      LSR.W   #3,D4
00001B4C  0244 0007               1649      ANDI.W  #$7,D4
00001B50                          1650      
00001B50                          1651      
00001B50                          1652      ;check for mode 111 -> immediate data
00001B50  B87C 0007               1653      CMP.W   #$7,D4
00001B54                          1654      ;if immediate data, leave and get immediate data rather than another register
00001B54  6700 009C               1655      BEQ     EA_MOVEM_IMMEDIATE_SOURCE
00001B58                          1656  
00001B58  C8FC 0006               1657      MULU    #6,D4
00001B5C                          1658          
00001B5C                          1659      ;isolate source register
00001B5C  2A00                    1660      MOVE.L  D0,D5
00001B5E  0245 0007               1661      ANDI.W  #$7,D5
00001B62                          1662  
00001B62  4EB9 00001D9C           1663      JSR    EA_JMP_HELPER
00001B68  14FC 002C               1664      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001B6C                          1665      
00001B6C                          1666      ;our operand is in D2
00001B6C  4246                    1667      CLR     D6
00001B6E  3C02                    1668      MOVE.W  D2,D6
00001B70  0246 FF00               1669      ANDI.W  #$FF00,D6                       ;isolate nibble 1 and 2
00001B74  BC7C 0000               1670      CMP.W   #0,D6                           ;check if 0
00001B78  6700 0006               1671      BEQ     EA_MOVEM_MEM_TO_DATAREG        ;if 0, source is data register
00001B7C  6000 0020               1672      BRA     EA_MOVEM_MEM_TO_ADDRREG        ;else it is address register
00001B80                          1673          
00001B80                          1674  EA_MOVEM_MEM_TO_DATAREG: 
00001B80  2C02                    1675      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001B82  4247                    1676      CLR     D7
00001B84                          1677      
00001B84  1E3C 0000               1678      MOVE.B  #0,D7
00001B88  4245                    1679      CLR D5
00001B8A  4243                    1680      CLR D3
00001B8C                          1681      
00001B8C  14FC 0044               1682      MOVE.B  #'D',(A2)+                      ;add 'D' to buffer
00001B90  6100 002C               1683      BSR     MOVEM_LOOP                      ;enter loop to get number
00001B94                          1684      
00001B94                          1685      ;convert d7 to ascii and add to buffer
00001B94  0607 0030               1686      ADDI.B  #$30,D7                         ;convert to ASCII
00001B98  14C7                    1687      MOVE.B  D7,(A2)+                        ;put on buffer
00001B9A                          1688  
00001B9A  4EF8 191E               1689      JMP     EA_FINISH
00001B9E                          1690     
00001B9E                          1691  EA_MOVEM_MEM_TO_ADDRREG:
00001B9E  2C02                    1692      MOVE.L  D2,D6                           ;replenish D6 with stuff
00001BA0  4247                    1693      CLR     D7
00001BA2                          1694      
00001BA2                          1695      
00001BA2  1E3C 0000               1696      MOVE.B  #0,D7
00001BA6  4245                    1697      CLR D5
00001BA8  4243                    1698      CLR D3
00001BAA                          1699      
00001BAA                          1700      
00001BAA  14FC 0041               1701      MOVE.B  #'A',(A2)+                      ;add 'A' to buffer
00001BAE  E04E                    1702      LSR.W   #8,D6                           ;shift 8 times
00001BB0  6100 000C               1703      BSR     MOVEM_LOOP                      ;enter loop to get number
00001BB4                          1704      
00001BB4                          1705      ;convert d7 to ascii and add to buffer
00001BB4  0607 0030               1706      ADDI.B  #$30,D7                         ;convert to ASCII
00001BB8  14C7                    1707      MOVE.B  D7,(A2)+                        ;put on buffer
00001BBA                          1708  
00001BBA  4EF8 191E               1709      JMP     EA_FINISH
00001BBE                          1710  
00001BBE                          1711  MOVEM_LOOP  
00001BBE                          1712      ;D1 = min_set_flag (0 = not set, 1 = set) | D3 = MIN | D5 = MAX | D7 = COUNTER (STARTS AT 0)
00001BBE                          1713      ;D6 = OUR SECOND OPERAND
00001BBE                          1714       
00001BBE  E24E                    1715      LSR.W   #1,D6
00001BC0  6500 0004               1716      BCS     MOVEM_CARRY
00001BC4                          1717      
00001BC4  4E75                    1718      RTS 
00001BC6                          1719  
00001BC6                          1720  MOVEM_CARRY:
00001BC6  B27C 0000               1721      CMP         #0,D1
00001BCA  6700 000A               1722      BEQ         MOVEM_SET_MIN
00001BCE                          1723      
00001BCE  3A07                    1724      MOVE.W      D7,D5
00001BD0  5247                    1725      ADDI.W      #1,D7  
00001BD2  4EF8 1BBE               1726      JMP         MOVEM_LOOP
00001BD6                          1727  
00001BD6                          1728  MOVEM_SET_MIN:
00001BD6  3607                    1729      MOVE.W      D7,D3           ;set min
00001BD8  323C 0001               1730      MOVE.W      #1,D1           ;set flag
00001BDC  5247                    1731      ADDI.W      #1,D7  
00001BDE  4EF8 1BBE               1732      JMP         MOVEM_LOOP
00001BE2                          1733  
00001BE2                          1734  
00001BE2                          1735  
00001BE2                          1736  EA_MOVEM_IMMEDIATE_DESTINATION:
00001BE2                          1737      ;GET NEXT WORD VALUE AT A5 AND INCREMENT
00001BE2  3E15                    1738      MOVE.W  (A5),D7                        ;immediate value is in D7 now
00001BE4  14FC 0024               1739      MOVE.B  #'$',(A2)+                      ;add '$' to buffer
00001BE8                          1740      
00001BE8                          1741      ;convert to ascii and put on buffer
00001BE8  4EB9 00001ECA           1742      JSR     EA_ITOA_WORD
00001BEE                          1743  
00001BEE  4EF8 191E               1744      JMP     EA_FINISH
00001BF2                          1745  
00001BF2                          1746  EA_MOVEM_IMMEDIATE_SOURCE:
00001BF2                          1747      ;GET NEXT WORD VALUE AT A5 AND INCREMENT
00001BF2  3E15                    1748      MOVE.W  (A5),D7                        ;immediate value is in D7 now
00001BF4  14FC 0024               1749      MOVE.B  #'$',(A2)+                      ;add '$' to buffer
00001BF8                          1750      
00001BF8                          1751      ;convert to ascii and put on buffer
00001BF8  4EB9 00001ECA           1752      JSR     EA_ITOA_WORD
00001BFE                          1753  
00001BFE                          1754      ;TRY THIS
00001BFE  14FC 002C               1755      MOVE.B  #',',(A2)+                      ;add ',' to buffer
00001C02                          1756      
00001C02                          1757      ;our operand is in D2
00001C02  4246                    1758      CLR     D6
00001C04  3C02                    1759      MOVE.W  D2,D6
00001C06  0246 FF00               1760      ANDI.W  #$FF00,D6                       ;isolate nibble 1 and 2
00001C0A  BC7C 0000               1761      CMP.W   #0,D6                           ;check if 0
00001C0E  6700 FF70               1762      BEQ     EA_MOVEM_MEM_TO_DATAREG        ;if 0, source is data register
00001C12  608A                    1763      BRA     EA_MOVEM_MEM_TO_ADDRREG        ;else it is address register
00001C14                          1764  
00001C14                          1765  
00001C14                          1766  
00001C14                          1767  
00001C14                          1768  
00001C14                          1769  
00001C14                          1770  
00001C14                          1771  EA_TRAP:
00001C14                          1772  
00001C14                          1773  
00001C14                          1774  
00001C14                          1775  
00001C14                          1776  
00001C14                          1777  EA_QUICK:
00001C14                          1778      ;FIGURE WHAT KIND? (ADDQ,SUBQ,MOVEQ)
00001C14                          1779      ;ADDQ/SUBQ  -->  opcode = 0101 (stored in D0)
00001C14                          1780      ;MOVEQ      -->  opcode = 0111 (stored in D0)
00001C14  14FC 0009               1781      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001C18  14FC 0023               1782      MOVE.B  #'#',(A2)+                  ;add a # to buffer
00001C1C  14FC 0024               1783      MOVE.B  #'$',(A2)+                  ;add a $ to buffer
00001C20                          1784      
00001C20  2200                    1785      MOVE.L  D0,D1                       ;should move into D1
00001C22                          1786      
00001C22                          1787      ;check for MOVEQ
00001C22  EC49                    1788      LSR.W   #right6,D1
00001C24  EC49                    1789      LSR.W   #right6,D1  
00001C26  B27C 0007               1790      CMP.W   #$7,D1
00001C2A  6700 003A               1791      BEQ     EA_QUICK_MOVEQ
00001C2E                          1792      
00001C2E  4241                    1793      CLR     D1                          ;else not MOVEQ, reset D1 and continue with ADDQ / SUBQ
00001C30  2200                    1794      MOVE.L  D0,D1
00001C32  0241 0E00               1795      ANDI.W  #dest_reg,D1                ;isolate destination register(11,10,9)
00001C36  E049                    1796      LSR.W   #right8,D1                  ;shift 8 times
00001C38  E249                    1797      LSR.W   #right1,D1                  ;shift 1 time for total of 9 times
00001C3A                          1798      
00001C3A                          1799      ;at this point we have our number, so convert to ASCII and put on buffer
00001C3A  0601 0030               1800      ADDI.B  #$30,D1                     ;convert to ASCII
00001C3E  14C1                    1801      MOVE.B  D1,(A2)+                    ;put on buffer
00001C40                          1802      
00001C40                          1803      
00001C40                          1804      ;ready for destination address
00001C40  14FC 002C               1805      MOVE.B  #',',(A2)+                  ;add ',' to buffer  
00001C44  41F9 00001DA0           1806      LEA     EA_MODE_TABLE,A0            ;load table
00001C4A                          1807      
00001C4A                          1808      
00001C4A                          1809      ;isolate source mode
00001C4A  2800                    1810      MOVE.L  D0,D4
00001C4C  E64C                    1811      LSR.W   #3,D4
00001C4E  0244 0007               1812      ANDI.W  #$7,D4
00001C52  C8FC 0006               1813      MULU    #6,D4
00001C56                          1814          
00001C56                          1815      ;isolate source register
00001C56  2A00                    1816      MOVE.L  D0,D5
00001C58  0245 0007               1817      ANDI.W  #$7,D5
00001C5C                          1818      
00001C5C  4EB9 00001D9C           1819      JSR    EA_JMP_HELPER
00001C62                          1820      
00001C62  4EF8 191E               1821      JMP     EA_FINISH
00001C66                          1822      
00001C66                          1823      ;LSR.W       #right12,D1         ;shift D1 by 12 bits, leaving just 4 bits      --> gives shift count error
00001C66                          1824      ;CMP.W       #$5,D1
00001C66                          1825      ;BEQ         EA_ADDQ_SUBQ
00001C66                          1826      
00001C66                          1827  EA_QUICK_MOVEQ:
00001C66  2200                    1828      MOVE.L  D0,D1
00001C68  0241 00FF               1829      ANDI.W  #$00FF,D1               ;isolate bits 7-0
00001C6C                          1830      
00001C6C                          1831      ;our bits are isolated in D1, move to D7 for ITOA function
00001C6C  2E01                    1832      MOVE.L  D1,D7
00001C6E  4EB9 00001F08           1833      JSR     EA_ITOA_BYTE_CONVERT
00001C74                          1834      
00001C74  14FC 002C               1835      MOVE.B  #',',(A2)+                  ;add ',' to buffer
00001C78  14FC 0044               1836      MOVE.B  #'D',(A2)+                  ;add ',' to buffer
00001C7C  2200                    1837      MOVE.L  D0,D1
00001C7E  0241 0F00               1838      ANDI.W  #nibble2,D1
00001C82  E049                    1839      LSR.W   #8,D1
00001C84  E249                    1840      LSR.W   #1,D1
00001C86                          1841      
00001C86                          1842      ;at this point we have our number, so convert to ASCII and put on buffer
00001C86  0601 0030               1843      ADDI.B  #$30,D1                     ;convert to ASCII
00001C8A  14C1                    1844      MOVE.B  D1,(A2)+                    ;put on buffer
00001C8C                          1845  
00001C8C  4EF8 191E               1846      JMP     EA_FINISH
00001C90                          1847  
00001C90                          1848  EA_BRANCH:
00001C90                          1849      ;PROGRAM COUNTER @ A5
00001C90                          1850      ;BRA or BSR
00001C90                          1851      ;displacement bits are 7-0 
00001C90  2200                    1852      MOVE.L  D0,D1
00001C92  0241 00FF               1853      ANDI.W  #$00FF,D1               ;isolate bits 7-0
00001C96                          1854      ;PERFORM CHECKS 0000 0000 = WORD VALUE, 1111 1111 = LONG VALUE
00001C96                          1855      
00001C96  B23C 0000               1856      CMP.B   #$00,D1
00001C9A  6700 0006               1857      BEQ     EA_BRANCH_16
00001C9E  6000 001A               1858      BRA     EA_BRANCH_32
00001CA2                          1859  
00001CA2                          1860  
00001CA2                          1861  
00001CA2                          1862  EA_BRANCH_16:
00001CA2  3215                    1863      MOVE.W  (A5),D1                    ;CHECK WHERE POINTER IS WHEN HITS HERE
00001CA4                          1864      ;D1 WILL HAVE OUR DISPLACEMENT (0E32)
00001CA4                          1865      ;ADD 0E32 TO PC + 2
00001CA4  3E01                    1866      MOVE.W  D1,D7
00001CA6  DE4D                    1867      ADD.W   A5,D7
00001CA8                          1868      ;SUBI.B  #2,D7
00001CA8                          1869      
00001CA8  14FC 0009               1870      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001CAC  14FC 0024               1871      MOVE.B  #'$',(A2)+                  ;add '$' to buffer
00001CB0                          1872      
00001CB0                          1873      ;convert to ASCII and put on buffer
00001CB0                          1874      ;D7 HAS DISPLACEMENT   
00001CB0  4EB9 00001CBA           1875      JSR     BRANCH_16_ITOA
00001CB6                          1876      
00001CB6  4EF8 191E               1877      JMP     EA_FINISH
00001CBA                          1878  
00001CBA                          1879  EA_BRANCH_32:
00001CBA                          1880      ;come back and implement branch 32
00001CBA                          1881  
00001CBA                          1882  
00001CBA                          1883  
00001CBA                          1884  BRANCH_16_ITOA:
00001CBA                          1885      ;D7 HAS OUR DISPLACEMENT... CONVERT TO ASCII!   ;D7 = 1234
00001CBA  E04F                    1886      LSR.W   #right8,D7                              ;D7 = 0012
00001CBC  4EB9 00001F08           1887      JSR     EA_ITOA_BYTE_CONVERT                    ;BUFFER WILL HAVE 12
00001CC2  3E1D                    1888      MOVE.W  (A5)+,D7                                ;D7 = 0E32
00001CC4  DE4D                    1889      ADD.W   A5,D7                                   ;D7 = 123
00001CC6  5507                    1890      SUBI.B  #2,D7                                   ;SUBI 2 to account for post increment of A5
00001CC8  0247 00FF               1891      ANDI.W  #$00FF,D7                               ;D7 = 0034
00001CCC  4EB9 00001F08           1892      JSR     EA_ITOA_BYTE_CONVERT                    ;BUFFER WILL HAVE 1234
00001CD2                          1893      
00001CD2  4EF9 00001F40           1894      JMP     EA_ITOA_DONE
00001CD8                          1895  
00001CD8                          1896  
00001CD8                          1897  EA_MATH:
00001CD8                          1898      ;source mode 3, 4, 5 | source register 0, 1, 2 | destination register 11, 10, 9
00001CD8  14FC 0009               1899      MOVE.B  #$09, (A2)+             ;add a ' ' to buffer
00001CDC  41F9 00001DA0           1900      LEA     EA_MODE_TABLE,A0        ;load mode table
00001CE2                          1901      
00001CE2                          1902      ;isolate source mode
00001CE2  2800                    1903      MOVE.L  D0,D4
00001CE4  E64C                    1904      LSR.W   #3,D4
00001CE6  0244 0007               1905      ANDI.W  #$7,D4
00001CEA  C8FC 0006               1906      MULU    #6,D4
00001CEE                          1907      
00001CEE                          1908      ;isolate source register
00001CEE  2A00                    1909      MOVE.L  D0,D5
00001CF0  0245 0007               1910      ANDI.W  #$7,D5
00001CF4                          1911      
00001CF4  4EB9 00001D9C           1912      JSR     EA_JMP_HELPER
00001CFA                          1913      
00001CFA  14FC 002C               1914      MOVE.B  #',',(A2)+              ;add a ',' to buffer
00001CFE                          1915      
00001CFE                          1916      ;condition for ADDA - opcode == 1101 && bits 7,6 == 11
00001CFE                          1917      ;check for ADDA and leave if yes, otherwise continue
00001CFE  2200                    1918      MOVE.L  D0,D1                   ;complete opcode in D1
00001D00  EC49                    1919      LSR.W   #6,D1                   ;shift right 6
00001D02  EC49                    1920      LSR.W   #6,D1                   ;shift another 6 to = 12 total
00001D04                          1921      
00001D04  B27C 000D               1922      CMP     #$D,D1                  ;check if opcode = 1101
00001D08  6600 002C               1923      BNE     EA_MATH_CONTINUE        ;if not 1101, skip and go to math
00001D0C                          1924      
00001D0C                          1925      ;if we are here, we know opcode is 1101 and further check
00001D0C  2200                    1926      MOVE.L  D0,D1
00001D0E  EC49                    1927      LSR.W   #6,D1
00001D10  0241 0003               1928      ANDI.W  #3,D1
00001D14  B23C 0003               1929      CMP.B   #3,D1
00001D18  6600 001C               1930      BNE     EA_MATH_CONTINUE
00001D1C                          1931      
00001D1C                          1932      ;if d1 == 3, both conditions met so process as ADDA
00001D1C                          1933      ;destination mode is 1 (address register)
00001D1C  7801                    1934      MOVE.L  #1,D4
00001D1E  C8FC 0006               1935      MULU    #6,D4
00001D22                          1936      
00001D22                          1937      ;isolate destination register 
00001D22  2A00                    1938      MOVE.L  D0,D5
00001D24  E84D                    1939      LSR.W   #4,D5
00001D26  EA4D                    1940      LSR.W   #5,D5                      
00001D28  0245 0007               1941      ANDI.W  #$7,D5   
00001D2C                          1942   
00001D2C  4EB9 00001D9C           1943      JSR     EA_JMP_HELPER 
00001D32  4EF8 191E               1944      JMP     EA_FINISH
00001D36                          1945          
00001D36                          1946  EA_MATH_CONTINUE:       
00001D36                          1947      ;destination mode is 0 (data register)
00001D36  7800                    1948      MOVE.L  #0,D4
00001D38  C8FC 0006               1949      MULU    #6,D4
00001D3C                          1950      
00001D3C                          1951      ;isolate destination register 
00001D3C  2A00                    1952      MOVE.L  D0,D5
00001D3E  E84D                    1953      LSR.W   #4,D5
00001D40  EA4D                    1954      LSR.W   #5,D5                      
00001D42  0245 0007               1955      ANDI.W  #$7,D5  
00001D46                          1956      
00001D46  4EB9 00001D9C           1957      JSR     EA_JMP_HELPER 
00001D4C  4EF8 191E               1958      JMP     EA_FINISH
00001D50                          1959      
00001D50                          1960  
00001D50                          1961  EA_ROTATION:
00001D50  14FC 0009               1962      MOVE.B  #$09, (A2)+                 ;adds a ' ' to buffer
00001D54  2200                    1963      MOVE.L  D0,D1                       ;complete opcode
00001D56  EA49                    1964      LSR.W   #5,D1                       ;shift right 5
00001D58  0241 0001               1965      ANDI.W  #1,D1
00001D5C                          1966      
00001D5C  B27C 0000               1967      CMP     #0,D1
00001D60  6700 002E               1968      BEQ     EA_ROTATION_IMMEDIATE       ;it is immediate value
00001D64  6000 0030               1969      BRA     EA_ROTATION_REGISTER        ;else register 
00001D68                          1970  
00001D68                          1971  EA_ROTATION_CONTINUE:
00001D68  2200                    1972      MOVE.L  D0,D1                       ;get rotation value
00001D6A  0241 0F00               1973      ANDI.W  #nibble2,D1                 ;isolate nibble 2
00001D6E  E049                    1974      LSR.W   #8,D1
00001D70  E249                    1975      LSR.W   #1,D1                       :total of 9 shifts right
00001D72                          1976      
00001D72                          1977      ;at this point we have our number, so convert to ASCII and put on buffer
00001D72  0601 0030               1978      ADDI.B  #$30,D1                     ;convert to ASCII
00001D76  14C1                    1979      MOVE.B  D1,(A2)+                    ;put on buffer
00001D78                          1980      
00001D78  14FC 002C               1981      MOVE.B  #',',(A2)+                  ;add ',' to buffer 
00001D7C  14FC 0044               1982      MOVE.B  #'D',(A2)+                  ;add 'D' to buffer
00001D80                          1983      
00001D80  2200                    1984      MOVE.L  D0,D1                       ;complete opcode
00001D82  0241 0007               1985      ANDI.W  #7,D1                       
00001D86                          1986      
00001D86  0601 0030               1987      ADDI.B  #$30,D1                     ;convert to ASCII
00001D8A  14C1                    1988      MOVE.B  D1,(A2)+                    ;put on buffer
00001D8C                          1989      
00001D8C  4EF8 191E               1990      JMP     EA_FINISH                   ;done
00001D90                          1991  
00001D90                          1992  EA_ROTATION_IMMEDIATE:
00001D90  14FC 0023               1993      MOVE.B  #'#',(A2)+                  ;add '#' to buffer
00001D94  60D2                    1994      BRA     EA_ROTATION_CONTINUE
00001D96                          1995      
00001D96                          1996  EA_ROTATION_REGISTER:
00001D96  14FC 0044               1997      MOVE.B  #'D',(A2)+                  ;add '#' to buffer
00001D9A  60CC                    1998      BRA     EA_ROTATION_CONTINUE
00001D9C                          1999      
00001D9C                          2000  EA_JMP_HELPER
00001D9C  4EF0 4000               2001      JMP     0(A0,D4)
00001DA0                          2002  
00001DA0                          2003  
00001DA0                          2004  ;********************************************  EA_MODE_TABLE  ****************************************************  
00001DA0                          2005  EA_MODE_TABLE:
00001DA0  4EF9 00001DD0           2006      JMP     EA_MODE_000
00001DA6  4EF9 00001DDE           2007      JMP     EA_MODE_001
00001DAC  4EF9 00001DEC           2008      JMP     EA_MODE_010
00001DB2  4EF9 00001E02           2009      JMP     EA_MODE_011
00001DB8  4EF9 00001E1C           2010      JMP     EA_MODE_100
00001DBE  4EF9 00001E34           2011      JMP     EA_MODE_101
00001DC4  4EF9 00001E34           2012      JMP     EA_MODE_110
00001DCA  4EF9 00001E34           2013      JMP     EA_MODE_111
00001DD0                          2014      ;JMP     EA_MODE_FINISH
00001DD0                          2015  
00001DD0                          2016  ;********************************************  EA_MODE_XXX  ****************************************************    
00001DD0                          2017  EA_MODE_000:                                        ;Data register 'Dn'
00001DD0  14FC 0044               2018      MOVE.B  #'D',(A2)+                              ;put D on buffer
00001DD4  1605                    2019      MOVE.B D5,D3                                    ;move to d3 for conversion
00001DD6  4EB9 00001E74           2020      JSR     EA_HEX_TO_ASCII                         ;puts register on buffer  
00001DDC  4E75                    2021      RTS
00001DDE                          2022      
00001DDE                          2023  EA_MODE_001:                                        ;Address Register 'An'
00001DDE  14FC 0041               2024      MOVE.B  #'A',(A2)+                              ;put A on buffer
00001DE2  1605                    2025      MOVE.B  D5,D3                                   ;move to d3 for conversion
00001DE4  4EB9 00001E74           2026      JSR     EA_HEX_TO_ASCII                         ;puts register on buffer  
00001DEA  4E75                    2027      RTS
00001DEC                          2028  
00001DEC                          2029  EA_MODE_010:                                        ;Address direct --> '(An)'
00001DEC  14FC 0028               2030      MOVE.B  #'(',(A2)+                              ;put ( on buffer
00001DF0  14FC 0041               2031      MOVE.B  #'A',(A2)+                              ;put A on buffer
00001DF4  1605                    2032      MOVE.B  D5,D3                                   ;move to D3 for conversion
00001DF6  4EB9 00001E74           2033      JSR     EA_HEX_TO_ASCII                         ;convert and put on buffer   
00001DFC  14FC 0029               2034      MOVE.B  #')',(A2)+                              ;put ) on buffer
00001E00  4E75                    2035      RTS
00001E02                          2036  
00001E02                          2037  EA_MODE_011:                                        ;Address with Postincrement --> '(An)+' 
00001E02  14FC 0028               2038      MOVE.B  #'(',(A2)+                              ;put ( on buffer
00001E06  14FC 0041               2039      MOVE.B  #'A',(A2)+                              ;put A on buffer
00001E0A  1605                    2040      MOVE.B  D5,D3                                   ;move to D3 for conversion
00001E0C  4EB9 00001E74           2041      JSR     EA_HEX_TO_ASCII                         ;convert and put on buffer   
00001E12  14FC 0029               2042      MOVE.B  #')',(A2)+                              ;put ) on buffer
00001E16  14FC 002B               2043      MOVE.B  #'+',(A2)+                              ;put + on buffer
00001E1A  4E75                    2044      RTS
00001E1C                          2045  
00001E1C                          2046  EA_MODE_100:                                        ;Address with Predecrement --> '-(An)'
00001E1C  14FC 002D               2047      MOVE.B  #'-',(A2)+                              ;put - on buffer
00001E20  14FC 0028               2048      MOVE.B  #'(',(A2)+                              ;put ( on buffer
00001E24  14FC 0041               2049      MOVE.B  #'A',(A2)+                              ;put A on buffer
00001E28  1605                    2050      MOVE.B  D5,D3                                   ;move to D3 for conversion
00001E2A  4EB9 00001E74           2051      JSR     EA_HEX_TO_ASCII                         ;convert and put on buffer   
00001E30  14FC 0029               2052      MOVE.B  #')',(A2)+                              ;put ) on buffer
00001E34                          2053  
00001E34                          2054  
00001E34                          2055  
00001E34                          2056  ;unsupported
00001E34                          2057  EA_MODE_101:                                        
00001E34                          2058  ;Address with Displacement --> '(d16, An)
00001E34                          2059      
00001E34                          2060  ;unsupported
00001E34                          2061  EA_MODE_110:
00001E34                          2062  
00001E34                          2063  
00001E34                          2064  
00001E34                          2065  ;some form of immediate data: short, long, immediate
00001E34                          2066  EA_MODE_111:
00001E34                          2067      ;D4 = MODE | D5 = register (000, 001, 100)
00001E34                          2068      ;000 = Absolute Short (xxx).w
00001E34                          2069      ;001 = Absolute Long (xxx).l
00001E34                          2070      ;100 = Immediate data
00001E34                          2071      
00001E34  BA3C 0000               2072      CMP.B   #000,D5
00001E38  6700 0012               2073      BEQ     EA_111_ABSOLUTE_SHORT
00001E3C  BA3C 0001               2074      CMP.B   #001,D5
00001E40  6700 001E               2075      BEQ     EA_111_ABSOLUTE_LONG
00001E44  BA3C 0064               2076      CMP.B   #100,D5
00001E48  6700 002A               2077      BEQ     EA_111_IMMEDIATE
00001E4C                          2078      
00001E4C                          2079      ;HANDLE ERROR
00001E4C                          2080              
00001E4C                          2081      
00001E4C                          2082  EA_111_ABSOLUTE_SHORT:
00001E4C                          2083      ;A5 is looking at correct spot
00001E4C                          2084      ;ADD WORD VALUE AT A5 ON TO BUFFER AT A2 AND INCREMENT BY WORD
00001E4C  14FC 0024               2085      MOVE.B  #'$',(A2)+                              ;put $ on buffer
00001E50  3E15                    2086      MOVE.W  (A5),D7
00001E52  4246                    2087      CLR     D6
00001E54  1C3C 0001               2088      MOVE.B  #01,D6                                  ;word size in EA_ITOA_IMMEDIATE
00001E58  4EB9 00001EA6           2089      JSR     EA_ITOA_IMMEDIATE
00001E5E  4E75                    2090      RTS
00001E60                          2091  
00001E60                          2092  EA_111_ABSOLUTE_LONG:
00001E60  14FC 0024               2093      MOVE.B  #'$',(A2)+                              ;put $ on buffer
00001E64  3E15                    2094      MOVE.W  (A5),D7
00001E66  4246                    2095      CLR     D6
00001E68  1C3C 0002               2096      MOVE.B  #02,D6                                  ;long size in EA_ITOA_IMMEDIATE        
00001E6C  4EB9 00001EA6           2097      JSR     EA_ITOA_IMMEDIATE
00001E72  4E75                    2098      RTS
00001E74                          2099  
00001E74                          2100  EA_111_IMMEDIATE:
00001E74                          2101      
00001E74                          2102  
00001E74                          2103     
00001E74                          2104      
00001E74                          2105  
00001E74                          2106  EA_HEX_TO_ASCII:
00001E74  0603 0030               2107      ADDI.B      #$30,D3                     ;add $30 to D1 to convert
00001E78  14C3                    2108      MOVE.B      D3,(A2)+                    ;add to buffer and increment to next position
00001E7A  4E75                    2109      RTS     
00001E7C                          2110  
00001E7C                          2111  
00001E7C                          2112  EA_CHECK_SIZE:
00001E7C  4246                    2113      CLR     D6
00001E7E  2C00                    2114      MOVE.L  D0,D6                           ;complete opcode --> D6
00001E80  0246 00F0               2115      ANDI.W  #nibble3,D6                     ;isolating nibble 3
00001E84  EC4E                    2116      LSR.W   #right6,D6                      ;shifting bits 7,6 --> 1,0
00001E86                          2117      
00001E86  BC7C 0000               2118      CMP     #00,D6
00001E8A  6700 000E               2119      BEQ     EA_SIZE_BYTE
00001E8E  BC7C 0001               2120      CMP     #01,D6
00001E92  6700 000A               2121      BEQ     EA_SIZE_WORD
00001E96  6000 000A               2122      BRA     EA_SIZE_LONG
00001E9A                          2123  
00001E9A                          2124  EA_SIZE_BYTE:
00001E9A  3E1D                    2125      MOVE.W  (A5)+,D7
00001E9C                          2126      ;MOVE.B  #4,D3;                          SET UP COUNTER
00001E9C  4E75                    2127      RTS
00001E9E                          2128  
00001E9E                          2129  EA_SIZE_WORD:
00001E9E  3E15                    2130      MOVE.W  (A5),D7
00001EA0                          2131      ;MOVE.B  #4,D3;                          SET UP COUNTER
00001EA0  4E75                    2132      RTS
00001EA2                          2133  
00001EA2                          2134  EA_SIZE_LONG:
00001EA2  3E15                    2135      MOVE.W  (A5),D7
00001EA4                          2136      ;MOVE.B  #8,D3;                          SET UP COUNTER
00001EA4  4E75                    2137      RTS
00001EA6                          2138  
00001EA6                          2139  
00001EA6                          2140  
00001EA6                          2141  EA_ITOA_IMMEDIATE:
00001EA6                          2142      ;D3 = counter, D7 = value to be converted, D6 = size
00001EA6  BC3C 0000               2143      CMP.B   #%00,D6
00001EAA  6700 0012               2144      BEQ     EA_ITOA_BYTE
00001EAE  BC3C 0001               2145      CMP.B   #%01,D6
00001EB2  6700 0016               2146      BEQ     EA_ITOA_WORD
00001EB6  BC3C 0002               2147      CMP.B   #%10,D6     
00001EBA  6700 0024               2148      BEQ     EA_ITOA_LONG
00001EBE                          2149      
00001EBE                          2150  
00001EBE                          2151  ;EA_IT0A_IMMEDIATE_LOOP
00001EBE                          2152  ;    CMP.B   #0,D3                       ;check if loop done
00001EBE                          2153  ;    BEQ     EA_ITOA_FINISH              ;if = 0, loop done
00001EBE                          2154      
00001EBE                          2155  EA_ITOA_BYTE:
00001EBE  4EB9 00001F08           2156      JSR     EA_ITOA_BYTE_CONVERT
00001EC4                          2157      
00001EC4  4EF9 00001F40           2158      JMP     EA_ITOA_DONE
00001ECA                          2159  
00001ECA                          2160  
00001ECA                          2161  EA_ITOA_WORD:
00001ECA  E04F                    2162      LSR.W   #right8,D7
00001ECC  4EB9 00001F08           2163      JSR     EA_ITOA_BYTE_CONVERT
00001ED2  3E1D                    2164      MOVE.W  (A5)+,D7
00001ED4  4EB9 00001F08           2165      JSR     EA_ITOA_BYTE_CONVERT
00001EDA                          2166      
00001EDA  4EF9 00001F40           2167      JMP     EA_ITOA_DONE
00001EE0                          2168      
00001EE0                          2169  EA_ITOA_LONG:
00001EE0  E04F                    2170      LSR.W   #right8,D7
00001EE2  4EB9 00001F08           2171      JSR     EA_ITOA_BYTE_CONVERT
00001EE8  3E1D                    2172      MOVE.W  (A5)+,D7
00001EEA  4EB9 00001F08           2173      JSR     EA_ITOA_BYTE_CONVERT
00001EF0                          2174  
00001EF0  3E15                    2175      MOVE.W  (A5),D7
00001EF2  E04F                    2176      LSR.W   #right8,D7
00001EF4  4EB9 00001F08           2177      JSR     EA_ITOA_BYTE_CONVERT
00001EFA  3E1D                    2178      MOVE.W  (A5)+,D7
00001EFC  4EB9 00001F08           2179      JSR     EA_ITOA_BYTE_CONVERT
00001F02                          2180  
00001F02  4EF9 00001F40           2181      JMP     EA_ITOA_DONE
00001F08                          2182  
00001F08                          2183  EA_ITOA_BYTE_CONVERT:
00001F08  3607                    2184      MOVE.W  D7,D3
00001F0A  0243 00F0               2185      ANDI.W  #$F0,D3
00001F0E  E84B                    2186      LSR.W   #right4,D3
00001F10  4EB9 00001F24           2187      JSR     EA_ITOA_NIBBLE_CONVERT
00001F16                          2188      
00001F16  3607                    2189      MOVE.W  D7,D3
00001F18  0243 000F               2190      ANDI.W  #$0F,D3
00001F1C  4EB9 00001F24           2191      JSR     EA_ITOA_NIBBLE_CONVERT
00001F22  4E75                    2192      RTS
00001F24                          2193  
00001F24                          2194  EA_ITOA_NIBBLE_CONVERT:
00001F24  B63C 0009               2195      CMP.B   #9,D3
00001F28  6E00 000E               2196      BGT     EA_ITOA_LETTER
00001F2C  6000 0002               2197      BRA     EA_ITOA_NUMBER
00001F30                          2198  
00001F30                          2199  EA_ITOA_HEX2ASCII:
00001F30                          2200  
00001F30                          2201  
00001F30                          2202  
00001F30                          2203  EA_ITOA_NUMBER:
00001F30  0603 0030               2204      ADDI.B  #$30,D3
00001F34  14C3                    2205      MOVE.B  D3,(A2)+
00001F36  4E75                    2206      RTS
00001F38                          2207  
00001F38                          2208  EA_ITOA_LETTER:
00001F38  0603 0037               2209      ADDI.B  #$37,D3
00001F3C  14C3                    2210      MOVE.B  D3,(A2)+
00001F3E  4E75                    2211      RTS
00001F40                          2212  
00001F40                          2213  EA_ITOA_DONE
00001F40  4E75                    2214      RTS
00001F42                          2215  
00001F42                          2216      
00001F42                          2217  ;****************************************** MESSAGES ***************************************************
00001F42= 57 65 6C 63 6F 6D ...   2218  welcome_message         DC.B    'Welcome to 68k disassembler',CR,LF,0
00001F60                          2219  
00001F60= 50 6C 65 61 73 65 ...   2220  get_start_address       DC.B    'Please enter a starting address in hexadecimal',CR,LF,0
00001F91                          2221  
00001F91= 50 6C 65 61 73 65 ...   2222  get_end_address         DC.B    'Please enter an ending address in hexadecimal',CR,LF,0
00001FC1                          2223  
00001FC1= 49 6E 76 61 6C 69 ...   2224  atoi_error_invalid      DC.B    'Invalid address, characters must be $0-F',CR,LF,0
00001FEC                          2225  
00001FEC                          2226  
00001FEC= 49 6E 76 61 6C 69 ...   2227  error_message_1         DC.B    'Invalid Address: Must be greater than 0',CR,LF,0
00002016                          2228  
00002016= 49 6E 76 61 6C 69 ...   2229  error_message_2         DC.B    'Invalid Address: Must be even',CR,LF,0
00002036                          2230  
00002036= 49 6E 76 61 6C 69 ...   2231  error_message_3         DC.B    'Invalid Address: Must be even',CR,LF,0
00002056                          2232  
00002056= 49 6E 76 61 6C 69 ...   2233  error_message_4         DC.B    'Invalid Address: Must be less than $00FFFFFF',CR,LF,0
00002085                          2234  
00002085= 49 6E 76 61 6C 69 ...   2235  error_message_5         DC.B    'Invalid Address: Must be greater than starting address',CR,LF,0
000020BE                          2236  
000020BE                          2237  
000020BE                          2238  ascii_start:
000020BE                          2239      DS.w    10          ;specify size later?
000020D2                          2240      
000020D2                          2241  ascii_end:
000020D2                          2242      DS.w    10          ;specify size later?
000020E6                          2243  
000020E6                          2244  buffer                  ;storing op code
000020E6                          2245      DS.W    64          ;do we leave as .w or change to .l ?
00002166                          2246      
00002166                          2247  
00002166                          2248      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_END           20D2
ASCII_START         20BE
ATOI                17A6
ATOI_DONE           1818
ATOI_ERROR          1818
ATOI_ERROR_INVALID  1FC1
ATOI_FORMAT         1808
ATOI_LOOP           17AC
ATOI_LOWERCASE_LETTER  17FE
ATOI_NUMBER         17EA
ATOI_UPPERCASE_LETTER  17F4
BRANCH_16_ITOA      1CBA
BUFFER              20E6
BUFFER_SIZE         40
CR                  D
DECODING_LOOP       1088
DEST_MODE           1C0
DEST_REG            E00
DONE                108E
EA_111_ABSOLUTE_LONG  1E60
EA_111_ABSOLUTE_SHORT  1E4C
EA_111_IMMEDIATE    1E74
EA_BRANCH           1C90
EA_BRANCH_16        1CA2
EA_BRANCH_32        1CBA
EA_CHECK_SIZE       1E7C
EA_DESTONLY         1A2E
EA_EXT              1A2E
EA_FINISH           191E
EA_HEX_TO_ASCII     1E74
EA_IMMEDIATE        1920
EA_ITOA_BYTE        1EBE
EA_ITOA_BYTE_CONVERT  1F08
EA_ITOA_DONE        1F40
EA_ITOA_HEX2ASCII   1F30
EA_ITOA_IMMEDIATE   1EA6
EA_ITOA_LETTER      1F38
EA_ITOA_LONG        1EE0
EA_ITOA_NIBBLE_CONVERT  1F24
EA_ITOA_NUMBER      1F30
EA_ITOA_WORD        1ECA
EA_JMP_HELPER       1D9C
EA_LEA              19EE
EA_MATH             1CD8
EA_MATH_CONTINUE    1D36
EA_MODE_000         1DD0
EA_MODE_001         1DDE
EA_MODE_010         1DEC
EA_MODE_011         1E02
EA_MODE_100         1E1C
EA_MODE_101         1E34
EA_MODE_110         1E34
EA_MODE_111         1E34
EA_MODE_TABLE       1DA0
EA_MOVE             1962
EA_MOVEA            19A8
EA_MOVEM            1A2E
EA_MOVEM_ADDRREG_TO_MEM  1AF2
EA_MOVEM_DATAREG_TO_MEM  1A6C
EA_MOVEM_IMMEDIATE_DESTINATION  1BE2
EA_MOVEM_IMMEDIATE_SOURCE  1BF2
EA_MOVEM_MEM_TO_ADDRREG  1B9E
EA_MOVEM_MEM_TO_DATAREG  1B80
EA_MOVEM_MEM_TO_REG  1B42
EA_MOVEM_REG_TO_MEM  1A58
EA_QUICK            1C14
EA_QUICK_MOVEQ      1C66
EA_ROTATION         1D50
EA_ROTATION_CONTINUE  1D68
EA_ROTATION_IMMEDIATE  1D90
EA_ROTATION_REGISTER  1D96
EA_SIZE_BYTE        1E9A
EA_SIZE_LONG        1EA2
EA_SIZE_WORD        1E9E
EA_START            18C2
EA_TRAP             1C14
EA_TYPE_BRANCH      9
EA_TYPE_DESTONLY    4
EA_TYPE_EXT         5
EA_TYPE_IMMEDIATE   0
EA_TYPE_LEA         3
EA_TYPE_MATH        A
EA_TYPE_MOVE        1
EA_TYPE_MOVEA       2
EA_TYPE_MOVEA6      C
EA_TYPE_MOVEM       6
EA_TYPE_QUICK       8
EA_TYPE_ROTATION    B
EA_TYPE_TABLE       18D0
EA_TYPE_TRAP        7
ENDA_ERROR_LARGE    18A2
ENDA_ERROR_LESS_THAN_STARTA  18B2
ENDA_ERROR_NOT_EVEN  1892
ERROR_MESSAGE_1     1FEC
ERROR_MESSAGE_2     2016
ERROR_MESSAGE_3     2036
ERROR_MESSAGE_4     2056
ERROR_MESSAGE_5     2085
GET_ENDING_ADDRESS  104A
GET_END_ADDRESS     1F91
GET_STARTING_ADDRESS  1012
GET_START_ADDRESS   1F60
ITOA                181C
ITOA_ADDRESS        1826
ITOA_ADDRESS_LOOP   1834
ITOA_BYTE           1826
ITOA_FINISH         1870
ITOA_HEX2ASCII      1850
ITOA_LETTER         1868
ITOA_LONG           1826
ITOA_LOOP           181E
ITOA_NUMBER         1860
ITOA_WORD           1826
LF                  A
LINES_PER_SCREEN    1E
MOVEM_CARRY         1BC6
MOVEM_CHECK_MULTIPLE  1AC4
MOVEM_LOOP          1BBE
MOVEM_MULTIPLE      1ACC
MOVEM_MULTIPLE_A    1AEA
MOVEM_MULTIPLE_D    1AE2
MOVEM_SET_MIN       1BD6
NIBBLE1             F000
NIBBLE2             F00
NIBBLE3             F0
NIBBLE4             F
OPCODE0000          1140
OPCODE0001          115A
OPCODE0010          1160
OPCODE0011          117A
OPCODE0100          1194
OPCODE0101          11AE
OPCODE0110          11CA
OPCODE0111          11E4
OPCODE1000          11EA
OPCODE1001          1206
OPCODE1010          120C
OPCODE1011          1212
OPCODE1100          1218
OPCODE1101          1234
OPCODE1110          1250
OPCODE1111          1270
OP_0000_TABLE       1276
OP_0100_TABLE       12D6
OP_0110_TABLE       1336
OP_ADD              16A8
OP_ADDA             16C6
OP_ADDI             13F8
OP_ADDQ             1568
OP_AND              16A8
OP_ANDI             13B4
OP_ASL              16E8
OP_ASR              1706
OP_BEQ              15DC
OP_BRA              15AC
OP_BSR              15C4
OP_CHECK_SIZE       1724
OP_CHECK_SIZE_ADDA  178A
OP_CHECK_SIZE_MOVEM  1748
OP_CLR              1568
OP_CMP              1652
OP_CMPI             143C
OP_DATA_CLR         10CA
OP_DATA_CLR_LOOP    10D6
OP_DIVS             1618
OP_DIVU             15FC
OP_EOR              1670
OP_EORI             141A
OP_EXT              1568
OP_FINISH           10C4
OP_JMP              1568
OP_JSR              1568
OP_LEA              1550
OP_LSL              1724
OP_LSR              1724
OP_MOVEAL           1482
OP_MOVEAW           14CE
OP_MOVEB            145E
OP_MOVEL            14AA
OP_MOVEM            152A
OP_MOVEQ            15DC
OP_MOVEW            14F6
OP_MULS             168C
OP_MULU             1670
OP_NOP              151A
OP_NOT              1568
OP_OR               1634
OP_ORI              1396
OP_ROL              1724
OP_ROR              1724
OP_RTE              1568
OP_RTS              1568
OP_SIZE_BYTE        176C
OP_SIZE_LONG        1780
OP_SIZE_WORD        1776
OP_START            1092
OP_STOP             1568
OP_SUB              1634
OP_SUBI             13D6
OP_SUBQ             158A
OP_TABLE            10E0
OP_TRAP             1568
OP_UNSUPPORTED_OPCODE  1724
RIGHT1              1
RIGHT10             A
RIGHT12             C
RIGHT16             10
RIGHT2              2
RIGHT24             18
RIGHT3              3
RIGHT4              4
RIGHT5              5
RIGHT6              6
RIGHT7              7
RIGHT8              8
RIGHT9              9
STACK               A0000
START               1000
STARTA_ERROR_LESS_THAN_ZERO  1872
STARTA_ERROR_NOT_EVEN  1882
START_DECODING      1088
VALIDATE_BEGINNING  1872
WELCOME             1006
WELCOME_MESSAGE     1F42
